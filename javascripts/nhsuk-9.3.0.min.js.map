{"version":3,"sources":["nhsuk.js","../packages/polyfills.js","../webpack/bootstrap","../packages/components/button/button.js","../packages/components/character-count/character-count.js","../packages/common.js","../packages/components/checkboxes/checkboxes.js","../packages/components/details/details.js","../packages/components/error-summary/error-summary.js","../packages/components/header/header.js","../packages/components/tabs/tabs.js","../packages/nhsuk.js","../packages/components/radios/radios.js","../packages/components/skip-link/skip-link.js"],"names":["__webpack_modules__","NodeList","prototype","forEach","Array","includes","Object","defineProperty","enumerable","value","obj","this","filter","el","length","Element","matches","msMatchesSelector","webkitMatchesSelector","closest","s","call","parentElement","parentNode","nodeType","window","CustomEvent","event","params","bubbles","cancelable","detail","evt","document","createEvent","initCustomEvent","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","Button","$module","KEY_SPACE","DEBOUNCE_TIMEOUT_IN_SECONDS","debounceFormSubmitTimer","_proto","handleKeyDown","target","getAttribute","keyCode","preventDefault","click","debounce","_this","setTimeout","init","addEventListener","bind","CharacterCount","$textarea","querySelector","$visibleCountMessage","$screenReaderCountMessage","lastInputTimestamp","$fallbackLimitMessage","getElementById","id","insertAdjacentElement","createElement","className","setAttribute","classList","add","options","getDataset","countAttribute","defaults","characterCountAttribute","maxwords","wordCountAttribute","maxLength","removeAttribute","bindChangeEvents","updateCountMessage","element","dataset","attributes","i","attribute","match","name","count","text","handleKeyUp","handleFocus","handleBlur","checkIfValueChanged","oldValue","updateVisibleCountMessage","updateScreenReaderCountMessage","remainingNumber","isOverThreshold","remove","innerHTML","formattedUpdateMessage","charVerb","charNoun","Math","abs","currentLength","threshold","Date","now","valueChecker","setInterval","clearInterval","toggleAttribute","attr","toggleConditionalInput","input","conditionalId","conditionalElement","checked","syncAllConditionalReveals","form","querySelectorAll","item","checkboxes","_temp","_ref$scope","scope","checkboxInputs","handleClick","hasAttribute","inputWithSameName","exclusiveInput","unCheckExclusiveInputs","checkboxButton","details","open","allDetails","index","content","summary","style","display","initDetails","focusTarget","tagName","href","hash","legendOrLabel","fieldset","legends","getElementsByTagName","candidateLegend","type","legendTop","getBoundingClientRect","top","inputRect","height","innerHeight","getAssociatedLegendOrLabel","scrollIntoView","focus","preventScroll","Header","menuIsOpen","navigation","navigationList","mobileMenu","mobileMenuToggleButton","mobileMenuCloseButton","mobileMenuContainer","breakpoints","width","body","offsetWidth","setupMobileMenu","calculateBreakpoints","updateNavigation","doOnOrientationChange","handleResize","toggleMobileMenu","func","timeout","timer","_this2","_len","arguments","args","_key","clearTimeout","apply","gapPixels","getComputedStyle","getPropertyValue","gap","Number","replace","childrenWidth","children","appendChild","closeMobileMenu","marginBottom","removeEventListener","handleEscapeKey","e","key","openMobileMenu","marginBody","offsetHeight","availableSpace","itemsVisible","insertBefore","firstChild","removeChild","_this3","orientation","Tabs","namespace","responsive","historyEnabled","$tabs","keys","down","left","right","up","jsHiddenClass","showEvent","hideEvent","matchMedia","setupResponsiveChecks","setup","mql","checkMode","addListener","teardown","$tabList","$tabListItems","$item","$tab","setAttributes","boundTabClick","onTabClick","boundTabKeydown","onTabKeydown","hideTab","$activeTab","getTab","location","showTab","boundOnHashChange","onHashChange","unsetAttributes","$tabWithHash","changingHash","$previousTab","getCurrentTab","unhighlightTab","hidePanel","highlightTab","showPanel","panelId","getHref","slice","$panel","getPanel","contains","stopPropagation","$newTab","$currentTab","createHistoryEntry","activatePreviousTab","activateNextTab","nextTab","currentTab","nextTabListItem","nextElementSibling","previousTab","previousTabListItem","previousElementSibling","dispatchEvent","tab","indexOf","initAll","initCharacterCount","initCheckboxes","_ref","_ref$focusOnPageLoad","focusOnPageLoad","errorSummary","initErrorSummary","radioInputs","radioButton","initRadios","_ref$namespace","_ref$responsive","_ref$historyEnabled","initTabs","$skipLink","HTMLAnchorElement","linkedElementId","split","pop","$linkedElement","$element","isFocusable","onBlur","onFocus","onBeforeFocus","setFocus","initSkipLink"],"mappings":"CAAS,WACC,IAAIA,EAAsB,CAE9B,IACA,WCDDC,SAASC,UAAUC,UACtBF,SAASC,UAAUC,QAAUC,MAAMF,UAAUC,SAM1CC,MAAMF,UAAUG,UAEnBC,OAAOC,eAAeH,MAAMF,UAAW,WAAY,CACjDM,YAAY,EACZC,MAAK,SAACC,GACJ,OAAOC,KAAKC,QAAO,SAACC,GAAE,OAAKA,IAAOH,CAAG,IAAEI,OAAS,CAClD,IAOCC,QAAQb,UAAUc,UACrBD,QAAQb,UAAUc,QAChBD,QAAQb,UAAUe,mBAClBF,QAAQb,UAAUgB,uBAGjBH,QAAQb,UAAUiB,UACrBJ,QAAQb,UAAUiB,QAAU,SAAUC,GACpC,IAAIP,EAAKF,KAET,EAAG,CACD,GAAII,QAAQb,UAAUc,QAAQK,KAAKR,EAAIO,GAAI,OAAOP,EAClDA,EAAKA,EAAGS,eAAiBT,EAAGU,UAC9B,OAAgB,OAAPV,GAA+B,IAAhBA,EAAGW,UAC3B,OAAO,IACT,GAMgC,mBAAvBC,OAAOC,cAChBD,OAAOC,YAAc,SAAUC,EAAOC,GACpCA,EAASA,GAAU,CAAEC,SAAS,EAAOC,YAAY,EAAOC,OAAQ,MAChE,IAAIC,EAAMC,SAASC,YAAY,eAE/B,OADAF,EAAIG,gBAAgBR,EAAOC,EAAOC,QAASD,EAAOE,WAAYF,EAAOG,QAC9DC,CACT,EDWK,GE5DPI,EAAA,CAAA,EAGA,SAAAC,EAAAC,GAEA,IAAAC,EAAAH,EAAAE,GACA,QAAAE,IAAAD,EACA,OAAAA,EAAAE,QAGA,IAAAC,EAAAN,EAAAE,GAAA,CAGAG,QAAA,CAAA,GAOA,OAHAzC,EAAAsC,GAAAI,EAAAA,EAAAD,QAAAJ,GAGAK,EAAAD,OACA,EFqEC,WACD,aAKA,IGjGME,EAAM,WACV,SAAAA,EAAYC,GACVjC,KAAKkC,UAAY,GACjBlC,KAAKmC,4BAA8B,EAEnCnC,KAAKiC,QAAUA,EACfjC,KAAKoC,wBAA0B,IACjC,CAEA,IAAAC,EAAAL,EAAAzC,UAsDC,OAtDD8C,EASAC,cAAA,SAActB,GAGZ,IAAQuB,EAAWvB,EAAXuB,OAG0B,WAAhCA,EAAOC,aAAa,SACpBxB,EAAMyB,UAAYzC,KAAKkC,YAEvBlB,EAAM0B,iBAENH,EAAOI,QAEX,EAEAN,EAKAO,SAAA,SAAS5B,GAAO,IAAA6B,EAAA7C,KAGd,GAAyD,SAFtCgB,EAAXuB,OAEGC,aAAa,6BAKxB,OAAIxC,KAAKoC,yBACPpB,EAAM0B,kBACC,QAGT1C,KAAKoC,wBAA0BU,YAAW,WACxCD,EAAKT,wBAA0B,IACjC,GAAsC,IAAnCpC,KAAKmC,6BACV,EAEAE,EAIAU,KAAA,WACE/C,KAAKiC,QAAQe,iBAAiB,UAAWhD,KAAKsC,cAAcW,KAAKjD,OACjEA,KAAKiC,QAAQe,iBAAiB,QAAShD,KAAK4C,SAASK,KAAKjD,MAC5D,EAACgC,CAAA,CA/DS,GCANkB,EAAc,WAClB,SAAAA,EAAYjB,GACVjC,KAAKiC,QAAUA,EACfjC,KAAKmD,UAAYlB,EAAQmB,cAAc,6BACvCpD,KAAKqD,qBAAuB,KAC5BrD,KAAKsD,0BAA4B,KACjCtD,KAAKuD,mBAAqB,IAC5B,CAEA,IAAAlB,EAAAa,EAAA3D,UA4PC,OA5PD8C,EACAU,KAAA,WAEE,GAAK/C,KAAKmD,UAAV,CAKA,IAAQlB,EAAYjC,KAAZiC,QACAkB,EAAcnD,KAAdmD,UACFK,EAAwBlC,SAASmC,eAClCN,EAAUO,GAAE,SAKjBP,EAAUQ,sBAAsB,WAAYH,GAI5C,IAAMF,EAA4BhC,SAASsC,cAAc,OACzDN,EAA0BO,UACxB,2DACFP,EAA0BQ,aAAa,YAAa,UACpD9D,KAAKsD,0BAA4BA,EACjCE,EAAsBG,sBACpB,WACAL,GAKF,IAAMD,EAAuB/B,SAASsC,cAAc,OACpDP,EAAqBQ,UAAYL,EAAsBK,UACvDR,EAAqBU,UAAUC,IAAI,iCACnCX,EAAqBS,aAAa,cAAe,QACjD9D,KAAKqD,qBAAuBA,EAC5BG,EAAsBG,sBACpB,WACAN,GAIFG,EAAsBO,UAAUC,IAAI,2BAGpChE,KAAKiE,QAAUf,EAAegB,WAAWjC,GAGzC,IAAIkC,EAAiBnE,KAAKoE,SAASC,wBAC/BrE,KAAKiE,QAAQK,WACfH,EAAiBnE,KAAKoE,SAASG,oBAIjCvE,KAAKwE,UAAYvC,EAAQO,aAAa2B,GAGjCnE,KAAKwE,YAKVrB,EAAUsB,gBAAgB,aAE1BzE,KAAK0E,mBAMD,eAAgB5D,OAClBA,OAAOkC,iBAAiB,WAAYhD,KAAK2E,mBAAmB1B,KAAKjD,OAEjEc,OAAOkC,iBACL,mBACAhD,KAAK2E,mBAAmB1B,KAAKjD,OAGjCA,KAAK2E,qBA1EL,CA2EF,EAEAzB,EACOgB,WAAP,SAAkBU,GAChB,IAAMC,EAAU,CAAC,EACTC,EAAeF,EAAfE,WACR,GAAIA,EACF,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAW3E,OAAQ4E,IAAK,CAC1C,IAAMC,EAAYF,EAAWC,GACvBE,EAAQD,EAAUE,KAAKD,MAAM,cAC/BA,IACFJ,EAAQI,EAAM,IAAMD,EAAUlF,MAElC,CAEF,OAAO+E,CACT,EAEAxC,EACA8C,MAAA,SAAMC,GACJ,IAAIjF,EACAH,KAAKiE,QAAQK,SAEfnE,GADeiF,EAAKH,MAAM,SAAW,IACrB9E,OAEhBA,EAASiF,EAAKjF,OAEhB,OAAOA,CACT,EAEAkC,EACAqC,iBAAA,WACE,IAAQvB,EAAcnD,KAAdmD,UACRA,EAAUH,iBAAiB,QAAShD,KAAKqF,YAAYpC,KAAKjD,OAG1DmD,EAAUH,iBAAiB,QAAShD,KAAKsF,YAAYrC,KAAKjD,OAC1DmD,EAAUH,iBAAiB,OAAQhD,KAAKuF,WAAWtC,KAAKjD,MAC1D,EAIAqC,EACAmD,oBAAA,WACOxF,KAAKmD,UAAUsC,WAClBzF,KAAKmD,UAAUsC,SAAW,IAExBzF,KAAKmD,UAAUrD,QAAUE,KAAKmD,UAAUsC,WAC1CzF,KAAKmD,UAAUsC,SAAWzF,KAAKmD,UAAUrD,MACzCE,KAAK2E,qBAET,EAGAtC,EACAsC,mBAAA,WACE3E,KAAK0F,4BACL1F,KAAK2F,gCACP,EAEAtD,EACAqD,0BAAA,WACE,IAAQvC,EAAcnD,KAAdmD,UACAE,EAAyBrD,KAAzBqD,qBACFuC,EAAkB5F,KAAKwE,UAAYxE,KAAKmF,MAAMhC,EAAUrD,OAI1DE,KAAK6F,kBACPxC,EAAqBU,UAAU+B,OAC7B,4CAGFzC,EAAqBU,UAAUC,IAC7B,4CAKA4B,EAAkB,GACpBzC,EAAUY,UAAUC,IAAI,yBACxBX,EAAqBU,UAAU+B,OAAO,cACtCzC,EAAqBU,UAAUC,IAAI,yBAEnCb,EAAUY,UAAU+B,OAAO,yBAC3BzC,EAAqBU,UAAU+B,OAAO,uBACtCzC,EAAqBU,UAAUC,IAAI,eAIrCX,EAAqB0C,UAAY/F,KAAKgG,wBACxC,EAEA3D,EACAsD,+BAAA,WACE,IAAQrC,EAA8BtD,KAA9BsD,0BAIJtD,KAAK6F,kBACPvC,EAA0BmB,gBAAgB,eAE1CnB,EAA0BQ,aAAa,eAAe,GAIxDR,EAA0ByC,UAAY/F,KAAKgG,wBAC7C,EAEA3D,EACA2D,uBAAA,WACE,IAIIC,EAJI9C,EAAcnD,KAAdmD,UACAc,EAAYjE,KAAZiE,QACF2B,EAAkB5F,KAAKwE,UAAYxE,KAAKmF,MAAMhC,EAAUrD,OAG1DoG,EAAW,YAUf,OARIjC,EAAQK,WACV4B,EAAW,QAEbA,IAAiC,IAArBN,GAA8C,IAApBA,EAAwB,GAAK,IAEnEK,EAAWL,EAAkB,EAAI,WAAa,YAG9C,YAFgBO,KAAKC,IAAIR,GAEO,IAAIM,EAAQ,IAAID,CAClD,EAIA5D,EACAwD,gBAAA,WACE,IAAQ1C,EAAcnD,KAAdmD,UACAc,EAAYjE,KAAZiE,QAGFoC,EAAgBrG,KAAKmF,MAAMhC,EAAUrD,OAO3C,OANsBE,KAAdwE,WAGiBP,EAAQqC,UAAYrC,EAAQqC,UAAY,GACT,KAE/BD,CAC3B,EAGAhE,EACAgD,YAAA,WACErF,KAAK0F,4BACL1F,KAAKuD,mBAAqBgD,KAAKC,KACjC,EAACnE,EAEDiD,YAAA,WAAc,IAAAzC,EAAA7C,KAKZA,KAAKyG,aAAeC,aAAY,aAE3B7D,EAAKU,oBACNgD,KAAKC,MAAQ,KAAO3D,EAAKU,qBAEzBV,EAAK2C,qBAET,GAAG,IACL,EAACnD,EAEDkD,WAAA,WAEEoB,cAAc3G,KAAKyG,aACrB,EAACvD,CAAA,CArQiB,GAwQpBA,EAAe3D,UAAU6E,SAAW,CAClCC,wBAAyB,iBACzBE,mBAAoB,iBAGtB,ICxQaqC,EAAkB,SAAChC,EAASiC,GAEvC,GAAKjC,GAAYiC,EAAjB,CAEA,IAAM/G,EAAuC,SAA/B8E,EAAQpC,aAAaqE,GAAmB,QAAU,OAChEjC,EAAQd,aAAa+C,EAAM/G,EAHJ,CAIzB,EAOagH,EAAyB,SAACC,EAAOlD,GAE5C,GAAKkD,GAAUlD,EAAf,CAEA,IAAMmD,EAAgBD,EAAMvE,aAAa,iBACzC,GAAIwE,EAAe,CAEjB,IAAMC,EAAqB3F,SAASmC,eAAeuD,GAC/CC,IACEF,EAAMG,SACRD,EAAmBlD,UAAU+B,OAAOjC,GACpCkD,EAAMjD,aAAa,iBAAiB,KAEpCmD,EAAmBlD,UAAUC,IAAIH,GACjCkD,EAAMjD,aAAa,iBAAiB,IAG1C,CAf0B,CAgB5B,EC9BA,IAAMqD,EAA4B,SAAmCJ,GAC3CA,EAAMK,KAAKC,iBAAiB,0BACpC7H,SAAQ,SAAC8H,GAAI,OAC3BR,EAAuBQ,EAAM,wCAAwC,GAEzE,EA+CAC,EAAA,SAAeC,GAA+B,IAALC,QAAK,IAAAD,EAAP,CAAC,EAACA,GAAvBE,MAEVC,QAFe,IAAAF,EAAGnG,SAAQmG,GAEHJ,iBAC3B,8CAOIO,EAAc,SAAC5G,GAjDQ,IAAgC+F,GAmD3DD,EACE9F,EAAMuB,OACN,yCAGGvB,EAAMuB,OAAO2E,WAKdlG,EAAMuB,OAAOsF,aAAa,6BA7D6Bd,EA8DlC/F,EAAMuB,QA7DW6E,KAAKC,iBAAgB,yDACNN,EAAMvE,aAAa,iCAAgC,MAGhFhD,SAAQ,SAACsI,GACZf,EAAMK,OAASU,EAAkBV,MAClCU,IAAsBf,IAC5Ce,EAAkBZ,SAAU,EAEhC,IAEAC,EAA0BJ,IAUG,SAAgCA,GACdA,EAAMK,KAAKC,iBAAgB,kFACUN,EAAMvE,aACtF,iCACD,MAGoChD,SAAQ,SAACuI,GACrBhB,EAAMK,OAASW,EAAeX,OAErDW,EAAeb,SAAU,EAE7B,IAEAC,EAA0BJ,EAC5B,CA2BMiB,CAAuBhH,EAAMuB,QAEjC,EAMI,eAAgBzB,OAClBA,OAAOkC,iBAAiB,YAAY,WAAA,OAClC2E,EAAenI,SAAQ,SAACuH,GAAK,OAAKI,EAA0BJ,EAAM,GAAC,IAGrEjG,OAAOkC,iBAAiB,oBAAoB,WAAA,OAC1C2E,EAAenI,SAAQ,SAACuH,GAAK,OAAKI,EAA0BJ,EAAM,GAAC,IAOvEY,EAAenI,SAAQ,SAACuH,GAAK,OAAKI,EAA0BJ,EAAM,IAGlEY,EAAenI,SAAQ,SAACyI,GACtBA,EAAejF,iBAAiB,SAAU4E,EAC5C,GACD,ECvGDM,EAAA,SAAeV,GAA+B,IAALC,QAAK,IAAAD,EAAP,CAAC,EAACA,GAAvBE,MAAAA,OAAK,IAAAD,EAAGnG,SAAQmG,EAIhC,KADoD,kBAA3CnG,SAASsC,cAAc,WAAWuE,MAC3C,CAKA,IAAMC,EAAaV,EAAML,iBAAiB,WA+DtCe,EAAWjI,QACbiI,EAAW5I,SAAQ,SAACoF,EAASyD,GACtBzD,EAAQiD,aAAa,qBA1DV,SAACjD,EAASyD,GAE5BzD,EAAQd,aAAa,mBAAoB,QAGpCc,EAAQlB,IAAIkB,EAAQd,aAAa,KAAI,gBAAkBuE,GAG5D,IAAMC,EAAUZ,EAAMtE,cAAa,IAAKwB,EAAQlB,GAAE,yBAC7C4E,EAAQ5E,IAAI4E,EAAQxE,aAAa,KAAI,sBAAwBuE,GAGlE,IAAME,EAAUb,EAAMtE,cAAa,IAC7BwB,EAAQlB,GAAE,4BAIhB6E,EAAQzE,aAAa,OAAQ,UAC7ByE,EAAQzE,aAAa,gBAAiBwE,EAAQ5E,IAC9C6E,EAAQzE,aAAa,WAAY,MAEhB,IADiC,OAAjCc,EAAQpC,aAAa,UAEpC+F,EAAQzE,aAAa,gBAAiB,QACtCwE,EAAQxE,aAAa,cAAe,WAEpCyE,EAAQzE,aAAa,gBAAiB,SACtCwE,EAAQxE,aAAa,cAAe,QACpCwE,EAAQE,MAAMC,QAAU,QAiB1BF,EAAQvF,iBAAiB,SAdH,WACpB4D,EAAgB2B,EAAS,iBACzB3B,EAAgB0B,EAAS,eAEzBA,EAAQE,MAAMC,QAC4B,SAAxCH,EAAQ9F,aAAa,eAA4B,OAAS,GACxDoC,EAAQiD,aAAa,QACvBjD,EAAQH,gBAAgB,QAExBG,EAAQd,aAAa,OAAQ,OAEjC,IAMAyE,EAAQvF,iBAAiB,WAAW,SAAChC,GACb,KAAlBA,EAAMyB,SAAoC,KAAlBzB,EAAMyB,UAChCzB,EAAM0B,iBACN6F,EAAQ5F,QAEZ,GACF,CAKmD+F,CAAY9D,EAASyD,EACtE,GArEF,CAuED,ECZD,SAASM,EAAYpG,GAEnB,GAAuB,MAAnBA,EAAOqG,UAAmC,IAAhBrG,EAAOsG,KACnC,OAAO,EAGT,IAAM9B,EAAQzF,SAAS8B,cAAcb,EAAOuG,MAC5C,IAAK/B,EACH,OAAO,EAGT,IAAMgC,EApER,SAAoChC,GAClC,IAAMiC,EAAWjC,EAAMvG,QAAQ,YAE/B,GAAIwI,EAAU,CACZ,IAAMC,EAAUD,EAASE,qBAAqB,UAE9C,GAAID,EAAQ9I,OAAQ,CAClB,IAAMgJ,EAAkBF,EAAQ,GAIhC,GAAmB,aAAflC,EAAMqC,MAAsC,UAAfrC,EAAMqC,KACrC,OAAOD,EAST,IAAME,EAAYF,EAAgBG,wBAAwBC,IACpDC,EAAYzC,EAAMuC,wBAIxB,GAAIE,EAAUC,QAAU3I,OAAO4I,aACTF,EAAUD,IAAMC,EAAUC,OAE5BJ,EAAYvI,OAAO4I,YAAc,EACjD,OAAOP,CAGb,CACF,CAEA,OACE7H,SAAS8B,cAAa,cAAe2D,EAAMvE,aAAa,MAAK,OAC7DuE,EAAMvG,QAAQ,QAElB,CA4BwBmJ,CAA2B5C,GACjD,QAAKgC,IAOLA,EAAca,iBACd7C,EAAM8C,MAAM,CAAEC,eAAe,KAEtB,EACT,CAKA,SAASlC,EAAY5G,GACf2H,EAAY3H,EAAMuB,SACpBvB,EAAM0B,gBAEV,CAEA,ICrGMqH,EAAM,WACV,SAAAA,IACE/J,KAAKgK,YAAa,EAClBhK,KAAKiK,WAAa3I,SAAS8B,cAAc,qBACzCpD,KAAKkK,eAAiB5I,SAAS8B,cAC7B,kCAEFpD,KAAKmK,WAAa7I,SAASsC,cAAc,MACzC5D,KAAKoK,uBAAyB9I,SAAS8B,cACrC,8BAEFpD,KAAKqK,sBAAwB/I,SAASsC,cAAc,UACpD5D,KAAKsK,oBAAsBhJ,SAAS8B,cAClC,gCAEFpD,KAAKuK,YAAc,GACnBvK,KAAKwK,MAAQlJ,SAASmJ,KAAKC,WAC7B,CAAC,IAAArI,EAAA0H,EAAAxK,UA2NA,OA3NA8C,EAEDU,KAAA,WAAO,IAAAF,EAAA7C,KAEFA,KAAKiK,YACLjK,KAAKkK,gBACLlK,KAAKoK,wBACLpK,KAAKsK,sBAKRtK,KAAK2K,kBACL3K,KAAK4K,uBACL5K,KAAK6K,mBACL7K,KAAK8K,wBAEL9K,KAAK+K,aAAe/K,KAAK4C,UAAS,WAChCC,EAAK+H,uBACL/H,EAAKgI,kBACP,IAEA7K,KAAKoK,uBAAuBpH,iBAC1B,QACAhD,KAAKgL,iBAAiB/H,KAAKjD,OAE7Bc,OAAOkC,iBAAiB,SAAUhD,KAAK+K,cACvCjK,OAAOkC,iBAAiB,oBAAqBhD,KAAK8K,yBACpD,EAACzI,EAEDO,SAAA,SAASqI,EAAMC,GAAe,IACxBC,EADwBC,EAAApL,KAE5B,YAFoB,IAAPkL,IAAAA,EAAU,KAEhB,WAAa,IAAA,IAAAG,EAAAC,UAAAnL,OAAToL,EAAI,IAAA9L,MAAA4L,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAJD,EAAIC,GAAAF,UAAAE,GACbC,aAAaN,GACbA,EAAQrI,YAAW,WACjBmI,EAAKS,MAAMN,EAAMG,EACnB,GAAGL,EACL,CACF,EAEA7I,EAOAuI,qBAAA,WAOE,IALA,IACMe,EADuB7K,OAAO8K,iBAAiB5L,KAAKkK,gBACnB2B,iBAAiB,OAClDC,EAAMC,OAAOJ,EAAUK,QAAQ,KAAM,KAEvCC,EAAgB,EACXlH,EAAI,EAAGA,EAAI/E,KAAKkK,eAAegC,SAAS/L,OAAQ4E,IACvDkH,GAAiBjM,KAAKkK,eAAegC,SAASnH,GAAG2F,YAAcoB,EAC/D9L,KAAKuK,YAAYxF,GAAKkH,CAE1B,EAEA5J,EACAsI,gBAAA,WACE3K,KAAKsK,oBAAoB6B,YAAYnM,KAAKmK,YAC1CnK,KAAKmK,WAAWpG,UAAUC,IACxB,0BACA,kCAEJ,EAEA3B,EAOA+J,gBAAA,WACEpM,KAAKgK,YAAa,EAClBhK,KAAKmK,WAAWpG,UAAUC,IAAI,mCAC9BhE,KAAKiK,WAAWzB,MAAM6D,aAAe,EACrCrM,KAAKoK,uBAAuBtG,aAAa,gBAAiB,SAC1D9D,KAAKoK,uBAAuBP,QAC5B7J,KAAKqK,sBAAsBiC,oBACzB,QACAtM,KAAKoM,gBAAgBnJ,KAAKjD,OAE5BsB,SAASgL,oBAAoB,UAAWtM,KAAKuM,gBAAgBtJ,KAAKjD,MACpE,EAEAqC,EAOAkK,gBAAA,SAAgBC,GACA,WAAVA,EAAEC,KACJzM,KAAKoM,iBAET,EAEA/J,EAWAqK,eAAA,WACE1M,KAAKgK,YAAa,EAClBhK,KAAKmK,WAAWpG,UAAU+B,OAAO,mCACjC,IAAM6G,EAAa3M,KAAKmK,WAAWyC,aACnC5M,KAAKiK,WAAWzB,MAAM6D,aAAkBM,EAAU,KAClD3M,KAAKoK,uBAAuBtG,aAAa,gBAAiB,QAG1DxC,SAAS0B,iBAAiB,UAAWhD,KAAKuM,gBAAgBtJ,KAAKjD,OAG/DA,KAAKqK,sBAAsBrH,iBACzB,QACAhD,KAAKoM,gBAAgBnJ,KAAKjD,MAE9B,EAEAqC,EAKA2I,iBAAA,WACMhL,KAAKgK,WACPhK,KAAKoM,kBAELpM,KAAK0M,gBAET,EAEArK,EAcAwI,iBAAA,WACE,IAAMgC,EAAiB7M,KAAKkK,eAAeQ,YACvCoC,EAAe9M,KAAKkK,eAAegC,SAAS/L,OAEhD,GAAI0M,EAAiB7M,KAAKuK,YAAYuC,EAAe,GAAI,CAOvD,GANA9M,KAAKoK,uBAAuBrG,UAAUC,IACpC,sCAEFhE,KAAKsK,oBAAoBvG,UAAUC,IACjC,wCAEmB,IAAjB8I,EACF,OAEF,KAAOD,EAAiB7M,KAAKuK,YAAYuC,EAAe,IACtD9M,KAAKmK,WAAW4C,aACd/M,KAAKkK,eAAegC,SAASY,EAAe,GAC5C9M,KAAKmK,WAAW6C,YAElBF,GAAgB,CAEpB,MAAO,GAAID,EAAiB7M,KAAKuK,YAAYuC,GAC3C,KAAOD,EAAiB7M,KAAKuK,YAAYuC,IACvC9M,KAAKkK,eAAe6C,aAClB/M,KAAKmK,WAAW8C,YAAYjN,KAAKmK,WAAW6C,YAC5ChN,KAAKsK,qBAEPwC,GAAgB,EAIf9M,KAAKmK,WAAW+B,SAAS/L,SAC5BH,KAAKoK,uBAAuBrG,UAAU+B,OACpC,sCAEF9F,KAAKsK,oBAAoBvG,UAAU+B,OACjC,yCAIAxE,SAASmJ,KAAKC,cAAgB1K,KAAKwK,OAASxK,KAAKgK,YACnDhK,KAAKoM,iBAET,EAEA/J,EAMAyI,sBAAA,WAAwB,IAAAoC,EAAAlN,KACtB,GACO,KADCc,OAAOqM,YAEXrK,YAAW,WACToK,EAAKtC,uBACLsC,EAAKrC,kBACP,GAAG,IAKT,EAACd,CAAA,CA5OS,GCLNqD,EAAI,WACR,SAAAA,EAAYnL,EAASoL,EAAWC,EAAYC,GAC1CvN,KAAKiC,QAAUA,EACfjC,KAAKqN,UAAYA,EACjBrN,KAAKsN,WAAaA,EAClBtN,KAAKuN,eAAiBA,EACtBvN,KAAKwN,MAAQvL,EAAQoF,iBAAgB,IAAKrH,KAAKqN,UAAS,SAExDrN,KAAKyN,KAAO,CACVC,KAAM,GACNC,KAAM,GACNC,MAAO,GACPC,GAAI,IAEN7N,KAAK8N,cAAmB9N,KAAKqN,UAAS,kBAEtCrN,KAAK+N,UAAY,IAAIhN,YAAY,YACjCf,KAAKgO,UAAY,IAAIjN,YAAY,WACnC,CAAC,IAAAsB,EAAA+K,EAAA7N,UAkTA,OAlTA8C,EAEDU,KAAA,WACmC,mBAAtBjC,OAAOmN,YAA6BjO,KAAKsN,WAClDtN,KAAKkO,wBAELlO,KAAKmO,OAET,EAAC9L,EAED6L,sBAAA,WAOElO,KAAKoO,IAAMtN,OAAOmN,WAAW,sBAIzB,qBAAsBjO,KAAKoO,IAC7BpO,KAAKoO,IAAIpL,iBAAiB,SAAUhD,KAAKqO,UAAUpL,KAAKjD,OAKxDA,KAAKoO,IAAIE,YAAYtO,KAAKqO,UAAUpL,KAAKjD,OAG3CA,KAAKqO,WACP,EAAChM,EAEDgM,UAAA,WACMrO,KAAKoO,IAAI/N,QACXL,KAAKmO,QAELnO,KAAKuO,UAET,EAAClM,EAED8L,MAAA,WAAQ,IAAAtL,EAAA7C,KACEiC,EAAYjC,KAAZiC,QACAuL,EAAUxN,KAAVwN,MACFgB,EAAWvM,EAAQmB,cAAa,IAAKpD,KAAKqN,UAAS,UACnDoB,EAAgBxM,EAAQoF,iBAAgB,IACxCrH,KAAKqN,UAAS,eAGpB,GAAKG,GAAUgB,GAAaC,EAA5B,CAIAD,EAAS1K,aAAa,OAAQ,WAE9B2K,EAAcjP,SAAQ,SAACkP,GACrBA,EAAM5K,aAAa,OAAQ,eAC7B,IAEA0J,EAAMhO,SAAQ,SAACmP,GAEb9L,EAAK+L,cAAcD,GAInBA,EAAKE,cAAgBhM,EAAKiM,WAAW7L,KAAKJ,GAE1C8L,EAAKI,gBAAkBlM,EAAKmM,aAAa/L,KAAKJ,GAG9C8L,EAAK3L,iBAAiB,QAAS2L,EAAKE,eAAe,GACnDF,EAAK3L,iBAAiB,UAAW2L,EAAKI,iBAAiB,GAGvDlM,EAAKoM,QAAQN,EACf,IAGA,IAAMO,EAAalP,KAAKmP,OAAOrO,OAAOsO,SAAStG,OAAS9I,KAAKwN,MAAM,GACnExN,KAAKqP,QAAQH,GAGTlP,KAAKuN,iBACPtL,EAAQqN,kBAAoBtP,KAAKuP,aAAatM,KAAKjD,MACnDc,OAAOkC,iBAAiB,aAAcf,EAAQqN,mBAAmB,GAjCnE,CAmCF,EAACjN,EAEDkM,SAAA,WAAW,IAAAnD,EAAApL,KACDiC,EAAYjC,KAAZiC,QACAuL,EAAUxN,KAAVwN,MACFgB,EAAWvM,EAAQmB,cAAa,IAAKpD,KAAKqN,UAAS,UACnDoB,EAAgBxM,EAAQoF,iBAAgB,IACxCrH,KAAKqN,UAAS,eAGfG,GAAUgB,GAAaC,IAI5BD,EAAS/J,gBAAgB,QAEzBgK,EAAcjP,SAAQ,SAACkP,GACrBA,EAAMjK,gBAAgB,OAAQ,eAChC,IAEA+I,EAAMhO,SAAQ,SAACmP,GAEbA,EAAKrC,oBAAoB,QAASqC,EAAKE,eAAe,GACtDF,EAAKrC,oBAAoB,UAAWqC,EAAKI,iBAAiB,GAG1D3D,EAAKoE,gBAAgBb,EACvB,IAEI3O,KAAKuN,gBAEPzM,OAAOwL,oBAAoB,aAAcrK,EAAQqN,mBAAmB,GAExE,EAACjN,EAEDkN,aAAA,WACE,IAAQzG,EAAShI,OAAOsO,SAAhBtG,KACF2G,EAAezP,KAAKmP,OAAOrG,GACjC,GAAK2G,EAKL,GAAIzP,KAAK0P,aACP1P,KAAK0P,cAAe,MADtB,CAMA,IAAMC,EAAe3P,KAAK4P,gBAE1B5P,KAAKiP,QAAQU,GACb3P,KAAKqP,QAAQI,GACbA,EAAa5F,OAPb,CAQF,EAACxH,EAED4M,QAAA,SAAQN,GACN3O,KAAK6P,eAAelB,GACpB3O,KAAK8P,UAAUnB,EACjB,EAACtM,EAEDgN,QAAA,SAAQV,GACN3O,KAAK+P,aAAapB,GAClB3O,KAAKgQ,UAAUrB,EACjB,EAACtM,EAED8M,OAAA,SAAOrG,GACL,OAAO9I,KAAKiC,QAAQmB,cAAa,IAAKpD,KAAKqN,UAAS,eAAevE,EAAI,KACzE,EAACzG,EAEDuM,cAAA,SAAcD,GAEZ,IAAMsB,EAAU7C,EAAK8C,QAAQvB,GAAMwB,MAAM,GACzCxB,EAAK7K,aAAa,KAAI,OAASmM,GAC/BtB,EAAK7K,aAAa,OAAQ,OAC1B6K,EAAK7K,aAAa,gBAAiBmM,GACnCtB,EAAK7K,aAAa,gBAAiB,SACnC6K,EAAK7K,aAAa,WAAY,MAG9B,IAAMsM,EAASpQ,KAAKqQ,SAAS1B,GAC7ByB,EAAOtM,aAAa,OAAQ,YAC5BsM,EAAOtM,aAAa,kBAAmB6K,EAAKjL,IAC5C0M,EAAOrM,UAAUC,IAAIhE,KAAK8N,cAC5B,EAACzL,EAEDmN,gBAAA,SAAgBb,GAEdA,EAAKlK,gBAAgB,MACrBkK,EAAKlK,gBAAgB,QACrBkK,EAAKlK,gBAAgB,iBACrBkK,EAAKlK,gBAAgB,iBACrBkK,EAAKlK,gBAAgB,YAGrB,IAAM2L,EAASpQ,KAAKqQ,SAAS1B,GAC7ByB,EAAO3L,gBAAgB,QACvB2L,EAAO3L,gBAAgB,mBACvB2L,EAAO3L,gBAAgB,YACvB2L,EAAOrM,UAAU+B,OAAO9F,KAAK8N,cAC/B,EAACzL,EAEDyM,WAAA,SAAWtC,GACJA,EAAEjK,OAAOwB,UAAUuM,SAAYtQ,KAAKqN,UAAS,WAChDb,EAAE+D,kBACF/D,EAAE9J,kBAEJ8J,EAAE9J,iBACF,IAAM8N,EAAUhE,EAAEjK,OACZkO,EAAczQ,KAAK4P,gBACzB5P,KAAKiP,QAAQwB,GACbzQ,KAAKqP,QAAQmB,GACbxQ,KAAK0Q,mBAAmBF,EAC1B,EAACnO,EAEDqO,mBAAA,SAAmB/B,GACjB,GAAI3O,KAAKuN,eAAgB,CACvB,IAAM6C,EAASpQ,KAAKqQ,SAAS1B,GAIrBjL,EAAO0M,EAAP1M,GACR0M,EAAO1M,GAAK,GACZ1D,KAAK0P,cAAe,EACpB5O,OAAOsO,SAAStG,KAAOsE,EAAK8C,QAAQvB,GAAMwB,MAAM,GAChDC,EAAO1M,GAAKA,CACd,CACF,EAACrB,EAED2M,aAAA,SAAaxC,GACX,OAAQA,EAAE/J,SACR,KAAKzC,KAAKyN,KAAKE,KACf,KAAK3N,KAAKyN,KAAKI,GACb7N,KAAK2Q,sBACLnE,EAAE9J,iBACF,MACF,KAAK1C,KAAKyN,KAAKG,MACf,KAAK5N,KAAKyN,KAAKC,KACb1N,KAAK4Q,kBACLpE,EAAE9J,iBAKR,EAACL,EAEDuO,gBAAA,WACE,IAEIC,EAFEC,EAAa9Q,KAAK4P,gBAClBmB,EAAkBD,EAAWlQ,WAAWoQ,mBAG1CD,IACFF,EAAUE,EAAgB3N,cAAa,IAAKpD,KAAKqN,UAAS,UAExDwD,IACF7Q,KAAKiP,QAAQ6B,GACb9Q,KAAKqP,QAAQwB,GACbA,EAAQhH,QACR7J,KAAK0Q,mBAAmBG,GAE5B,EAACxO,EAEDsO,oBAAA,WACE,IAEIM,EAFEH,EAAa9Q,KAAK4P,gBAClBsB,EAAsBJ,EAAWlQ,WAAWuQ,uBAG9CD,IACFD,EAAcC,EAAoB9N,cAAa,IAAKpD,KAAKqN,UAAS,UAEhE4D,IACFjR,KAAKiP,QAAQ6B,GACb9Q,KAAKqP,QAAQ4B,GACbA,EAAYpH,QACZ7J,KAAK0Q,mBAAmBO,GAE5B,EAAC5O,EAEDgO,SAAA,SAAS1B,GAEP,OADe3O,KAAKiC,QAAQmB,cAAcgK,EAAK8C,QAAQvB,GAEzD,EAACtM,EAED2N,UAAA,SAAUrB,GACR,IAAMyB,EAASpQ,KAAKqQ,SAAS1B,GAC7ByB,EAAOrM,UAAU+B,OAAO9F,KAAK8N,eAC7BsC,EAAOgB,cAAcpR,KAAK+N,UAC5B,EAAC1L,EAEDyN,UAAA,SAAUuB,GACR,IAAMjB,EAASpQ,KAAKqQ,SAASgB,GAC7BjB,EAAOrM,UAAUC,IAAIhE,KAAK8N,eAC1BsC,EAAOgB,cAAcpR,KAAKgO,UAC5B,EAAC3L,EAEDwN,eAAA,SAAelB,GACbA,EAAK7K,aAAa,gBAAiB,SACnC6K,EAAK/N,WAAWmD,UAAU+B,OAAU9F,KAAKqN,UAAS,yBAClDsB,EAAK7K,aAAa,WAAY,KAChC,EAACzB,EAED0N,aAAA,SAAapB,GACXA,EAAK7K,aAAa,gBAAiB,QACnC6K,EAAK/N,WAAWmD,UAAUC,IAAOhE,KAAKqN,UAAS,yBAC/CsB,EAAK7K,aAAa,WAAY,IAChC,EAACzB,EAEDuN,cAAA,WACE,OAAO5P,KAAKiC,QAAQmB,cAAa,IAC3BpD,KAAKqN,UAAS,0BAA0BrN,KAAKqN,UAAS,QAE9D,EAIAD,EACO8C,QAAP,SAAevB,GACb,IAAM9F,EAAO8F,EAAKnM,aAAa,QAE/B,OADaqG,EAAKsH,MAAMtH,EAAKyI,QAAQ,KAAMzI,EAAK1I,OAElD,EAACiN,CAAA,CApUO,GV25CM1L,EAAoB,KWp4C7B,SAAS6P,EAAQ7J,GR2CxB,IAAeF,EAA0BC,QAAlB,KAAkBA,QAAK,KAA/BD,EQ1CF,CAAEE,MAAAA,IR0CwB,CAAC,EAACF,GAAvBE,OAAQpG,SAAQmG,GACVJ,iBAAiB,gCAC/B7H,SAAQ,SAACU,GACf,IAAI8B,EAAO9B,GAAI6C,MACjB,ICuMF,SAAeyE,GAA+B,IAALC,QAAK,IAAAD,EAAP,CAAC,EAACA,GAAvBE,YAAK,IAAAD,EAAGnG,SAAQmG,GACFJ,iBAC5B,yCAEc7H,SAAQ,SAACU,GACvB,IAAIgD,EAAehD,GAAI6C,MACzB,GACD,CO3PCyO,CAAmB,CAAE9J,MAAAA,IACrB+J,EAAe,CAAE/J,MAAAA,IACjBgB,EAAY,CAAEhB,MAAAA,IH+EhB,SAAeF,GAAuD,IAAAkK,OAAA,IAAAlK,EAAP,CAAC,EAACA,EAAAmK,EAAAD,EAA/CE,gBAAAA,OAAe,IAAAD,GAAOA,EAAAlK,EAAAiK,EAAEhK,MAElCmK,QAFuC,IAAApK,EAAGnG,SAAQmG,GAE7BrE,cAAc,wBAErCyO,IAGED,GACFC,EAAahI,QAEfgI,EAAa7O,iBAAiB,QAAS4E,GAE1C,CG1FCkK,CAAiB,CAAEpK,MAAAA,ICrBrB,SAAeF,GAA+B,IAALC,QAAK,IAAAD,EAAP,CAAC,EAACA,GAAvBE,MAEVqK,QAFe,IAAAtK,EAAGnG,SAAQmG,GAENJ,iBACxB,mDAMIF,EAA4B,WAChC4K,EAAYvS,SAAQ,SAACuH,GAAK,OACxBD,EAAuBC,EAAO,oCAAoC,GAEtE,EAMI,eAAgBjG,OAClBA,OAAOkC,iBAAiB,WAAYmE,GAEpCrG,OAAOkC,iBAAiB,mBAAoBmE,GAM9CA,IAGA4K,EAAYvS,SAAQ,SAACwS,GACnBA,EAAYhP,iBAAiB,SAAUmE,EACzC,GACD,CDZC8K,CAAW,CAAEvK,MAAAA,IDiTf,SAAeF,GAKJ,IAAAkK,OAAA,IAAAlK,EAAP,CAAC,EAACA,EAAA0K,EAAAR,EAJJrE,UAAAA,OAAS,IAAA6E,EAAG,aAAYA,EAAAC,EAAAT,EACxBpE,WAAAA,OAAU,IAAA6E,GAAOA,EAAAC,EAAAV,EACjBnE,eAAAA,OAAc,IAAA6E,GAAOA,EAAA3K,EAAAiK,EACrBhK,YAAK,IAAAD,EAAGnG,SAAQmG,GAEGJ,iBAAgB,iBAAkBgG,EAAS,MACzD7N,SAAQ,SAACU,GACZ,IAAIkN,EAAKlN,EAAImN,EAAWC,EAAYC,GAAgBxK,MACtD,GACD,CC1TCsP,CAAS,CAAE3K,MAAAA,GACb,CAGApG,SAAS0B,iBAAiB,oBAAoB,YFmN5C,IAAI+G,GAAShH,OI5Of,WACE,IAAMuP,EAAYhR,SAAS8B,cAAc,oBAGzC,GAAKkP,GAAeA,aAAqBC,kBAAzC,CAIA,IAAMC,EAAkBF,EAAUxJ,KAAK2J,MAAM,KAAKC,MAC5CC,EAAiBH,EACnBlR,SAASmC,eAAe+O,GACxB,KAGCG,GAULL,EAAUtP,iBAAiB,SAAS,WAAA,ORoB/B,SAAkB4P,EAAU3O,QAAO,IAAPA,IAAAA,EAAU,CAAC,GAC5C,IAAM4O,EAAcD,EAASpQ,aAAa,YAiB1C,SAASsQ,IACPF,EAAStG,oBAAoB,OAAQwG,GAEjC7O,EAAQ6O,QACV7O,EAAQ6O,OAAOpS,KAAKkS,GAGjBC,GACHD,EAASnO,gBAAgB,WAE7B,CAzBKoO,GACHD,EAAS9O,aAAa,WAAY,MA2BpC8O,EAAS5P,iBAAiB,SArB1B,SAAS+P,IACPH,EAAStG,oBAAoB,QAASyG,GACtCH,EAAS5P,iBAAiB,OAAQ8P,EACpC,IAqBI7O,EAAQ+O,eACV/O,EAAQ+O,cAActS,KAAKkS,GAG7BA,EAAS/I,OACX,CQ1DIoJ,CAASN,EAAgB,CACvBK,cAAa,WACXL,EAAe5O,UAAUC,IAAI,kCAC/B,EACA8O,OAAM,WACJH,EAAe5O,UAAU+B,OAAO,kCAClC,GACA,GA1BJ,CA4BD,CFPCoN,GAEA3B,EAAQjQ,SACV,GX06CA,CAt3CC,EAu3CS,CAl9CD","file":"nhsuk-9.3.0.min.js","sourcesContent":["/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 621:\n/***/ (function() {\n\n/**\n * IE polyfill for NodeList.forEach()\n */\nif (!NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach;\n}\n\n/**\n * IE polyfill for Array.includes()\n */\nif (!Array.prototype.includes) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Array.prototype, 'includes', {\n    enumerable: false,\n    value: function value(obj) {\n      return this.filter(function (el) {\n        return el === obj;\n      }).length > 0;\n    }\n  });\n}\n\n/**\n * IE polyfill for Element.closest()\n */\nif (!Element.prototype.matches) {\n  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n}\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this;\n    do {\n      if (Element.prototype.matches.call(el, s)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n    return null;\n  };\n}\n\n/**\n * IE polyfill for CustomEvent\n */\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function (event, params) {\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: null\n    };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  };\n}\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n!function() {\n\"use strict\";\n\n// UNUSED EXPORTS: initAll\n\n;// CONCATENATED MODULE: ./packages/components/button/button.js\nvar Button = /*#__PURE__*/function () {\n  function Button($module) {\n    this.KEY_SPACE = 32;\n    this.DEBOUNCE_TIMEOUT_IN_SECONDS = 1;\n    this.$module = $module;\n    this.debounceFormSubmitTimer = null;\n  }\n\n  /**\n   * JavaScript 'shim' to trigger the click event of element(s) when the space key is pressed.\n   *\n   * Created since some Assistive Technologies (for example some Screenreaders)\n   * will tell a user to press space on a 'button', so this functionality needs to be shimmed\n   * See https://github.com/alphagov/govuk_elements/pull/272#issuecomment-233028270\n   *\n   * @param {object} event event\n   */\n  var _proto = Button.prototype;\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // get the target element\n\n    var target = event.target;\n    // if the element has a role='button' and the pressed key is a space, we'll simulate a click\n    if (target.getAttribute('role') === 'button' && event.keyCode === this.KEY_SPACE) {\n      event.preventDefault();\n      // trigger the target's click event\n      target.click();\n    }\n  }\n\n  /**\n   * If the click quickly succeeds a previous click then nothing will happen.\n   * This stops people accidentally causing multiple form submissions by\n   * double clicking buttons.\n   */;\n  _proto.debounce = function debounce(event) {\n    var _this = this;\n    var target = event.target;\n    // Check the button that is clicked on has the preventDoubleClick feature enabled\n    if (target.getAttribute('data-prevent-double-click') !== 'true') {\n      return;\n    }\n\n    // If the timer is still running then we want to prevent the click from submitting the form\n    if (this.debounceFormSubmitTimer) {\n      event.preventDefault();\n      return false; // eslint-disable-line consistent-return\n    }\n    this.debounceFormSubmitTimer = setTimeout(function () {\n      _this.debounceFormSubmitTimer = null;\n    }, this.DEBOUNCE_TIMEOUT_IN_SECONDS * 1000);\n  }\n\n  /**\n   * Initialise an event listener for keydown at document level\n   * this will help listening for later inserted elements with a role=\"button\"\n   */;\n  _proto.init = function init() {\n    this.$module.addEventListener('keydown', this.handleKeyDown.bind(this));\n    this.$module.addEventListener('click', this.debounce.bind(this));\n  };\n  return Button;\n}();\n/* harmony default export */ var button_button = (function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  var buttons = scope.querySelectorAll('[data-module=\"nhsuk-button\"]');\n  buttons.forEach(function (el) {\n    new Button(el).init();\n  });\n});\n;// CONCATENATED MODULE: ./packages/components/character-count/character-count.js\nvar CharacterCount = /*#__PURE__*/function () {\n  function CharacterCount($module) {\n    this.$module = $module;\n    this.$textarea = $module.querySelector('.nhsuk-js-character-count');\n    this.$visibleCountMessage = null;\n    this.$screenReaderCountMessage = null;\n    this.lastInputTimestamp = null;\n  }\n\n  // Initialize component\n  var _proto = CharacterCount.prototype;\n  _proto.init = function init() {\n    // Check that required elements are present\n    if (!this.$textarea) {\n      return;\n    }\n\n    // Check for module\n    var $module = this.$module;\n    var $textarea = this.$textarea;\n    var $fallbackLimitMessage = document.getElementById($textarea.id + \"-info\");\n\n    // Move the fallback count message to be immediately after the textarea\n    // Kept for backwards compatibility\n    $textarea.insertAdjacentElement('afterend', $fallbackLimitMessage);\n\n    // Create the *screen reader* specific live-updating counter\n    // This doesn't need any styling classes, as it is never visible\n    var $screenReaderCountMessage = document.createElement('div');\n    $screenReaderCountMessage.className = 'nhsuk-character-count__sr-status nhsuk-u-visually-hidden';\n    $screenReaderCountMessage.setAttribute('aria-live', 'polite');\n    this.$screenReaderCountMessage = $screenReaderCountMessage;\n    $fallbackLimitMessage.insertAdjacentElement('afterend', $screenReaderCountMessage);\n\n    // Create our live-updating counter element, copying the classes from the\n    // fallback element for backwards compatibility as these may have been configured\n    var $visibleCountMessage = document.createElement('div');\n    $visibleCountMessage.className = $fallbackLimitMessage.className;\n    $visibleCountMessage.classList.add('nhsuk-character-count__status');\n    $visibleCountMessage.setAttribute('aria-hidden', 'true');\n    this.$visibleCountMessage = $visibleCountMessage;\n    $fallbackLimitMessage.insertAdjacentElement('afterend', $visibleCountMessage);\n\n    // Hide the fallback limit message\n    $fallbackLimitMessage.classList.add('nhsuk-u-visually-hidden');\n\n    // Read options set using dataset ('data-' values)\n    this.options = CharacterCount.getDataset($module);\n\n    // Determine the limit attribute (characters or words)\n    var countAttribute = this.defaults.characterCountAttribute;\n    if (this.options.maxwords) {\n      countAttribute = this.defaults.wordCountAttribute;\n    }\n\n    // Save the element limit\n    this.maxLength = $module.getAttribute(countAttribute);\n\n    // Check for limit\n    if (!this.maxLength) {\n      return;\n    }\n\n    // Remove hard limit if set\n    $textarea.removeAttribute('maxlength');\n    this.bindChangeEvents();\n\n    // When the page is restored after navigating 'back' in some browsers the\n    // state of the character count is not restored until *after* the DOMContentLoaded\n    // event is fired, so we need to manually update it after the pageshow event\n    // in browsers that support it.\n    if ('onpageshow' in window) {\n      window.addEventListener('pageshow', this.updateCountMessage.bind(this));\n    } else {\n      window.addEventListener('DOMContentLoaded', this.updateCountMessage.bind(this));\n    }\n    this.updateCountMessage();\n  }\n\n  // Read data attributes\n  ;\n  CharacterCount.getDataset = function getDataset(element) {\n    var dataset = {};\n    var attributes = element.attributes;\n    if (attributes) {\n      for (var i = 0; i < attributes.length; i++) {\n        var attribute = attributes[i];\n        var match = attribute.name.match(/^data-(.+)/);\n        if (match) {\n          dataset[match[1]] = attribute.value;\n        }\n      }\n    }\n    return dataset;\n  }\n\n  // Counts characters or words in text\n  ;\n  _proto.count = function count(text) {\n    var length;\n    if (this.options.maxwords) {\n      var tokens = text.match(/\\S+/g) || []; // Matches consecutive non-whitespace chars\n      length = tokens.length; // eslint-disable-line prefer-destructuring\n    } else {\n      length = text.length; // eslint-disable-line prefer-destructuring\n    }\n    return length;\n  }\n\n  // Bind input propertychange to the elements and update based on the change\n  ;\n  _proto.bindChangeEvents = function bindChangeEvents() {\n    var $textarea = this.$textarea;\n    $textarea.addEventListener('keyup', this.handleKeyUp.bind(this));\n\n    // Bind focus/blur events to start/stop polling\n    $textarea.addEventListener('focus', this.handleFocus.bind(this));\n    $textarea.addEventListener('blur', this.handleBlur.bind(this));\n  }\n\n  // Speech recognition software such as Dragon NaturallySpeaking will modify the\n  // fields by directly changing its `value`. These changes don't trigger events\n  // in JavaScript, so we need to poll to handle when and if they occur.\n  ;\n  _proto.checkIfValueChanged = function checkIfValueChanged() {\n    if (!this.$textarea.oldValue) {\n      this.$textarea.oldValue = '';\n    }\n    if (this.$textarea.value !== this.$textarea.oldValue) {\n      this.$textarea.oldValue = this.$textarea.value;\n      this.updateCountMessage();\n    }\n  }\n\n  // Helper function to update both the visible and screen reader-specific\n  // counters simultaneously (e.g. on init)\n  ;\n  _proto.updateCountMessage = function updateCountMessage() {\n    this.updateVisibleCountMessage();\n    this.updateScreenReaderCountMessage();\n  }\n\n  // Update visible counter\n  ;\n  _proto.updateVisibleCountMessage = function updateVisibleCountMessage() {\n    var $textarea = this.$textarea;\n    var $visibleCountMessage = this.$visibleCountMessage;\n    var remainingNumber = this.maxLength - this.count($textarea.value);\n\n    // If input is over the threshold, remove the disabled class which renders the\n    // counter invisible.\n    if (this.isOverThreshold()) {\n      $visibleCountMessage.classList.remove('nhsuk-character-count__message--disabled');\n    } else {\n      $visibleCountMessage.classList.add('nhsuk-character-count__message--disabled');\n    }\n\n    // Update styles\n    if (remainingNumber < 0) {\n      $textarea.classList.add('nhsuk-textarea--error');\n      $visibleCountMessage.classList.remove('nhsuk-hint');\n      $visibleCountMessage.classList.add('nhsuk-error-message');\n    } else {\n      $textarea.classList.remove('nhsuk-textarea--error');\n      $visibleCountMessage.classList.remove('nhsuk-error-message');\n      $visibleCountMessage.classList.add('nhsuk-hint');\n    }\n\n    // Update message\n    $visibleCountMessage.innerHTML = this.formattedUpdateMessage();\n  }\n\n  // Update screen reader-specific counter\n  ;\n  _proto.updateScreenReaderCountMessage = function updateScreenReaderCountMessage() {\n    var $screenReaderCountMessage = this.$screenReaderCountMessage;\n\n    // If over the threshold, remove the aria-hidden attribute, allowing screen\n    // readers to announce the content of the element.\n    if (this.isOverThreshold()) {\n      $screenReaderCountMessage.removeAttribute('aria-hidden');\n    } else {\n      $screenReaderCountMessage.setAttribute('aria-hidden', true);\n    }\n\n    // Update message\n    $screenReaderCountMessage.innerHTML = this.formattedUpdateMessage();\n  }\n\n  // Format update message\n  ;\n  _proto.formattedUpdateMessage = function formattedUpdateMessage() {\n    var $textarea = this.$textarea;\n    var options = this.options;\n    var remainingNumber = this.maxLength - this.count($textarea.value);\n    var charVerb = 'remaining';\n    var charNoun = 'character';\n    var displayNumber = remainingNumber;\n    if (options.maxwords) {\n      charNoun = 'word';\n    }\n    charNoun += remainingNumber === -1 || remainingNumber === 1 ? '' : 's';\n    charVerb = remainingNumber < 0 ? 'too many' : 'remaining';\n    displayNumber = Math.abs(remainingNumber);\n    return \"You have \" + displayNumber + \" \" + charNoun + \" \" + charVerb;\n  }\n\n  // Checks whether the value is over the configured threshold for the input.\n  // If there is no configured threshold, it is set to 0 and this function will\n  // always return true.\n  ;\n  _proto.isOverThreshold = function isOverThreshold() {\n    var $textarea = this.$textarea;\n    var options = this.options;\n\n    // Determine the remaining number of characters/words\n    var currentLength = this.count($textarea.value);\n    var maxLength = this.maxLength;\n\n    // Set threshold if presented in options\n    var thresholdPercent = options.threshold ? options.threshold : 0;\n    var thresholdValue = maxLength * thresholdPercent / 100;\n    return thresholdValue <= currentLength;\n  }\n\n  // Update the visible character counter and keep track of when the last update\n  // happened for each keypress\n  ;\n  _proto.handleKeyUp = function handleKeyUp() {\n    this.updateVisibleCountMessage();\n    this.lastInputTimestamp = Date.now();\n  };\n  _proto.handleFocus = function handleFocus() {\n    var _this = this;\n    // If the field is focused, and a keyup event hasn't been detected for at\n    // least 1000 ms (1 second), then run the manual change check.\n    // This is so that the update triggered by the manual comparison doesn't\n    // conflict with debounced KeyboardEvent updates.\n    this.valueChecker = setInterval(function () {\n      if (!_this.lastInputTimestamp || Date.now() - 500 >= _this.lastInputTimestamp) {\n        _this.checkIfValueChanged();\n      }\n    }, 1000);\n  };\n  _proto.handleBlur = function handleBlur() {\n    // Cancel value checking on blur\n    clearInterval(this.valueChecker);\n  };\n  return CharacterCount;\n}();\nCharacterCount.prototype.defaults = {\n  characterCountAttribute: 'data-maxlength',\n  wordCountAttribute: 'data-maxwords'\n};\n/* harmony default export */ var character_count = (function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  var characterCounts = scope.querySelectorAll('[data-module=\"nhsuk-character-count\"]');\n  characterCounts.forEach(function (el) {\n    new CharacterCount(el).init();\n  });\n});\n;// CONCATENATED MODULE: ./packages/common.js\n/**\n * Toggle a boolean attribute on a HTML element\n * @param {HTMLElement} element\n * @param {string} attr\n */\nvar toggleAttribute = function toggleAttribute(element, attr) {\n  // Return without error if element or attr are missing\n  if (!element || !attr) return;\n  // Toggle attribute value. Treat no existing attr same as when set to false\n  var value = element.getAttribute(attr) === 'true' ? 'false' : 'true';\n  element.setAttribute(attr, value);\n};\n\n/**\n * Toggle a toggle a class on conditional content for an input based on checked state\n * @param {HTMLElement} input input element\n * @param {string} className class to toggle\n */\nvar toggleConditionalInput = function toggleConditionalInput(input, className) {\n  // Return without error if input or class are missing\n  if (!input || !className) return;\n  // If the input has conditional content it had a data-aria-controls attribute\n  var conditionalId = input.getAttribute('aria-controls');\n  if (conditionalId) {\n    // Get the conditional element from the input data-aria-controls attribute\n    var conditionalElement = document.getElementById(conditionalId);\n    if (conditionalElement) {\n      if (input.checked) {\n        conditionalElement.classList.remove(className);\n        input.setAttribute('aria-expanded', true);\n      } else {\n        conditionalElement.classList.add(className);\n        input.setAttribute('aria-expanded', false);\n      }\n    }\n  }\n};\n\n/**\n * Move focus to element\n *\n * Sets tabindex to -1 to make the element programmatically focusable,\n * but removes it on blur as the element doesn't need to be focused again.\n *\n * Original code taken from GDS (Government Digital Service)\n * {@link https://github.com/alphagov/govuk-frontend}\n *\n * @template {HTMLElement} FocusElement\n * @param {FocusElement} $element - HTML element\n * @param {object} [options] - Handler options\n * @param {function(this: FocusElement): void} [options.onBeforeFocus] - Callback before focus\n * @param {function(this: FocusElement): void} [options.onBlur] - Callback on blur\n */\nfunction setFocus($element, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var isFocusable = $element.getAttribute('tabindex');\n  if (!isFocusable) {\n    $element.setAttribute('tabindex', '-1');\n  }\n\n  /**\n   * Handle element focus\n   */\n  function onFocus() {\n    $element.removeEventListener('focus', onFocus);\n    $element.addEventListener('blur', onBlur);\n  }\n\n  /**\n   * Handle element blur\n   */\n  function onBlur() {\n    $element.removeEventListener('blur', onBlur);\n    if (options.onBlur) {\n      options.onBlur.call($element);\n    }\n    if (!isFocusable) {\n      $element.removeAttribute('tabindex');\n    }\n  }\n\n  // Add listener to reset element on blur, after focus\n  $element.addEventListener('focus', onFocus);\n\n  // Focus element\n  if (options.onBeforeFocus) {\n    options.onBeforeFocus.call($element);\n  }\n  $element.focus();\n}\n;// CONCATENATED MODULE: ./packages/components/checkboxes/checkboxes.js\n\n\n/**\n * Conditionally show content when a checkbox button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/checkboxes/conditional.html\n */\nvar syncAllConditionalReveals = function syncAllConditionalReveals(input) {\n  var allInputsInForm = input.form.querySelectorAll('input[type=\"checkbox\"]');\n  allInputsInForm.forEach(function (item) {\n    return toggleConditionalInput(item, 'nhsuk-checkboxes__conditional--hidden');\n  });\n};\n\n/**\n * Uncheck other checkboxes\n *\n * Find any other checkbox inputs with the checkbox group value, and uncheck them.\n * This is useful for when a â€œNone of these\" checkbox is checked.\n */\nvar unCheckAllInputsExcept = function unCheckAllInputsExcept(input) {\n  var allInputsInSameExclusiveGroup = input.form.querySelectorAll(\"input[type=\\\"checkbox\\\"][data-checkbox-exclusive-group=\\\"\" + input.getAttribute('data-checkbox-exclusive-group') + \"\\\"]\");\n  allInputsInSameExclusiveGroup.forEach(function (inputWithSameName) {\n    var hasSameFormOwner = input.form === inputWithSameName.form;\n    if (hasSameFormOwner && inputWithSameName !== input) {\n      inputWithSameName.checked = false; // eslint-disable-line no-param-reassign\n    }\n  });\n  syncAllConditionalReveals(input);\n};\n\n/**\n * Uncheck exclusive inputs\n *\n * Find any checkbox inputs with the same checkbox group value and the 'exclusive' behaviour,\n * and uncheck them. This helps prevent someone checking both a regular checkbox and a\n * \"None of these\" checkbox in the same fieldset.\n */\nvar unCheckExclusiveInputs = function unCheckExclusiveInputs(input) {\n  var allExclusiveInputsInSameExclusiveGroup = input.form.querySelectorAll(\"input[type=\\\"checkbox\\\"][data-checkbox-exclusive][data-checkbox-exclusive-group=\\\"\" + input.getAttribute('data-checkbox-exclusive-group') + \"\\\"]\");\n  allExclusiveInputsInSameExclusiveGroup.forEach(function (exclusiveInput) {\n    var hasSameFormOwner = input.form === exclusiveInput.form;\n    if (hasSameFormOwner) {\n      exclusiveInput.checked = false; // eslint-disable-line no-param-reassign\n    }\n  });\n  syncAllConditionalReveals(input);\n};\n/* harmony default export */ var checkboxes = (function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Checkbox input DOMElements inside a conditional form group\n  var checkboxInputs = scope.querySelectorAll('.nhsuk-checkboxes .nhsuk-checkboxes__input');\n\n  /**\n   * Toggle classes and attributes\n   * @param {Object} event click event object\n   */\n  var handleClick = function handleClick(event) {\n    // Toggle conditional content based on checked state\n    toggleConditionalInput(event.target, 'nhsuk-checkboxes__conditional--hidden');\n    if (!event.target.checked) {\n      return;\n    }\n\n    // Handle 'exclusive' checkbox behaviour (ie \"None of these\")\n    if (event.target.hasAttribute('data-checkbox-exclusive')) {\n      unCheckAllInputsExcept(event.target);\n    } else {\n      unCheckExclusiveInputs(event.target);\n    }\n  };\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', function () {\n      return checkboxInputs.forEach(function (input) {\n        return syncAllConditionalReveals(input);\n      });\n    });\n  } else {\n    window.addEventListener('DOMContentLoaded', function () {\n      return checkboxInputs.forEach(function (input) {\n        return syncAllConditionalReveals(input);\n      });\n    });\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  checkboxInputs.forEach(function (input) {\n    return syncAllConditionalReveals(input);\n  });\n\n  // Attach handleClick as click to checkboxInputs\n  checkboxInputs.forEach(function (checkboxButton) {\n    checkboxButton.addEventListener('change', handleClick);\n  });\n});\n;// CONCATENATED MODULE: ./packages/components/details/details.js\n\n\n/**\n * Ensure details component is cross browser and accessible\n * Test at http://localhost:3000/nhsuk-frontend/components/details/index.html\n */\n\n/* harmony default export */ var details = (function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Does the browser support details component\n  var nativeSupport = typeof document.createElement('details').open === 'boolean';\n  if (nativeSupport) {\n    return;\n  }\n\n  // Nodelist of all details elements\n  var allDetails = scope.querySelectorAll('details');\n\n  /**\n   * Adds all necessary functionality to a details element\n   * @param {HTMLElement} element details element to initialise\n   * @param {number} index number to be appended to dynamic IDs\n   */\n  var initDetails = function initDetails(element, index) {\n    // Set details element as polyfilled to prevent duplicate events being added\n    element.setAttribute('nhsuk-polyfilled', 'true');\n\n    // Give details element an ID if it doesn't already have one\n    if (!element.id) element.setAttribute('id', \"nhsuk-details\" + index);\n\n    // Set content element and give it an ID if it doesn't already have one\n    var content = scope.querySelector(\"#\" + element.id + \" .nhsuk-details__text\");\n    if (!content.id) content.setAttribute('id', \"nhsuk-details__text\" + index);\n\n    // Set summary element\n    var summary = scope.querySelector(\"#\" + element.id + \" .nhsuk-details__summary\");\n\n    // Set initial summary aria attributes\n    summary.setAttribute('role', 'button');\n    summary.setAttribute('aria-controls', content.id);\n    summary.setAttribute('tabIndex', '0');\n    var openAttr = element.getAttribute('open') !== null;\n    if (openAttr === true) {\n      summary.setAttribute('aria-expanded', 'true');\n      content.setAttribute('aria-hidden', 'false');\n    } else {\n      summary.setAttribute('aria-expanded', 'false');\n      content.setAttribute('aria-hidden', 'true');\n      content.style.display = 'none';\n    }\n    var toggleDetails = function toggleDetails() {\n      toggleAttribute(summary, 'aria-expanded');\n      toggleAttribute(content, 'aria-hidden');\n      content.style.display = content.getAttribute('aria-hidden') === 'true' ? 'none' : '';\n      if (element.hasAttribute('open')) {\n        element.removeAttribute('open');\n      } else {\n        element.setAttribute('open', 'open');\n      }\n    };\n\n    // Toggle details onclick\n    summary.addEventListener('click', toggleDetails);\n\n    // Call toggle details on enter and space key events\n    summary.addEventListener('keydown', function (event) {\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        summary.click();\n      }\n    });\n  };\n\n  // Initialise details for any new details element\n  if (allDetails.length) {\n    allDetails.forEach(function (element, index) {\n      if (!element.hasAttribute('nhsuk-polyfilled')) initDetails(element, index);\n    });\n  }\n});\n;// CONCATENATED MODULE: ./packages/components/error-summary/error-summary.js\n/**\n * Adapted from https://github.com/alphagov/govuk-frontend/blob/master/src/govuk/components/error-summary/error-summary.js\n */\n\n/**\n * Get associated legend or label\n *\n * Returns the first element that exists from this list:\n *\n * - The `<legend>` associated with the closest `<fieldset>` ancestor, as long\n *   as the top of it is no more than half a viewport height away from the\n *   bottom of the input\n * - The first `<label>` that is associated with the input using for='inputId'\n * - The closest parent `<label>`\n */\nfunction getAssociatedLegendOrLabel(input) {\n  var fieldset = input.closest('fieldset');\n  if (fieldset) {\n    var legends = fieldset.getElementsByTagName('legend');\n    if (legends.length) {\n      var candidateLegend = legends[0]; // eslint-disable-line prefer-destructuring\n\n      // If the input type is radio or checkbox, always use the legend if there\n      // is one.\n      if (input.type === 'checkbox' || input.type === 'radio') {\n        return candidateLegend;\n      }\n\n      // For other input types, only scroll to the fieldsetâ€™s legend (instead of\n      // the label associated with the input) if the input would end up in the\n      // top half of the screen.\n      //\n      // This should avoid situations where the input either ends up off the\n      // screen, or obscured by a software keyboard.\n      var legendTop = candidateLegend.getBoundingClientRect().top;\n      var inputRect = input.getBoundingClientRect();\n\n      // If the browser doesn't support Element.getBoundingClientRect().height\n      // or window.innerHeight (like IE8), bail and just link to the label.\n      if (inputRect.height && window.innerHeight) {\n        var inputBottom = inputRect.top + inputRect.height;\n        if (inputBottom - legendTop < window.innerHeight / 2) {\n          return candidateLegend;\n        }\n      }\n    }\n  }\n  return document.querySelector(\"label[for='\" + input.getAttribute('id') + \"']\") || input.closest('label');\n}\n\n/**\n * Focus the target element\n *\n * By default, the browser will scroll the target into view. Because our labels\n * or legends appear above the input, this means the user will be presented with\n * an input without any context, as the label or legend will be off the top of\n * the screen.\n *\n * Manually handling the click event, scrolling the question into view and then\n * focussing the element solves this.\n *\n * This also results in the label and/or legend being announced correctly in\n * NVDA - without this only the field type is announced\n * (e.g. 'Edit, has autocomplete').\n */\nfunction focusTarget(target) {\n  // If the element that was clicked was not a link, return early\n  if (target.tagName !== 'A' || target.href === false) {\n    return false;\n  }\n  var input = document.querySelector(target.hash);\n  if (!input) {\n    return false;\n  }\n  var legendOrLabel = getAssociatedLegendOrLabel(input);\n  if (!legendOrLabel) {\n    return false;\n  }\n\n  // Scroll the legend or label into view *before* calling focus on the input to\n  // avoid extra scrolling in browsers that don't support `preventScroll` (which\n  // at time of writing is most of them...)\n  legendOrLabel.scrollIntoView();\n  input.focus({\n    preventScroll: true\n  });\n  return true;\n}\n\n/**\n * Handle click events on the error summary\n */\nfunction handleClick(event) {\n  if (focusTarget(event.target)) {\n    event.preventDefault();\n  }\n}\n/* harmony default export */ var error_summary = (function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$focusOnPageLoad = _ref.focusOnPageLoad,\n    focusOnPageLoad = _ref$focusOnPageLoad === void 0 ? true : _ref$focusOnPageLoad,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Error summary component\n  var errorSummary = scope.querySelector('.nhsuk-error-summary');\n  if (errorSummary) {\n    // Focus error summary component if it exists\n\n    if (focusOnPageLoad) {\n      errorSummary.focus();\n    }\n    errorSummary.addEventListener('click', handleClick);\n  }\n});\n;// CONCATENATED MODULE: ./packages/components/header/header.js\n/**\n * Header component\n *\n */\nvar Header = /*#__PURE__*/function () {\n  function Header() {\n    this.menuIsOpen = false;\n    this.navigation = document.querySelector('.nhsuk-navigation');\n    this.navigationList = document.querySelector('.nhsuk-header__navigation-list');\n    this.mobileMenu = document.createElement('ul');\n    this.mobileMenuToggleButton = document.querySelector('.nhsuk-header__menu-toggle');\n    this.mobileMenuCloseButton = document.createElement('button');\n    this.mobileMenuContainer = document.querySelector('.nhsuk-mobile-menu-container');\n    this.breakpoints = [];\n    this.width = document.body.offsetWidth;\n  }\n  var _proto = Header.prototype;\n  _proto.init = function init() {\n    var _this = this;\n    if (!this.navigation || !this.navigationList || !this.mobileMenuToggleButton || !this.mobileMenuContainer) {\n      return;\n    }\n    this.setupMobileMenu();\n    this.calculateBreakpoints();\n    this.updateNavigation();\n    this.doOnOrientationChange();\n    this.handleResize = this.debounce(function () {\n      _this.calculateBreakpoints();\n      _this.updateNavigation();\n    });\n    this.mobileMenuToggleButton.addEventListener('click', this.toggleMobileMenu.bind(this));\n    window.addEventListener('resize', this.handleResize);\n    window.addEventListener('orientationchange', this.doOnOrientationChange());\n  };\n  _proto.debounce = function debounce(func, timeout) {\n    var _this2 = this;\n    if (timeout === void 0) {\n      timeout = 100;\n    }\n    var timer;\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        func.apply(_this2, args);\n      }, timeout);\n    };\n  }\n\n  /**\n   * Calculate breakpoints.\n   *\n   * Calculate the breakpoints by summing the widths of\n   * each navigation item.\n   *\n   */;\n  _proto.calculateBreakpoints = function calculateBreakpoints() {\n    // Get the width of the gap between each navigation item\n    var navigationListStyles = window.getComputedStyle(this.navigationList);\n    var gapPixels = navigationListStyles.getPropertyValue('gap');\n    var gap = Number(gapPixels.replace('px', ''));\n    var childrenWidth = 0;\n    for (var i = 0; i < this.navigationList.children.length; i++) {\n      childrenWidth += this.navigationList.children[i].offsetWidth + gap;\n      this.breakpoints[i] = childrenWidth;\n    }\n  }\n\n  // Add the mobile menu to the DOM\n  ;\n  _proto.setupMobileMenu = function setupMobileMenu() {\n    this.mobileMenuContainer.appendChild(this.mobileMenu);\n    this.mobileMenu.classList.add('nhsuk-header__drop-down', 'nhsuk-header__drop-down--hidden');\n  }\n\n  /**\n   * Close the mobile menu\n   *\n   * Closes the mobile menu and updates accessibility state.\n   *\n   * Removes the margin-bottom from the navigation\n   */;\n  _proto.closeMobileMenu = function closeMobileMenu() {\n    this.menuIsOpen = false;\n    this.mobileMenu.classList.add('nhsuk-header__drop-down--hidden');\n    this.navigation.style.marginBottom = 0;\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'false');\n    this.mobileMenuToggleButton.focus();\n    this.mobileMenuCloseButton.removeEventListener('click', this.closeMobileMenu.bind(this));\n    document.removeEventListener('keydown', this.handleEscapeKey.bind(this));\n  }\n\n  /**\n   * Escape key handler\n   *\n   * This function is called when the user\n   * presses the escape key to close the mobile menu.\n   *\n   */;\n  _proto.handleEscapeKey = function handleEscapeKey(e) {\n    if (e.key === 'Escape') {\n      this.closeMobileMenu();\n    }\n  }\n\n  /**\n   * Open the mobile menu\n   *\n   * Opens the mobile menu and updates accessibility state.\n   *\n   * The mobile menu is absolutely positioned, so it adds a margin\n   * to the bottom of the navigation to prevent it from overlapping\n   *\n   * Adds event listeners for the close button,\n   */;\n  _proto.openMobileMenu = function openMobileMenu() {\n    this.menuIsOpen = true;\n    this.mobileMenu.classList.remove('nhsuk-header__drop-down--hidden');\n    var marginBody = this.mobileMenu.offsetHeight;\n    this.navigation.style.marginBottom = marginBody + \"px\";\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'true');\n\n    // add event listener for esc key to close menu\n    document.addEventListener('keydown', this.handleEscapeKey.bind(this));\n\n    // add event listener for close icon to close menu\n    this.mobileMenuCloseButton.addEventListener('click', this.closeMobileMenu.bind(this));\n  }\n\n  /**\n   * Handle menu button click\n   *\n   * Toggles the mobile menu between open and closed\n   */;\n  _proto.toggleMobileMenu = function toggleMobileMenu() {\n    if (this.menuIsOpen) {\n      this.closeMobileMenu();\n    } else {\n      this.openMobileMenu();\n    }\n  }\n\n  /**\n   * Update nav for the available space\n   *\n   * If the available space is less than the current breakpoint,\n   * add the mobile menu toggle button and move the last\n   * item in the list to the drop-down list.\n   *\n   * If the available space is greater than the current breakpoint,\n   * remove the mobile menu toggle button and move the first item in the\n   *\n   * Additionally will close the mobile menu if the window gets resized\n   * and the menu is open.\n   */;\n  _proto.updateNavigation = function updateNavigation() {\n    var availableSpace = this.navigationList.offsetWidth;\n    var itemsVisible = this.navigationList.children.length;\n    if (availableSpace < this.breakpoints[itemsVisible - 1]) {\n      this.mobileMenuToggleButton.classList.add('nhsuk-header__menu-toggle--visible');\n      this.mobileMenuContainer.classList.add('nhsuk-mobile-menu-container--visible');\n      if (itemsVisible === 2) {\n        return;\n      }\n      while (availableSpace < this.breakpoints[itemsVisible - 1]) {\n        this.mobileMenu.insertBefore(this.navigationList.children[itemsVisible - 2], this.mobileMenu.firstChild);\n        itemsVisible -= 1;\n      }\n    } else if (availableSpace > this.breakpoints[itemsVisible]) {\n      while (availableSpace > this.breakpoints[itemsVisible]) {\n        this.navigationList.insertBefore(this.mobileMenu.removeChild(this.mobileMenu.firstChild), this.mobileMenuContainer);\n        itemsVisible += 1;\n      }\n    }\n    if (!this.mobileMenu.children.length) {\n      this.mobileMenuToggleButton.classList.remove('nhsuk-header__menu-toggle--visible');\n      this.mobileMenuContainer.classList.remove('nhsuk-mobile-menu-container--visible');\n    }\n    if (document.body.offsetWidth !== this.width && this.menuIsOpen) {\n      this.closeMobileMenu();\n    }\n  }\n\n  /**\n   * Orientation change\n   *\n   * Check the orientation of the device, if changed it will trigger a\n   * update to the breakpoints and navigation.\n   */;\n  _proto.doOnOrientationChange = function doOnOrientationChange() {\n    var _this3 = this;\n    switch (window.orientation) {\n      case 90:\n        setTimeout(function () {\n          _this3.calculateBreakpoints();\n          _this3.updateNavigation();\n        }, 200);\n        break;\n      default:\n        break;\n    }\n  };\n  return Header;\n}();\n/* harmony default export */ var header = (function () {\n  new Header().init();\n});\n;// CONCATENATED MODULE: ./packages/components/radios/radios.js\n\n\n/**\n * Conditionally show content when a radio button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/radios/conditional.html\n */\n\n/* harmony default export */ var radios = (function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Radio input HTMLElements inside a conditional form group\n  var radioInputs = scope.querySelectorAll('.nhsuk-radios--conditional .nhsuk-radios__input');\n\n  /**\n   * Update all conditional reveals to match checked state\n   */\n  var syncAllConditionalReveals = function syncAllConditionalReveals() {\n    radioInputs.forEach(function (input) {\n      return toggleConditionalInput(input, 'nhsuk-radios__conditional--hidden');\n    });\n  };\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', syncAllConditionalReveals);\n  } else {\n    window.addEventListener('DOMContentLoaded', syncAllConditionalReveals);\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  syncAllConditionalReveals();\n\n  // Attach event handler to radioInputs\n  radioInputs.forEach(function (radioButton) {\n    radioButton.addEventListener('change', syncAllConditionalReveals);\n  });\n});\n;// CONCATENATED MODULE: ./packages/components/skip-link/skip-link.js\n\n\n/*\n * NHS.UK skip link.\n *\n * When using VoiceOver on iOS, focus remains on the skip link anchor\n * when elected so the next focusable element is not at the jumped to area.\n */\n\n/* harmony default export */ var skip_link = (function () {\n  var $skipLink = document.querySelector('.nhsuk-skip-link');\n\n  // Check for skip link\n  if (!$skipLink || !($skipLink instanceof HTMLAnchorElement)) {\n    return;\n  }\n  var linkedElementId = $skipLink.hash.split('#').pop();\n  var $linkedElement = linkedElementId ? document.getElementById(linkedElementId) : null;\n\n  // Check for linked element\n  if (!$linkedElement) {\n    return;\n  }\n\n  /**\n   * Focus the linked element on click\n   *\n   * Adds a helper CSS class to hide native focus styles,\n   * but removes it on blur to restore native focus styles\n   */\n  $skipLink.addEventListener('click', function () {\n    return setFocus($linkedElement, {\n      onBeforeFocus: function onBeforeFocus() {\n        $linkedElement.classList.add('nhsuk-skip-link-focused-element');\n      },\n      onBlur: function onBlur() {\n        $linkedElement.classList.remove('nhsuk-skip-link-focused-element');\n      }\n    });\n  });\n});\n;// CONCATENATED MODULE: ./packages/components/tabs/tabs.js\nvar Tabs = /*#__PURE__*/function () {\n  function Tabs($module, namespace, responsive, historyEnabled) {\n    this.$module = $module;\n    this.namespace = namespace;\n    this.responsive = responsive;\n    this.historyEnabled = historyEnabled;\n    this.$tabs = $module.querySelectorAll(\".\" + this.namespace + \"__tab\");\n    this.keys = {\n      down: 40,\n      left: 37,\n      right: 39,\n      up: 38\n    };\n    this.jsHiddenClass = this.namespace + \"__panel--hidden\";\n    this.showEvent = new CustomEvent('tab.show');\n    this.hideEvent = new CustomEvent('tab.hide');\n  }\n  var _proto = Tabs.prototype;\n  _proto.init = function init() {\n    if (typeof window.matchMedia === 'function' && this.responsive) {\n      this.setupResponsiveChecks();\n    } else {\n      this.setup();\n    }\n  };\n  _proto.setupResponsiveChecks = function setupResponsiveChecks() {\n    // $mq-breakpoints: (\n    // mobile: 320px,\n    // tablet: 641px,\n    // desktop: 769px,\n    // large - desktop: 990px\n    // );\n    this.mql = window.matchMedia('(min-width: 641px)');\n\n    // MediaQueryList.addEventListener isn't supported by Safari < 14 so we need\n    // to be able to fall back to the deprecated MediaQueryList.addListener\n    if ('addEventListener' in this.mql) {\n      this.mql.addEventListener('change', this.checkMode.bind(this));\n    } else {\n      // addListener is a deprecated function, however addEventListener\n      // isn't supported by Safari < 14. We therefore add this in as\n      // a fallback for those browsers\n      this.mql.addListener(this.checkMode.bind(this));\n    }\n    this.checkMode();\n  };\n  _proto.checkMode = function checkMode() {\n    if (this.mql.matches) {\n      this.setup();\n    } else {\n      this.teardown();\n    }\n  };\n  _proto.setup = function setup() {\n    var _this = this;\n    var $module = this.$module;\n    var $tabs = this.$tabs;\n    var $tabList = $module.querySelector(\".\" + this.namespace + \"__list\");\n    var $tabListItems = $module.querySelectorAll(\".\" + this.namespace + \"__list-item\");\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return;\n    }\n    $tabList.setAttribute('role', 'tablist');\n    $tabListItems.forEach(function ($item) {\n      $item.setAttribute('role', 'presentation');\n    });\n    $tabs.forEach(function ($tab) {\n      // Set HTML attributes\n      _this.setAttributes($tab);\n\n      // Save bounded functions to use when removing event listeners during teardown\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabClick = _this.onTabClick.bind(_this);\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabKeydown = _this.onTabKeydown.bind(_this);\n\n      // Handle events\n      $tab.addEventListener('click', $tab.boundTabClick, true);\n      $tab.addEventListener('keydown', $tab.boundTabKeydown, true);\n\n      // Remove old active panels\n      _this.hideTab($tab);\n    });\n\n    // Show either the active tab according to the URL's hash or the first tab\n    var $activeTab = this.getTab(window.location.hash) || this.$tabs[0];\n    this.showTab($activeTab);\n\n    // Handle hashchange events\n    if (this.historyEnabled) {\n      $module.boundOnHashChange = this.onHashChange.bind(this);\n      window.addEventListener('hashchange', $module.boundOnHashChange, true);\n    }\n  };\n  _proto.teardown = function teardown() {\n    var _this2 = this;\n    var $module = this.$module;\n    var $tabs = this.$tabs;\n    var $tabList = $module.querySelector(\".\" + this.namespace + \"__list\");\n    var $tabListItems = $module.querySelectorAll(\".\" + this.namespace + \"__list-item\");\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return;\n    }\n    $tabList.removeAttribute('role');\n    $tabListItems.forEach(function ($item) {\n      $item.removeAttribute('role', 'presentation');\n    });\n    $tabs.forEach(function ($tab) {\n      // Remove events\n      $tab.removeEventListener('click', $tab.boundTabClick, true);\n      $tab.removeEventListener('keydown', $tab.boundTabKeydown, true);\n\n      // Unset HTML attributes\n      _this2.unsetAttributes($tab);\n    });\n    if (this.historyEnabled) {\n      // Remove hashchange event handler\n      window.removeEventListener('hashchange', $module.boundOnHashChange, true);\n    }\n  };\n  _proto.onHashChange = function onHashChange() {\n    var hash = window.location.hash;\n    var $tabWithHash = this.getTab(hash);\n    if (!$tabWithHash) {\n      return;\n    }\n\n    // Prevent changing the hash\n    if (this.changingHash) {\n      this.changingHash = false;\n      return;\n    }\n\n    // Show either the active tab according to the URL's hash or the first tab\n    var $previousTab = this.getCurrentTab();\n    this.hideTab($previousTab);\n    this.showTab($tabWithHash);\n    $tabWithHash.focus();\n  };\n  _proto.hideTab = function hideTab($tab) {\n    this.unhighlightTab($tab);\n    this.hidePanel($tab);\n  };\n  _proto.showTab = function showTab($tab) {\n    this.highlightTab($tab);\n    this.showPanel($tab);\n  };\n  _proto.getTab = function getTab(hash) {\n    return this.$module.querySelector(\".\" + this.namespace + \"__tab[href=\\\"\" + hash + \"\\\"]\");\n  };\n  _proto.setAttributes = function setAttributes($tab) {\n    // set tab attributes\n    var panelId = Tabs.getHref($tab).slice(1);\n    $tab.setAttribute('id', \"tab_\" + panelId);\n    $tab.setAttribute('role', 'tab');\n    $tab.setAttribute('aria-controls', panelId);\n    $tab.setAttribute('aria-selected', 'false');\n    $tab.setAttribute('tabindex', '-1');\n\n    // set panel attributes\n    var $panel = this.getPanel($tab);\n    $panel.setAttribute('role', 'tabpanel');\n    $panel.setAttribute('aria-labelledby', $tab.id);\n    $panel.classList.add(this.jsHiddenClass);\n  };\n  _proto.unsetAttributes = function unsetAttributes($tab) {\n    // unset tab attributes\n    $tab.removeAttribute('id');\n    $tab.removeAttribute('role');\n    $tab.removeAttribute('aria-controls');\n    $tab.removeAttribute('aria-selected');\n    $tab.removeAttribute('tabindex');\n\n    // unset panel attributes\n    var $panel = this.getPanel($tab);\n    $panel.removeAttribute('role');\n    $panel.removeAttribute('aria-labelledby');\n    $panel.removeAttribute('tabindex');\n    $panel.classList.remove(this.jsHiddenClass);\n  };\n  _proto.onTabClick = function onTabClick(e) {\n    if (!e.target.classList.contains(this.namespace + \"__tab\")) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n    e.preventDefault();\n    var $newTab = e.target;\n    var $currentTab = this.getCurrentTab();\n    this.hideTab($currentTab);\n    this.showTab($newTab);\n    this.createHistoryEntry($newTab);\n  };\n  _proto.createHistoryEntry = function createHistoryEntry($tab) {\n    if (this.historyEnabled) {\n      var $panel = this.getPanel($tab);\n\n      // Save and restore the id\n      // so the page doesn't jump when a user clicks a tab (which changes the hash)\n      var id = $panel.id;\n      $panel.id = '';\n      this.changingHash = true;\n      window.location.hash = Tabs.getHref($tab).slice(1);\n      $panel.id = id;\n    }\n  };\n  _proto.onTabKeydown = function onTabKeydown(e) {\n    switch (e.keyCode) {\n      case this.keys.left:\n      case this.keys.up:\n        this.activatePreviousTab();\n        e.preventDefault();\n        break;\n      case this.keys.right:\n      case this.keys.down:\n        this.activateNextTab();\n        e.preventDefault();\n        break;\n      default:\n    }\n  };\n  _proto.activateNextTab = function activateNextTab() {\n    var currentTab = this.getCurrentTab();\n    var nextTabListItem = currentTab.parentNode.nextElementSibling;\n    var nextTab;\n    if (nextTabListItem) {\n      nextTab = nextTabListItem.querySelector(\".\" + this.namespace + \"__tab\");\n    }\n    if (nextTab) {\n      this.hideTab(currentTab);\n      this.showTab(nextTab);\n      nextTab.focus();\n      this.createHistoryEntry(nextTab);\n    }\n  };\n  _proto.activatePreviousTab = function activatePreviousTab() {\n    var currentTab = this.getCurrentTab();\n    var previousTabListItem = currentTab.parentNode.previousElementSibling;\n    var previousTab;\n    if (previousTabListItem) {\n      previousTab = previousTabListItem.querySelector(\".\" + this.namespace + \"__tab\");\n    }\n    if (previousTab) {\n      this.hideTab(currentTab);\n      this.showTab(previousTab);\n      previousTab.focus();\n      this.createHistoryEntry(previousTab);\n    }\n  };\n  _proto.getPanel = function getPanel($tab) {\n    var $panel = this.$module.querySelector(Tabs.getHref($tab));\n    return $panel;\n  };\n  _proto.showPanel = function showPanel($tab) {\n    var $panel = this.getPanel($tab);\n    $panel.classList.remove(this.jsHiddenClass);\n    $panel.dispatchEvent(this.showEvent);\n  };\n  _proto.hidePanel = function hidePanel(tab) {\n    var $panel = this.getPanel(tab);\n    $panel.classList.add(this.jsHiddenClass);\n    $panel.dispatchEvent(this.hideEvent);\n  };\n  _proto.unhighlightTab = function unhighlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'false');\n    $tab.parentNode.classList.remove(this.namespace + \"__list-item--selected\");\n    $tab.setAttribute('tabindex', '-1');\n  };\n  _proto.highlightTab = function highlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'true');\n    $tab.parentNode.classList.add(this.namespace + \"__list-item--selected\");\n    $tab.setAttribute('tabindex', '0');\n  };\n  _proto.getCurrentTab = function getCurrentTab() {\n    return this.$module.querySelector(\".\" + this.namespace + \"__list-item--selected .\" + this.namespace + \"__tab\");\n  }\n\n  // this is because IE doesn't always return the actual value but a relative full path\n  // should be a utility function most prob\n  // http://labs.thesedays.com/blog/2010/01/08/getting-the-href-value-with-jquery-in-ie/\n  ;\n  Tabs.getHref = function getHref($tab) {\n    var href = $tab.getAttribute('href');\n    var hash = href.slice(href.indexOf('#'), href.length);\n    return hash;\n  };\n  return Tabs;\n}();\n/**\n * Main function to invoke tabs. Can be called as follows to alter various features\n *\n * Tabs({historyEnabled: false});\n * Tabs({responsive: false});\n * Tabs({namespace: 'my-custom-namespace'});  // Alters classes allowing alternative css\n */\n/* harmony default export */ var tabs = (function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$namespace = _ref.namespace,\n    namespace = _ref$namespace === void 0 ? 'nhsuk-tabs' : _ref$namespace,\n    _ref$responsive = _ref.responsive,\n    responsive = _ref$responsive === void 0 ? true : _ref$responsive,\n    _ref$historyEnabled = _ref.historyEnabled,\n    historyEnabled = _ref$historyEnabled === void 0 ? true : _ref$historyEnabled,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  var tabs = scope.querySelectorAll(\"[data-module=\\\"\" + namespace + \"\\\"]\");\n  tabs.forEach(function (el) {\n    new Tabs(el, namespace, responsive, historyEnabled).init();\n  });\n});\n// EXTERNAL MODULE: ./packages/polyfills.js\nvar polyfills = __webpack_require__(621);\n;// CONCATENATED MODULE: ./packages/nhsuk.js\n/* eslint-disable import/prefer-default-export */\n\n// Components\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Use this function to initialise nhsuk-frontend components within a\n * given scope. This function is called by default with the document\n * element, but you can call it again later with a new DOM element\n * containing nhsuk-frontend components which you wish to initialise.\n *\n * @param {HTMLElement} scope\n */\nfunction initAll(scope) {\n  button_button({\n    scope: scope\n  });\n  character_count({\n    scope: scope\n  });\n  checkboxes({\n    scope: scope\n  });\n  details({\n    scope: scope\n  });\n  error_summary({\n    scope: scope\n  });\n  radios({\n    scope: scope\n  });\n  tabs({\n    scope: scope\n  });\n}\n\n// Initialize components\ndocument.addEventListener('DOMContentLoaded', function () {\n  header();\n  skip_link();\n  initAll(document);\n});\n}();\n/******/ })()\n;\n","/**\n * IE polyfill for NodeList.forEach()\n */\nif (!NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach\n}\n\n/**\n * IE polyfill for Array.includes()\n */\nif (!Array.prototype.includes) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Array.prototype, 'includes', {\n    enumerable: false,\n    value(obj) {\n      return this.filter((el) => el === obj).length > 0\n    }\n  })\n}\n\n/**\n * IE polyfill for Element.closest()\n */\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector\n}\n\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this\n\n    do {\n      if (Element.prototype.matches.call(el, s)) return el\n      el = el.parentElement || el.parentNode\n    } while (el !== null && el.nodeType === 1)\n    return null\n  }\n}\n\n/**\n * IE polyfill for CustomEvent\n */\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function (event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null }\n    var evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n    return evt\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","class Button {\n  constructor($module) {\n    this.KEY_SPACE = 32\n    this.DEBOUNCE_TIMEOUT_IN_SECONDS = 1\n\n    this.$module = $module\n    this.debounceFormSubmitTimer = null\n  }\n\n  /**\n   * JavaScript 'shim' to trigger the click event of element(s) when the space key is pressed.\n   *\n   * Created since some Assistive Technologies (for example some Screenreaders)\n   * will tell a user to press space on a 'button', so this functionality needs to be shimmed\n   * See https://github.com/alphagov/govuk_elements/pull/272#issuecomment-233028270\n   *\n   * @param {object} event event\n   */\n  handleKeyDown(event) {\n    // get the target element\n\n    const { target } = event\n    // if the element has a role='button' and the pressed key is a space, we'll simulate a click\n    if (\n      target.getAttribute('role') === 'button' &&\n      event.keyCode === this.KEY_SPACE\n    ) {\n      event.preventDefault()\n      // trigger the target's click event\n      target.click()\n    }\n  }\n\n  /**\n   * If the click quickly succeeds a previous click then nothing will happen.\n   * This stops people accidentally causing multiple form submissions by\n   * double clicking buttons.\n   */\n  debounce(event) {\n    const { target } = event\n    // Check the button that is clicked on has the preventDoubleClick feature enabled\n    if (target.getAttribute('data-prevent-double-click') !== 'true') {\n      return\n    }\n\n    // If the timer is still running then we want to prevent the click from submitting the form\n    if (this.debounceFormSubmitTimer) {\n      event.preventDefault()\n      return false // eslint-disable-line consistent-return\n    }\n\n    this.debounceFormSubmitTimer = setTimeout(() => {\n      this.debounceFormSubmitTimer = null\n    }, this.DEBOUNCE_TIMEOUT_IN_SECONDS * 1000)\n  }\n\n  /**\n   * Initialise an event listener for keydown at document level\n   * this will help listening for later inserted elements with a role=\"button\"\n   */\n  init() {\n    this.$module.addEventListener('keydown', this.handleKeyDown.bind(this))\n    this.$module.addEventListener('click', this.debounce.bind(this))\n  }\n}\n\nexport default ({ scope = document } = {}) => {\n  const buttons = scope.querySelectorAll('[data-module=\"nhsuk-button\"]')\n  buttons.forEach((el) => {\n    new Button(el).init()\n  })\n}\n","class CharacterCount {\n  constructor($module) {\n    this.$module = $module\n    this.$textarea = $module.querySelector('.nhsuk-js-character-count')\n    this.$visibleCountMessage = null\n    this.$screenReaderCountMessage = null\n    this.lastInputTimestamp = null\n  }\n\n  // Initialize component\n  init() {\n    // Check that required elements are present\n    if (!this.$textarea) {\n      return\n    }\n\n    // Check for module\n    const { $module } = this\n    const { $textarea } = this\n    const $fallbackLimitMessage = document.getElementById(\n      `${$textarea.id}-info`\n    )\n\n    // Move the fallback count message to be immediately after the textarea\n    // Kept for backwards compatibility\n    $textarea.insertAdjacentElement('afterend', $fallbackLimitMessage)\n\n    // Create the *screen reader* specific live-updating counter\n    // This doesn't need any styling classes, as it is never visible\n    const $screenReaderCountMessage = document.createElement('div')\n    $screenReaderCountMessage.className =\n      'nhsuk-character-count__sr-status nhsuk-u-visually-hidden'\n    $screenReaderCountMessage.setAttribute('aria-live', 'polite')\n    this.$screenReaderCountMessage = $screenReaderCountMessage\n    $fallbackLimitMessage.insertAdjacentElement(\n      'afterend',\n      $screenReaderCountMessage\n    )\n\n    // Create our live-updating counter element, copying the classes from the\n    // fallback element for backwards compatibility as these may have been configured\n    const $visibleCountMessage = document.createElement('div')\n    $visibleCountMessage.className = $fallbackLimitMessage.className\n    $visibleCountMessage.classList.add('nhsuk-character-count__status')\n    $visibleCountMessage.setAttribute('aria-hidden', 'true')\n    this.$visibleCountMessage = $visibleCountMessage\n    $fallbackLimitMessage.insertAdjacentElement(\n      'afterend',\n      $visibleCountMessage\n    )\n\n    // Hide the fallback limit message\n    $fallbackLimitMessage.classList.add('nhsuk-u-visually-hidden')\n\n    // Read options set using dataset ('data-' values)\n    this.options = CharacterCount.getDataset($module)\n\n    // Determine the limit attribute (characters or words)\n    let countAttribute = this.defaults.characterCountAttribute\n    if (this.options.maxwords) {\n      countAttribute = this.defaults.wordCountAttribute\n    }\n\n    // Save the element limit\n    this.maxLength = $module.getAttribute(countAttribute)\n\n    // Check for limit\n    if (!this.maxLength) {\n      return\n    }\n\n    // Remove hard limit if set\n    $textarea.removeAttribute('maxlength')\n\n    this.bindChangeEvents()\n\n    // When the page is restored after navigating 'back' in some browsers the\n    // state of the character count is not restored until *after* the DOMContentLoaded\n    // event is fired, so we need to manually update it after the pageshow event\n    // in browsers that support it.\n    if ('onpageshow' in window) {\n      window.addEventListener('pageshow', this.updateCountMessage.bind(this))\n    } else {\n      window.addEventListener(\n        'DOMContentLoaded',\n        this.updateCountMessage.bind(this)\n      )\n    }\n    this.updateCountMessage()\n  }\n\n  // Read data attributes\n  static getDataset(element) {\n    const dataset = {}\n    const { attributes } = element\n    if (attributes) {\n      for (let i = 0; i < attributes.length; i++) {\n        const attribute = attributes[i]\n        const match = attribute.name.match(/^data-(.+)/)\n        if (match) {\n          dataset[match[1]] = attribute.value\n        }\n      }\n    }\n    return dataset\n  }\n\n  // Counts characters or words in text\n  count(text) {\n    let length\n    if (this.options.maxwords) {\n      const tokens = text.match(/\\S+/g) || [] // Matches consecutive non-whitespace chars\n      length = tokens.length // eslint-disable-line prefer-destructuring\n    } else {\n      length = text.length // eslint-disable-line prefer-destructuring\n    }\n    return length\n  }\n\n  // Bind input propertychange to the elements and update based on the change\n  bindChangeEvents() {\n    const { $textarea } = this\n    $textarea.addEventListener('keyup', this.handleKeyUp.bind(this))\n\n    // Bind focus/blur events to start/stop polling\n    $textarea.addEventListener('focus', this.handleFocus.bind(this))\n    $textarea.addEventListener('blur', this.handleBlur.bind(this))\n  }\n\n  // Speech recognition software such as Dragon NaturallySpeaking will modify the\n  // fields by directly changing its `value`. These changes don't trigger events\n  // in JavaScript, so we need to poll to handle when and if they occur.\n  checkIfValueChanged() {\n    if (!this.$textarea.oldValue) {\n      this.$textarea.oldValue = ''\n    }\n    if (this.$textarea.value !== this.$textarea.oldValue) {\n      this.$textarea.oldValue = this.$textarea.value\n      this.updateCountMessage()\n    }\n  }\n\n  // Helper function to update both the visible and screen reader-specific\n  // counters simultaneously (e.g. on init)\n  updateCountMessage() {\n    this.updateVisibleCountMessage()\n    this.updateScreenReaderCountMessage()\n  }\n\n  // Update visible counter\n  updateVisibleCountMessage() {\n    const { $textarea } = this\n    const { $visibleCountMessage } = this\n    const remainingNumber = this.maxLength - this.count($textarea.value)\n\n    // If input is over the threshold, remove the disabled class which renders the\n    // counter invisible.\n    if (this.isOverThreshold()) {\n      $visibleCountMessage.classList.remove(\n        'nhsuk-character-count__message--disabled'\n      )\n    } else {\n      $visibleCountMessage.classList.add(\n        'nhsuk-character-count__message--disabled'\n      )\n    }\n\n    // Update styles\n    if (remainingNumber < 0) {\n      $textarea.classList.add('nhsuk-textarea--error')\n      $visibleCountMessage.classList.remove('nhsuk-hint')\n      $visibleCountMessage.classList.add('nhsuk-error-message')\n    } else {\n      $textarea.classList.remove('nhsuk-textarea--error')\n      $visibleCountMessage.classList.remove('nhsuk-error-message')\n      $visibleCountMessage.classList.add('nhsuk-hint')\n    }\n\n    // Update message\n    $visibleCountMessage.innerHTML = this.formattedUpdateMessage()\n  }\n\n  // Update screen reader-specific counter\n  updateScreenReaderCountMessage() {\n    const { $screenReaderCountMessage } = this\n\n    // If over the threshold, remove the aria-hidden attribute, allowing screen\n    // readers to announce the content of the element.\n    if (this.isOverThreshold()) {\n      $screenReaderCountMessage.removeAttribute('aria-hidden')\n    } else {\n      $screenReaderCountMessage.setAttribute('aria-hidden', true)\n    }\n\n    // Update message\n    $screenReaderCountMessage.innerHTML = this.formattedUpdateMessage()\n  }\n\n  // Format update message\n  formattedUpdateMessage() {\n    const { $textarea } = this\n    const { options } = this\n    const remainingNumber = this.maxLength - this.count($textarea.value)\n\n    let charVerb = 'remaining'\n    let charNoun = 'character'\n    let displayNumber = remainingNumber\n    if (options.maxwords) {\n      charNoun = 'word'\n    }\n    charNoun += remainingNumber === -1 || remainingNumber === 1 ? '' : 's'\n\n    charVerb = remainingNumber < 0 ? 'too many' : 'remaining'\n    displayNumber = Math.abs(remainingNumber)\n\n    return `You have ${displayNumber} ${charNoun} ${charVerb}`\n  }\n\n  // Checks whether the value is over the configured threshold for the input.\n  // If there is no configured threshold, it is set to 0 and this function will\n  // always return true.\n  isOverThreshold() {\n    const { $textarea } = this\n    const { options } = this\n\n    // Determine the remaining number of characters/words\n    const currentLength = this.count($textarea.value)\n    const { maxLength } = this\n\n    // Set threshold if presented in options\n    const thresholdPercent = options.threshold ? options.threshold : 0\n    const thresholdValue = (maxLength * thresholdPercent) / 100\n\n    return thresholdValue <= currentLength\n  }\n\n  // Update the visible character counter and keep track of when the last update\n  // happened for each keypress\n  handleKeyUp() {\n    this.updateVisibleCountMessage()\n    this.lastInputTimestamp = Date.now()\n  }\n\n  handleFocus() {\n    // If the field is focused, and a keyup event hasn't been detected for at\n    // least 1000 ms (1 second), then run the manual change check.\n    // This is so that the update triggered by the manual comparison doesn't\n    // conflict with debounced KeyboardEvent updates.\n    this.valueChecker = setInterval(() => {\n      if (\n        !this.lastInputTimestamp ||\n        Date.now() - 500 >= this.lastInputTimestamp\n      ) {\n        this.checkIfValueChanged()\n      }\n    }, 1000)\n  }\n\n  handleBlur() {\n    // Cancel value checking on blur\n    clearInterval(this.valueChecker)\n  }\n}\n\nCharacterCount.prototype.defaults = {\n  characterCountAttribute: 'data-maxlength',\n  wordCountAttribute: 'data-maxwords'\n}\n\nexport default ({ scope = document } = {}) => {\n  const characterCounts = scope.querySelectorAll(\n    '[data-module=\"nhsuk-character-count\"]'\n  )\n  characterCounts.forEach((el) => {\n    new CharacterCount(el).init()\n  })\n}\n","/**\n * Toggle a boolean attribute on a HTML element\n * @param {HTMLElement} element\n * @param {string} attr\n */\nexport const toggleAttribute = (element, attr) => {\n  // Return without error if element or attr are missing\n  if (!element || !attr) return\n  // Toggle attribute value. Treat no existing attr same as when set to false\n  const value = element.getAttribute(attr) === 'true' ? 'false' : 'true'\n  element.setAttribute(attr, value)\n}\n\n/**\n * Toggle a toggle a class on conditional content for an input based on checked state\n * @param {HTMLElement} input input element\n * @param {string} className class to toggle\n */\nexport const toggleConditionalInput = (input, className) => {\n  // Return without error if input or class are missing\n  if (!input || !className) return\n  // If the input has conditional content it had a data-aria-controls attribute\n  const conditionalId = input.getAttribute('aria-controls')\n  if (conditionalId) {\n    // Get the conditional element from the input data-aria-controls attribute\n    const conditionalElement = document.getElementById(conditionalId)\n    if (conditionalElement) {\n      if (input.checked) {\n        conditionalElement.classList.remove(className)\n        input.setAttribute('aria-expanded', true)\n      } else {\n        conditionalElement.classList.add(className)\n        input.setAttribute('aria-expanded', false)\n      }\n    }\n  }\n}\n\n/**\n * Move focus to element\n *\n * Sets tabindex to -1 to make the element programmatically focusable,\n * but removes it on blur as the element doesn't need to be focused again.\n *\n * Original code taken from GDS (Government Digital Service)\n * {@link https://github.com/alphagov/govuk-frontend}\n *\n * @template {HTMLElement} FocusElement\n * @param {FocusElement} $element - HTML element\n * @param {object} [options] - Handler options\n * @param {function(this: FocusElement): void} [options.onBeforeFocus] - Callback before focus\n * @param {function(this: FocusElement): void} [options.onBlur] - Callback on blur\n */\nexport function setFocus($element, options = {}) {\n  const isFocusable = $element.getAttribute('tabindex')\n\n  if (!isFocusable) {\n    $element.setAttribute('tabindex', '-1')\n  }\n\n  /**\n   * Handle element focus\n   */\n  function onFocus() {\n    $element.removeEventListener('focus', onFocus)\n    $element.addEventListener('blur', onBlur)\n  }\n\n  /**\n   * Handle element blur\n   */\n  function onBlur() {\n    $element.removeEventListener('blur', onBlur)\n\n    if (options.onBlur) {\n      options.onBlur.call($element)\n    }\n\n    if (!isFocusable) {\n      $element.removeAttribute('tabindex')\n    }\n  }\n\n  // Add listener to reset element on blur, after focus\n  $element.addEventListener('focus', onFocus)\n\n  // Focus element\n  if (options.onBeforeFocus) {\n    options.onBeforeFocus.call($element)\n  }\n\n  $element.focus()\n}\n","import { toggleConditionalInput } from '../../common.js'\n\n/**\n * Conditionally show content when a checkbox button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/checkboxes/conditional.html\n */\nconst syncAllConditionalReveals = function syncAllConditionalReveals(input) {\n  const allInputsInForm = input.form.querySelectorAll('input[type=\"checkbox\"]')\n  allInputsInForm.forEach((item) =>\n    toggleConditionalInput(item, 'nhsuk-checkboxes__conditional--hidden')\n  )\n}\n\n/**\n * Uncheck other checkboxes\n *\n * Find any other checkbox inputs with the checkbox group value, and uncheck them.\n * This is useful for when a â€œNone of these\" checkbox is checked.\n */\nconst unCheckAllInputsExcept = function unCheckAllInputsExcept(input) {\n  const allInputsInSameExclusiveGroup = input.form.querySelectorAll(\n    `input[type=\"checkbox\"][data-checkbox-exclusive-group=\"${input.getAttribute('data-checkbox-exclusive-group')}\"]`\n  )\n\n  allInputsInSameExclusiveGroup.forEach((inputWithSameName) => {\n    const hasSameFormOwner = input.form === inputWithSameName.form\n    if (hasSameFormOwner && inputWithSameName !== input) {\n      inputWithSameName.checked = false // eslint-disable-line no-param-reassign\n    }\n  })\n\n  syncAllConditionalReveals(input)\n}\n\n/**\n * Uncheck exclusive inputs\n *\n * Find any checkbox inputs with the same checkbox group value and the 'exclusive' behaviour,\n * and uncheck them. This helps prevent someone checking both a regular checkbox and a\n * \"None of these\" checkbox in the same fieldset.\n */\nconst unCheckExclusiveInputs = function unCheckExclusiveInputs(input) {\n  const allExclusiveInputsInSameExclusiveGroup = input.form.querySelectorAll(\n    `input[type=\"checkbox\"][data-checkbox-exclusive][data-checkbox-exclusive-group=\"${input.getAttribute(\n      'data-checkbox-exclusive-group'\n    )}\"]`\n  )\n\n  allExclusiveInputsInSameExclusiveGroup.forEach((exclusiveInput) => {\n    const hasSameFormOwner = input.form === exclusiveInput.form\n    if (hasSameFormOwner) {\n      exclusiveInput.checked = false // eslint-disable-line no-param-reassign\n    }\n  })\n\n  syncAllConditionalReveals(input)\n}\n\nexport default ({ scope = document } = {}) => {\n  // Checkbox input DOMElements inside a conditional form group\n  const checkboxInputs = scope.querySelectorAll(\n    '.nhsuk-checkboxes .nhsuk-checkboxes__input'\n  )\n\n  /**\n   * Toggle classes and attributes\n   * @param {Object} event click event object\n   */\n  const handleClick = (event) => {\n    // Toggle conditional content based on checked state\n    toggleConditionalInput(\n      event.target,\n      'nhsuk-checkboxes__conditional--hidden'\n    )\n\n    if (!event.target.checked) {\n      return\n    }\n\n    // Handle 'exclusive' checkbox behaviour (ie \"None of these\")\n    if (event.target.hasAttribute('data-checkbox-exclusive')) {\n      unCheckAllInputsExcept(event.target)\n    } else {\n      unCheckExclusiveInputs(event.target)\n    }\n  }\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', () =>\n      checkboxInputs.forEach((input) => syncAllConditionalReveals(input))\n    )\n  } else {\n    window.addEventListener('DOMContentLoaded', () =>\n      checkboxInputs.forEach((input) => syncAllConditionalReveals(input))\n    )\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  checkboxInputs.forEach((input) => syncAllConditionalReveals(input))\n\n  // Attach handleClick as click to checkboxInputs\n  checkboxInputs.forEach((checkboxButton) => {\n    checkboxButton.addEventListener('change', handleClick)\n  })\n}\n","import { toggleAttribute } from '../../common.js'\n\n/**\n * Ensure details component is cross browser and accessible\n * Test at http://localhost:3000/nhsuk-frontend/components/details/index.html\n */\n\nexport default ({ scope = document } = {}) => {\n  // Does the browser support details component\n  const nativeSupport =\n    typeof document.createElement('details').open === 'boolean'\n  if (nativeSupport) {\n    return\n  }\n\n  // Nodelist of all details elements\n  const allDetails = scope.querySelectorAll('details')\n\n  /**\n   * Adds all necessary functionality to a details element\n   * @param {HTMLElement} element details element to initialise\n   * @param {number} index number to be appended to dynamic IDs\n   */\n  const initDetails = (element, index) => {\n    // Set details element as polyfilled to prevent duplicate events being added\n    element.setAttribute('nhsuk-polyfilled', 'true')\n\n    // Give details element an ID if it doesn't already have one\n    if (!element.id) element.setAttribute('id', `nhsuk-details${index}`)\n\n    // Set content element and give it an ID if it doesn't already have one\n    const content = scope.querySelector(`#${element.id} .nhsuk-details__text`)\n    if (!content.id) content.setAttribute('id', `nhsuk-details__text${index}`)\n\n    // Set summary element\n    const summary = scope.querySelector(\n      `#${element.id} .nhsuk-details__summary`\n    )\n\n    // Set initial summary aria attributes\n    summary.setAttribute('role', 'button')\n    summary.setAttribute('aria-controls', content.id)\n    summary.setAttribute('tabIndex', '0')\n    const openAttr = element.getAttribute('open') !== null\n    if (openAttr === true) {\n      summary.setAttribute('aria-expanded', 'true')\n      content.setAttribute('aria-hidden', 'false')\n    } else {\n      summary.setAttribute('aria-expanded', 'false')\n      content.setAttribute('aria-hidden', 'true')\n      content.style.display = 'none'\n    }\n\n    const toggleDetails = () => {\n      toggleAttribute(summary, 'aria-expanded')\n      toggleAttribute(content, 'aria-hidden')\n\n      content.style.display =\n        content.getAttribute('aria-hidden') === 'true' ? 'none' : ''\n      if (element.hasAttribute('open')) {\n        element.removeAttribute('open')\n      } else {\n        element.setAttribute('open', 'open')\n      }\n    }\n\n    // Toggle details onclick\n    summary.addEventListener('click', toggleDetails)\n\n    // Call toggle details on enter and space key events\n    summary.addEventListener('keydown', (event) => {\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault()\n        summary.click()\n      }\n    })\n  }\n\n  // Initialise details for any new details element\n  if (allDetails.length) {\n    allDetails.forEach((element, index) => {\n      if (!element.hasAttribute('nhsuk-polyfilled')) initDetails(element, index)\n    })\n  }\n}\n","/**\n * Adapted from https://github.com/alphagov/govuk-frontend/blob/master/src/govuk/components/error-summary/error-summary.js\n */\n\n/**\n * Get associated legend or label\n *\n * Returns the first element that exists from this list:\n *\n * - The `<legend>` associated with the closest `<fieldset>` ancestor, as long\n *   as the top of it is no more than half a viewport height away from the\n *   bottom of the input\n * - The first `<label>` that is associated with the input using for='inputId'\n * - The closest parent `<label>`\n */\nfunction getAssociatedLegendOrLabel(input) {\n  const fieldset = input.closest('fieldset')\n\n  if (fieldset) {\n    const legends = fieldset.getElementsByTagName('legend')\n\n    if (legends.length) {\n      const candidateLegend = legends[0] // eslint-disable-line prefer-destructuring\n\n      // If the input type is radio or checkbox, always use the legend if there\n      // is one.\n      if (input.type === 'checkbox' || input.type === 'radio') {\n        return candidateLegend\n      }\n\n      // For other input types, only scroll to the fieldsetâ€™s legend (instead of\n      // the label associated with the input) if the input would end up in the\n      // top half of the screen.\n      //\n      // This should avoid situations where the input either ends up off the\n      // screen, or obscured by a software keyboard.\n      const legendTop = candidateLegend.getBoundingClientRect().top\n      const inputRect = input.getBoundingClientRect()\n\n      // If the browser doesn't support Element.getBoundingClientRect().height\n      // or window.innerHeight (like IE8), bail and just link to the label.\n      if (inputRect.height && window.innerHeight) {\n        const inputBottom = inputRect.top + inputRect.height\n\n        if (inputBottom - legendTop < window.innerHeight / 2) {\n          return candidateLegend\n        }\n      }\n    }\n  }\n\n  return (\n    document.querySelector(`label[for='${input.getAttribute('id')}']`) ||\n    input.closest('label')\n  )\n}\n\n/**\n * Focus the target element\n *\n * By default, the browser will scroll the target into view. Because our labels\n * or legends appear above the input, this means the user will be presented with\n * an input without any context, as the label or legend will be off the top of\n * the screen.\n *\n * Manually handling the click event, scrolling the question into view and then\n * focussing the element solves this.\n *\n * This also results in the label and/or legend being announced correctly in\n * NVDA - without this only the field type is announced\n * (e.g. 'Edit, has autocomplete').\n */\nfunction focusTarget(target) {\n  // If the element that was clicked was not a link, return early\n  if (target.tagName !== 'A' || target.href === false) {\n    return false\n  }\n\n  const input = document.querySelector(target.hash)\n  if (!input) {\n    return false\n  }\n\n  const legendOrLabel = getAssociatedLegendOrLabel(input)\n  if (!legendOrLabel) {\n    return false\n  }\n\n  // Scroll the legend or label into view *before* calling focus on the input to\n  // avoid extra scrolling in browsers that don't support `preventScroll` (which\n  // at time of writing is most of them...)\n  legendOrLabel.scrollIntoView()\n  input.focus({ preventScroll: true })\n\n  return true\n}\n\n/**\n * Handle click events on the error summary\n */\nfunction handleClick(event) {\n  if (focusTarget(event.target)) {\n    event.preventDefault()\n  }\n}\n\nexport default ({ focusOnPageLoad = true, scope = document } = {}) => {\n  // Error summary component\n  const errorSummary = scope.querySelector('.nhsuk-error-summary')\n\n  if (errorSummary) {\n    // Focus error summary component if it exists\n\n    if (focusOnPageLoad) {\n      errorSummary.focus()\n    }\n    errorSummary.addEventListener('click', handleClick)\n  }\n}\n","/**\n * Header component\n *\n */\n\nclass Header {\n  constructor() {\n    this.menuIsOpen = false\n    this.navigation = document.querySelector('.nhsuk-navigation')\n    this.navigationList = document.querySelector(\n      '.nhsuk-header__navigation-list'\n    )\n    this.mobileMenu = document.createElement('ul')\n    this.mobileMenuToggleButton = document.querySelector(\n      '.nhsuk-header__menu-toggle'\n    )\n    this.mobileMenuCloseButton = document.createElement('button')\n    this.mobileMenuContainer = document.querySelector(\n      '.nhsuk-mobile-menu-container'\n    )\n    this.breakpoints = []\n    this.width = document.body.offsetWidth\n  }\n\n  init() {\n    if (\n      !this.navigation ||\n      !this.navigationList ||\n      !this.mobileMenuToggleButton ||\n      !this.mobileMenuContainer\n    ) {\n      return\n    }\n\n    this.setupMobileMenu()\n    this.calculateBreakpoints()\n    this.updateNavigation()\n    this.doOnOrientationChange()\n\n    this.handleResize = this.debounce(() => {\n      this.calculateBreakpoints()\n      this.updateNavigation()\n    })\n\n    this.mobileMenuToggleButton.addEventListener(\n      'click',\n      this.toggleMobileMenu.bind(this)\n    )\n    window.addEventListener('resize', this.handleResize)\n    window.addEventListener('orientationchange', this.doOnOrientationChange())\n  }\n\n  debounce(func, timeout = 100) {\n    let timer\n    return (...args) => {\n      clearTimeout(timer)\n      timer = setTimeout(() => {\n        func.apply(this, args)\n      }, timeout)\n    }\n  }\n\n  /**\n   * Calculate breakpoints.\n   *\n   * Calculate the breakpoints by summing the widths of\n   * each navigation item.\n   *\n   */\n  calculateBreakpoints() {\n    // Get the width of the gap between each navigation item\n    const navigationListStyles = window.getComputedStyle(this.navigationList)\n    const gapPixels = navigationListStyles.getPropertyValue('gap')\n    const gap = Number(gapPixels.replace('px', ''))\n\n    let childrenWidth = 0\n    for (let i = 0; i < this.navigationList.children.length; i++) {\n      childrenWidth += this.navigationList.children[i].offsetWidth + gap\n      this.breakpoints[i] = childrenWidth\n    }\n  }\n\n  // Add the mobile menu to the DOM\n  setupMobileMenu() {\n    this.mobileMenuContainer.appendChild(this.mobileMenu)\n    this.mobileMenu.classList.add(\n      'nhsuk-header__drop-down',\n      'nhsuk-header__drop-down--hidden'\n    )\n  }\n\n  /**\n   * Close the mobile menu\n   *\n   * Closes the mobile menu and updates accessibility state.\n   *\n   * Removes the margin-bottom from the navigation\n   */\n  closeMobileMenu() {\n    this.menuIsOpen = false\n    this.mobileMenu.classList.add('nhsuk-header__drop-down--hidden')\n    this.navigation.style.marginBottom = 0\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'false')\n    this.mobileMenuToggleButton.focus()\n    this.mobileMenuCloseButton.removeEventListener(\n      'click',\n      this.closeMobileMenu.bind(this)\n    )\n    document.removeEventListener('keydown', this.handleEscapeKey.bind(this))\n  }\n\n  /**\n   * Escape key handler\n   *\n   * This function is called when the user\n   * presses the escape key to close the mobile menu.\n   *\n   */\n  handleEscapeKey(e) {\n    if (e.key === 'Escape') {\n      this.closeMobileMenu()\n    }\n  }\n\n  /**\n   * Open the mobile menu\n   *\n   * Opens the mobile menu and updates accessibility state.\n   *\n   * The mobile menu is absolutely positioned, so it adds a margin\n   * to the bottom of the navigation to prevent it from overlapping\n   *\n   * Adds event listeners for the close button,\n   */\n\n  openMobileMenu() {\n    this.menuIsOpen = true\n    this.mobileMenu.classList.remove('nhsuk-header__drop-down--hidden')\n    const marginBody = this.mobileMenu.offsetHeight\n    this.navigation.style.marginBottom = `${marginBody}px`\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'true')\n\n    // add event listener for esc key to close menu\n    document.addEventListener('keydown', this.handleEscapeKey.bind(this))\n\n    // add event listener for close icon to close menu\n    this.mobileMenuCloseButton.addEventListener(\n      'click',\n      this.closeMobileMenu.bind(this)\n    )\n  }\n\n  /**\n   * Handle menu button click\n   *\n   * Toggles the mobile menu between open and closed\n   */\n  toggleMobileMenu() {\n    if (this.menuIsOpen) {\n      this.closeMobileMenu()\n    } else {\n      this.openMobileMenu()\n    }\n  }\n\n  /**\n   * Update nav for the available space\n   *\n   * If the available space is less than the current breakpoint,\n   * add the mobile menu toggle button and move the last\n   * item in the list to the drop-down list.\n   *\n   * If the available space is greater than the current breakpoint,\n   * remove the mobile menu toggle button and move the first item in the\n   *\n   * Additionally will close the mobile menu if the window gets resized\n   * and the menu is open.\n   */\n\n  updateNavigation() {\n    const availableSpace = this.navigationList.offsetWidth\n    let itemsVisible = this.navigationList.children.length\n\n    if (availableSpace < this.breakpoints[itemsVisible - 1]) {\n      this.mobileMenuToggleButton.classList.add(\n        'nhsuk-header__menu-toggle--visible'\n      )\n      this.mobileMenuContainer.classList.add(\n        'nhsuk-mobile-menu-container--visible'\n      )\n      if (itemsVisible === 2) {\n        return\n      }\n      while (availableSpace < this.breakpoints[itemsVisible - 1]) {\n        this.mobileMenu.insertBefore(\n          this.navigationList.children[itemsVisible - 2],\n          this.mobileMenu.firstChild\n        )\n        itemsVisible -= 1\n      }\n    } else if (availableSpace > this.breakpoints[itemsVisible]) {\n      while (availableSpace > this.breakpoints[itemsVisible]) {\n        this.navigationList.insertBefore(\n          this.mobileMenu.removeChild(this.mobileMenu.firstChild),\n          this.mobileMenuContainer\n        )\n        itemsVisible += 1\n      }\n    }\n\n    if (!this.mobileMenu.children.length) {\n      this.mobileMenuToggleButton.classList.remove(\n        'nhsuk-header__menu-toggle--visible'\n      )\n      this.mobileMenuContainer.classList.remove(\n        'nhsuk-mobile-menu-container--visible'\n      )\n    }\n\n    if (document.body.offsetWidth !== this.width && this.menuIsOpen) {\n      this.closeMobileMenu()\n    }\n  }\n\n  /**\n   * Orientation change\n   *\n   * Check the orientation of the device, if changed it will trigger a\n   * update to the breakpoints and navigation.\n   */\n  doOnOrientationChange() {\n    switch (window.orientation) {\n      case 90:\n        setTimeout(() => {\n          this.calculateBreakpoints()\n          this.updateNavigation()\n        }, 200)\n        break\n      default:\n        break\n    }\n  }\n}\n\nexport default () => {\n  new Header().init()\n}\n","class Tabs {\n  constructor($module, namespace, responsive, historyEnabled) {\n    this.$module = $module\n    this.namespace = namespace\n    this.responsive = responsive\n    this.historyEnabled = historyEnabled\n    this.$tabs = $module.querySelectorAll(`.${this.namespace}__tab`)\n\n    this.keys = {\n      down: 40,\n      left: 37,\n      right: 39,\n      up: 38\n    }\n    this.jsHiddenClass = `${this.namespace}__panel--hidden`\n\n    this.showEvent = new CustomEvent('tab.show')\n    this.hideEvent = new CustomEvent('tab.hide')\n  }\n\n  init() {\n    if (typeof window.matchMedia === 'function' && this.responsive) {\n      this.setupResponsiveChecks()\n    } else {\n      this.setup()\n    }\n  }\n\n  setupResponsiveChecks() {\n    // $mq-breakpoints: (\n    // mobile: 320px,\n    // tablet: 641px,\n    // desktop: 769px,\n    // large - desktop: 990px\n    // );\n    this.mql = window.matchMedia('(min-width: 641px)')\n\n    // MediaQueryList.addEventListener isn't supported by Safari < 14 so we need\n    // to be able to fall back to the deprecated MediaQueryList.addListener\n    if ('addEventListener' in this.mql) {\n      this.mql.addEventListener('change', this.checkMode.bind(this))\n    } else {\n      // addListener is a deprecated function, however addEventListener\n      // isn't supported by Safari < 14. We therefore add this in as\n      // a fallback for those browsers\n      this.mql.addListener(this.checkMode.bind(this))\n    }\n\n    this.checkMode()\n  }\n\n  checkMode() {\n    if (this.mql.matches) {\n      this.setup()\n    } else {\n      this.teardown()\n    }\n  }\n\n  setup() {\n    const { $module } = this\n    const { $tabs } = this\n    const $tabList = $module.querySelector(`.${this.namespace}__list`)\n    const $tabListItems = $module.querySelectorAll(\n      `.${this.namespace}__list-item`\n    )\n\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return\n    }\n\n    $tabList.setAttribute('role', 'tablist')\n\n    $tabListItems.forEach(($item) => {\n      $item.setAttribute('role', 'presentation')\n    })\n\n    $tabs.forEach(($tab) => {\n      // Set HTML attributes\n      this.setAttributes($tab)\n\n      // Save bounded functions to use when removing event listeners during teardown\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabClick = this.onTabClick.bind(this)\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabKeydown = this.onTabKeydown.bind(this)\n\n      // Handle events\n      $tab.addEventListener('click', $tab.boundTabClick, true)\n      $tab.addEventListener('keydown', $tab.boundTabKeydown, true)\n\n      // Remove old active panels\n      this.hideTab($tab)\n    })\n\n    // Show either the active tab according to the URL's hash or the first tab\n    const $activeTab = this.getTab(window.location.hash) || this.$tabs[0]\n    this.showTab($activeTab)\n\n    // Handle hashchange events\n    if (this.historyEnabled) {\n      $module.boundOnHashChange = this.onHashChange.bind(this)\n      window.addEventListener('hashchange', $module.boundOnHashChange, true)\n    }\n  }\n\n  teardown() {\n    const { $module } = this\n    const { $tabs } = this\n    const $tabList = $module.querySelector(`.${this.namespace}__list`)\n    const $tabListItems = $module.querySelectorAll(\n      `.${this.namespace}__list-item`\n    )\n\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return\n    }\n\n    $tabList.removeAttribute('role')\n\n    $tabListItems.forEach(($item) => {\n      $item.removeAttribute('role', 'presentation')\n    })\n\n    $tabs.forEach(($tab) => {\n      // Remove events\n      $tab.removeEventListener('click', $tab.boundTabClick, true)\n      $tab.removeEventListener('keydown', $tab.boundTabKeydown, true)\n\n      // Unset HTML attributes\n      this.unsetAttributes($tab)\n    })\n\n    if (this.historyEnabled) {\n      // Remove hashchange event handler\n      window.removeEventListener('hashchange', $module.boundOnHashChange, true)\n    }\n  }\n\n  onHashChange() {\n    const { hash } = window.location\n    const $tabWithHash = this.getTab(hash)\n    if (!$tabWithHash) {\n      return\n    }\n\n    // Prevent changing the hash\n    if (this.changingHash) {\n      this.changingHash = false\n      return\n    }\n\n    // Show either the active tab according to the URL's hash or the first tab\n    const $previousTab = this.getCurrentTab()\n\n    this.hideTab($previousTab)\n    this.showTab($tabWithHash)\n    $tabWithHash.focus()\n  }\n\n  hideTab($tab) {\n    this.unhighlightTab($tab)\n    this.hidePanel($tab)\n  }\n\n  showTab($tab) {\n    this.highlightTab($tab)\n    this.showPanel($tab)\n  }\n\n  getTab(hash) {\n    return this.$module.querySelector(`.${this.namespace}__tab[href=\"${hash}\"]`)\n  }\n\n  setAttributes($tab) {\n    // set tab attributes\n    const panelId = Tabs.getHref($tab).slice(1)\n    $tab.setAttribute('id', `tab_${panelId}`)\n    $tab.setAttribute('role', 'tab')\n    $tab.setAttribute('aria-controls', panelId)\n    $tab.setAttribute('aria-selected', 'false')\n    $tab.setAttribute('tabindex', '-1')\n\n    // set panel attributes\n    const $panel = this.getPanel($tab)\n    $panel.setAttribute('role', 'tabpanel')\n    $panel.setAttribute('aria-labelledby', $tab.id)\n    $panel.classList.add(this.jsHiddenClass)\n  }\n\n  unsetAttributes($tab) {\n    // unset tab attributes\n    $tab.removeAttribute('id')\n    $tab.removeAttribute('role')\n    $tab.removeAttribute('aria-controls')\n    $tab.removeAttribute('aria-selected')\n    $tab.removeAttribute('tabindex')\n\n    // unset panel attributes\n    const $panel = this.getPanel($tab)\n    $panel.removeAttribute('role')\n    $panel.removeAttribute('aria-labelledby')\n    $panel.removeAttribute('tabindex')\n    $panel.classList.remove(this.jsHiddenClass)\n  }\n\n  onTabClick(e) {\n    if (!e.target.classList.contains(`${this.namespace}__tab`)) {\n      e.stopPropagation()\n      e.preventDefault()\n    }\n    e.preventDefault()\n    const $newTab = e.target\n    const $currentTab = this.getCurrentTab()\n    this.hideTab($currentTab)\n    this.showTab($newTab)\n    this.createHistoryEntry($newTab)\n  }\n\n  createHistoryEntry($tab) {\n    if (this.historyEnabled) {\n      const $panel = this.getPanel($tab)\n\n      // Save and restore the id\n      // so the page doesn't jump when a user clicks a tab (which changes the hash)\n      const { id } = $panel\n      $panel.id = ''\n      this.changingHash = true\n      window.location.hash = Tabs.getHref($tab).slice(1)\n      $panel.id = id\n    }\n  }\n\n  onTabKeydown(e) {\n    switch (e.keyCode) {\n      case this.keys.left:\n      case this.keys.up:\n        this.activatePreviousTab()\n        e.preventDefault()\n        break\n      case this.keys.right:\n      case this.keys.down:\n        this.activateNextTab()\n        e.preventDefault()\n        break\n\n      default:\n    }\n  }\n\n  activateNextTab() {\n    const currentTab = this.getCurrentTab()\n    const nextTabListItem = currentTab.parentNode.nextElementSibling\n    let nextTab\n\n    if (nextTabListItem) {\n      nextTab = nextTabListItem.querySelector(`.${this.namespace}__tab`)\n    }\n    if (nextTab) {\n      this.hideTab(currentTab)\n      this.showTab(nextTab)\n      nextTab.focus()\n      this.createHistoryEntry(nextTab)\n    }\n  }\n\n  activatePreviousTab() {\n    const currentTab = this.getCurrentTab()\n    const previousTabListItem = currentTab.parentNode.previousElementSibling\n    let previousTab\n\n    if (previousTabListItem) {\n      previousTab = previousTabListItem.querySelector(`.${this.namespace}__tab`)\n    }\n    if (previousTab) {\n      this.hideTab(currentTab)\n      this.showTab(previousTab)\n      previousTab.focus()\n      this.createHistoryEntry(previousTab)\n    }\n  }\n\n  getPanel($tab) {\n    const $panel = this.$module.querySelector(Tabs.getHref($tab))\n    return $panel\n  }\n\n  showPanel($tab) {\n    const $panel = this.getPanel($tab)\n    $panel.classList.remove(this.jsHiddenClass)\n    $panel.dispatchEvent(this.showEvent)\n  }\n\n  hidePanel(tab) {\n    const $panel = this.getPanel(tab)\n    $panel.classList.add(this.jsHiddenClass)\n    $panel.dispatchEvent(this.hideEvent)\n  }\n\n  unhighlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'false')\n    $tab.parentNode.classList.remove(`${this.namespace}__list-item--selected`)\n    $tab.setAttribute('tabindex', '-1')\n  }\n\n  highlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'true')\n    $tab.parentNode.classList.add(`${this.namespace}__list-item--selected`)\n    $tab.setAttribute('tabindex', '0')\n  }\n\n  getCurrentTab() {\n    return this.$module.querySelector(\n      `.${this.namespace}__list-item--selected .${this.namespace}__tab`\n    )\n  }\n\n  // this is because IE doesn't always return the actual value but a relative full path\n  // should be a utility function most prob\n  // http://labs.thesedays.com/blog/2010/01/08/getting-the-href-value-with-jquery-in-ie/\n  static getHref($tab) {\n    const href = $tab.getAttribute('href')\n    const hash = href.slice(href.indexOf('#'), href.length)\n    return hash\n  }\n}\n\n/**\n * Main function to invoke tabs. Can be called as follows to alter various features\n *\n * Tabs({historyEnabled: false});\n * Tabs({responsive: false});\n * Tabs({namespace: 'my-custom-namespace'});  // Alters classes allowing alternative css\n */\nexport default ({\n  namespace = 'nhsuk-tabs',\n  responsive = true,\n  historyEnabled = true,\n  scope = document\n} = {}) => {\n  const tabs = scope.querySelectorAll(`[data-module=\"${namespace}\"]`)\n  tabs.forEach((el) => {\n    new Tabs(el, namespace, responsive, historyEnabled).init()\n  })\n}\n","/* eslint-disable import/prefer-default-export */\n\n// Components\nimport initButton from './components/button/button.js'\nimport initCharacterCount from './components/character-count/character-count.js'\nimport initCheckboxes from './components/checkboxes/checkboxes.js'\nimport initDetails from './components/details/details.js'\nimport initErrorSummary from './components/error-summary/error-summary.js'\nimport initHeader from './components/header/header.js'\nimport initRadios from './components/radios/radios.js'\nimport initSkipLink from './components/skip-link/skip-link.js'\nimport initTabs from './components/tabs/tabs.js'\n\nimport './polyfills.js'\n\n/**\n * Use this function to initialise nhsuk-frontend components within a\n * given scope. This function is called by default with the document\n * element, but you can call it again later with a new DOM element\n * containing nhsuk-frontend components which you wish to initialise.\n *\n * @param {HTMLElement} scope\n */\nexport function initAll(scope) {\n  initButton({ scope })\n  initCharacterCount({ scope })\n  initCheckboxes({ scope })\n  initDetails({ scope })\n  initErrorSummary({ scope })\n  initRadios({ scope })\n  initTabs({ scope })\n}\n\n// Initialize components\ndocument.addEventListener('DOMContentLoaded', () => {\n  initHeader()\n  initSkipLink()\n\n  initAll(document)\n})\n","import { toggleConditionalInput } from '../../common.js'\n\n/**\n * Conditionally show content when a radio button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/radios/conditional.html\n */\n\nexport default ({ scope = document } = {}) => {\n  // Radio input HTMLElements inside a conditional form group\n  const radioInputs = scope.querySelectorAll(\n    '.nhsuk-radios--conditional .nhsuk-radios__input'\n  )\n\n  /**\n   * Update all conditional reveals to match checked state\n   */\n  const syncAllConditionalReveals = () => {\n    radioInputs.forEach((input) =>\n      toggleConditionalInput(input, 'nhsuk-radios__conditional--hidden')\n    )\n  }\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', syncAllConditionalReveals)\n  } else {\n    window.addEventListener('DOMContentLoaded', syncAllConditionalReveals)\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  syncAllConditionalReveals()\n\n  // Attach event handler to radioInputs\n  radioInputs.forEach((radioButton) => {\n    radioButton.addEventListener('change', syncAllConditionalReveals)\n  })\n}\n","import { setFocus } from '../../common.js'\n\n/*\n * NHS.UK skip link.\n *\n * When using VoiceOver on iOS, focus remains on the skip link anchor\n * when elected so the next focusable element is not at the jumped to area.\n */\n\nexport default () => {\n  const $skipLink = document.querySelector('.nhsuk-skip-link')\n\n  // Check for skip link\n  if (!$skipLink || !($skipLink instanceof HTMLAnchorElement)) {\n    return\n  }\n\n  const linkedElementId = $skipLink.hash.split('#').pop()\n  const $linkedElement = linkedElementId\n    ? document.getElementById(linkedElementId)\n    : null\n\n  // Check for linked element\n  if (!$linkedElement) {\n    return\n  }\n\n  /**\n   * Focus the linked element on click\n   *\n   * Adds a helper CSS class to hide native focus styles,\n   * but removes it on blur to restore native focus styles\n   */\n  $skipLink.addEventListener('click', () =>\n    setFocus($linkedElement, {\n      onBeforeFocus() {\n        $linkedElement.classList.add('nhsuk-skip-link-focused-element')\n      },\n      onBlur() {\n        $linkedElement.classList.remove('nhsuk-skip-link-focused-element')\n      }\n    })\n  )\n}\n"]}