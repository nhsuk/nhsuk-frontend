{"version":3,"sources":["nhsuk.js","../packages/common.js","../packages/components/button/button.js","../packages/components/character-count/character-count.js","../packages/components/checkboxes/checkboxes.js","../packages/components/details/details.js","../packages/components/error-summary/error-summary.js","../packages/components/header/header.js","../packages/components/radios/radios.js","../packages/components/skip-link/skip-link.js","../packages/components/tabs/tabs.js","../packages/nhsuk.js","../packages/polyfills.js","../webpack/bootstrap","../webpack/startup"],"names":["__webpack_modules__","module","exports","toggleAttribute","element","attr","value","getAttribute","setAttribute","toggleConditionalInput","input","className","conditionalId","conditionalElement","document","getElementById","checked","classList","remove","add","setFocus","$element","options","isFocusable","onBlur","removeEventListener","call","removeAttribute","addEventListener","onFocus","onBeforeFocus","focus","Button","$module","this","KEY_SPACE","DEBOUNCE_TIMEOUT_IN_SECONDS","debounceFormSubmitTimer","_proto","prototype","handleKeyDown","event","target","keyCode","preventDefault","click","debounce","_this","setTimeout","init","bind","_temp","_ref$scope","scope","querySelectorAll","forEach","el","CharacterCount","$textarea","querySelector","$visibleCountMessage","$screenReaderCountMessage","lastInputTimestamp","$fallbackLimitMessage","id","insertAdjacentElement","createElement","getDataset","countAttribute","defaults","characterCountAttribute","maxwords","wordCountAttribute","maxLength","bindChangeEvents","window","updateCountMessage","dataset","attributes","i","length","attribute","match","name","count","text","handleKeyUp","handleFocus","handleBlur","checkIfValueChanged","oldValue","updateVisibleCountMessage","updateScreenReaderCountMessage","remainingNumber","isOverThreshold","innerHTML","formattedUpdateMessage","charVerb","charNoun","Math","abs","currentLength","threshold","Date","now","valueChecker","setInterval","clearInterval","__unused_webpack_exports","__webpack_require__","require","syncAllConditionalReveals","form","item","checkboxInputs","handleClick","hasAttribute","inputWithSameName","exclusiveInput","unCheckExclusiveInputs","checkboxButton","open","allDetails","index","content","summary","style","display","initDetails","focusTarget","tagName","href","hash","legendOrLabel","fieldset","closest","legends","getElementsByTagName","candidateLegend","type","legendTop","getBoundingClientRect","top","inputRect","height","innerHeight","getAssociatedLegendOrLabel","scrollIntoView","preventScroll","_ref","_ref$focusOnPageLoad","focusOnPageLoad","errorSummary","Header","menuIsEnabled","menuIsOpen","navigation","navigationList","navigationItems","mobileMenu","mobileMenuToggleButton","mobileMenuContainer","width","handleEscapeKey","onEscapeKey","handleUpdateNavigation","updateNavigation","handleToggleMobileMenu","toggleMobileMenu","setupNavigation","func","timeout","timer","_len","arguments","args","Array","_key","clearTimeout","apply","resetNavigation","_this2","right","breakpoints","breakpoint","insertBefore","offsetWidth","_this3","push","setupMobileMenu","parentElement","appendChild","enableMobileMenu","disableMobileMenu","closeMobileMenu","marginBottom","key","openMobileMenu","marginBody","offsetHeight","_this4","filter","radioInputs","radioButton","$skipLink","HTMLAnchorElement","linkedElementId","split","pop","$linkedElement","Tabs","namespace","responsive","historyEnabled","$tabs","keys","down","left","up","jsHiddenClass","showEvent","CustomEvent","hideEvent","matchMedia","setupResponsiveChecks","setup","mql","checkMode","addListener","matches","teardown","$tabList","$tabListItems","$item","$tab","setAttributes","boundTabClick","onTabClick","boundTabKeydown","onTabKeydown","hideTab","$activeTab","getTab","location","showTab","boundOnHashChange","onHashChange","unsetAttributes","$tabWithHash","changingHash","$previousTab","getCurrentTab","unhighlightTab","hidePanel","highlightTab","showPanel","panelId","getHref","slice","$panel","getPanel","e","contains","stopPropagation","$newTab","$currentTab","createHistoryEntry","activatePreviousTab","activateNextTab","nextTab","currentTab","nextTabListItem","parentNode","nextElementSibling","previousTab","previousTabListItem","previousElementSibling","dispatchEvent","tab","indexOf","_ref$namespace","_ref$responsive","_ref$historyEnabled","initButton","initCharacterCount","initCheckboxes","initErrorSummary","initHeader","initRadios","initSkipLink","initTabs","initAll","NodeList","includes","Object","defineProperty","enumerable","obj","Element","msMatchesSelector","webkitMatchesSelector","s","nodeType","params","bubbles","cancelable","detail","evt","createEvent","initCustomEvent","__webpack_module_cache__","moduleId","cachedModule","undefined"],"mappings":"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","file":"nhsuk-9.3.0.min.js","sourcesContent":["/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 848:\n/***/ (function(module) {\n\n/**\n * Toggle a boolean attribute on a HTML element\n * @param {HTMLElement} element\n * @param {string} attr\n */\nvar toggleAttribute = function toggleAttribute(element, attr) {\n  // Return without error if element or attr are missing\n  if (!element || !attr) return;\n  // Toggle attribute value. Treat no existing attr same as when set to false\n  var value = element.getAttribute(attr) === 'true' ? 'false' : 'true';\n  element.setAttribute(attr, value);\n};\n\n/**\n * Toggle a toggle a class on conditional content for an input based on checked state\n * @param {HTMLElement} input input element\n * @param {string} className class to toggle\n */\nvar toggleConditionalInput = function toggleConditionalInput(input, className) {\n  // Return without error if input or class are missing\n  if (!input || !className) return;\n  // If the input has conditional content it had a data-aria-controls attribute\n  var conditionalId = input.getAttribute('aria-controls');\n  if (conditionalId) {\n    // Get the conditional element from the input data-aria-controls attribute\n    var conditionalElement = document.getElementById(conditionalId);\n    if (conditionalElement) {\n      if (input.checked) {\n        conditionalElement.classList.remove(className);\n        input.setAttribute('aria-expanded', true);\n      } else {\n        conditionalElement.classList.add(className);\n        input.setAttribute('aria-expanded', false);\n      }\n    }\n  }\n};\n\n/**\n * Move focus to element\n *\n * Sets tabindex to -1 to make the element programmatically focusable,\n * but removes it on blur as the element doesn't need to be focused again.\n *\n * Original code taken from GDS (Government Digital Service)\n * {@link https://github.com/alphagov/govuk-frontend}\n *\n * @template {HTMLElement} FocusElement\n * @param {FocusElement} $element - HTML element\n * @param {object} [options] - Handler options\n * @param {function(this: FocusElement): void} [options.onBeforeFocus] - Callback before focus\n * @param {function(this: FocusElement): void} [options.onBlur] - Callback on blur\n */\nfunction setFocus($element, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var isFocusable = $element.getAttribute('tabindex');\n  if (!isFocusable) {\n    $element.setAttribute('tabindex', '-1');\n  }\n\n  /**\n   * Handle element focus\n   */\n  function onFocus() {\n    $element.removeEventListener('focus', onFocus);\n    $element.addEventListener('blur', onBlur);\n  }\n\n  /**\n   * Handle element blur\n   */\n  function onBlur() {\n    $element.removeEventListener('blur', onBlur);\n    if (options.onBlur) {\n      options.onBlur.call($element);\n    }\n    if (!isFocusable) {\n      $element.removeAttribute('tabindex');\n    }\n  }\n\n  // Add listener to reset element on blur, after focus\n  $element.addEventListener('focus', onFocus);\n\n  // Focus element\n  if (options.onBeforeFocus) {\n    options.onBeforeFocus.call($element);\n  }\n  $element.focus();\n}\nmodule.exports = {\n  toggleAttribute: toggleAttribute,\n  toggleConditionalInput: toggleConditionalInput,\n  setFocus: setFocus\n};\n\n/***/ }),\n\n/***/ 807:\n/***/ (function(module) {\n\nvar Button = /*#__PURE__*/function () {\n  function Button($module) {\n    this.KEY_SPACE = 32;\n    this.DEBOUNCE_TIMEOUT_IN_SECONDS = 1;\n    this.$module = $module;\n    this.debounceFormSubmitTimer = null;\n  }\n\n  /**\n   * JavaScript 'shim' to trigger the click event of element(s) when the space key is pressed.\n   *\n   * Created since some Assistive Technologies (for example some Screenreaders)\n   * will tell a user to press space on a 'button', so this functionality needs to be shimmed\n   * See https://github.com/alphagov/govuk_elements/pull/272#issuecomment-233028270\n   *\n   * @param {object} event event\n   */\n  var _proto = Button.prototype;\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // get the target element\n\n    var target = event.target;\n    // if the element has a role='button' and the pressed key is a space, we'll simulate a click\n    if (target.getAttribute('role') === 'button' && event.keyCode === this.KEY_SPACE) {\n      event.preventDefault();\n      // trigger the target's click event\n      target.click();\n    }\n  }\n\n  /**\n   * If the click quickly succeeds a previous click then nothing will happen.\n   * This stops people accidentally causing multiple form submissions by\n   * double clicking buttons.\n   */;\n  _proto.debounce = function debounce(event) {\n    var _this = this;\n    var target = event.target;\n    // Check the button that is clicked on has the preventDoubleClick feature enabled\n    if (target.getAttribute('data-prevent-double-click') !== 'true') {\n      return;\n    }\n\n    // If the timer is still running then we want to prevent the click from submitting the form\n    if (this.debounceFormSubmitTimer) {\n      event.preventDefault();\n      return false; // eslint-disable-line consistent-return\n    }\n    this.debounceFormSubmitTimer = setTimeout(function () {\n      _this.debounceFormSubmitTimer = null;\n    }, this.DEBOUNCE_TIMEOUT_IN_SECONDS * 1000);\n  }\n\n  /**\n   * Initialise an event listener for keydown at document level\n   * this will help listening for later inserted elements with a role=\"button\"\n   */;\n  _proto.init = function init() {\n    this.$module.addEventListener('keydown', this.handleKeyDown.bind(this));\n    this.$module.addEventListener('click', this.debounce.bind(this));\n  };\n  return Button;\n}();\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  var buttons = scope.querySelectorAll('[data-module=\"nhsuk-button\"]');\n  buttons.forEach(function (el) {\n    new Button(el).init();\n  });\n};\n\n/***/ }),\n\n/***/ 997:\n/***/ (function(module) {\n\nvar CharacterCount = /*#__PURE__*/function () {\n  function CharacterCount($module) {\n    this.$module = $module;\n    this.$textarea = $module.querySelector('.nhsuk-js-character-count');\n    this.$visibleCountMessage = null;\n    this.$screenReaderCountMessage = null;\n    this.lastInputTimestamp = null;\n  }\n\n  // Initialize component\n  var _proto = CharacterCount.prototype;\n  _proto.init = function init() {\n    // Check that required elements are present\n    if (!this.$textarea) {\n      return;\n    }\n\n    // Check for module\n    var $module = this.$module;\n    var $textarea = this.$textarea;\n    var $fallbackLimitMessage = document.getElementById($textarea.id + \"-info\");\n\n    // Move the fallback count message to be immediately after the textarea\n    // Kept for backwards compatibility\n    $textarea.insertAdjacentElement('afterend', $fallbackLimitMessage);\n\n    // Create the *screen reader* specific live-updating counter\n    // This doesn't need any styling classes, as it is never visible\n    var $screenReaderCountMessage = document.createElement('div');\n    $screenReaderCountMessage.className = 'nhsuk-character-count__sr-status nhsuk-u-visually-hidden';\n    $screenReaderCountMessage.setAttribute('aria-live', 'polite');\n    this.$screenReaderCountMessage = $screenReaderCountMessage;\n    $fallbackLimitMessage.insertAdjacentElement('afterend', $screenReaderCountMessage);\n\n    // Create our live-updating counter element, copying the classes from the\n    // fallback element for backwards compatibility as these may have been configured\n    var $visibleCountMessage = document.createElement('div');\n    $visibleCountMessage.className = $fallbackLimitMessage.className;\n    $visibleCountMessage.classList.add('nhsuk-character-count__status');\n    $visibleCountMessage.setAttribute('aria-hidden', 'true');\n    this.$visibleCountMessage = $visibleCountMessage;\n    $fallbackLimitMessage.insertAdjacentElement('afterend', $visibleCountMessage);\n\n    // Hide the fallback limit message\n    $fallbackLimitMessage.classList.add('nhsuk-u-visually-hidden');\n\n    // Read options set using dataset ('data-' values)\n    this.options = CharacterCount.getDataset($module);\n\n    // Determine the limit attribute (characters or words)\n    var countAttribute = this.defaults.characterCountAttribute;\n    if (this.options.maxwords) {\n      countAttribute = this.defaults.wordCountAttribute;\n    }\n\n    // Save the element limit\n    this.maxLength = $module.getAttribute(countAttribute);\n\n    // Check for limit\n    if (!this.maxLength) {\n      return;\n    }\n\n    // Remove hard limit if set\n    $textarea.removeAttribute('maxlength');\n    this.bindChangeEvents();\n\n    // When the page is restored after navigating 'back' in some browsers the\n    // state of the character count is not restored until *after* the DOMContentLoaded\n    // event is fired, so we need to manually update it after the pageshow event\n    // in browsers that support it.\n    if ('onpageshow' in window) {\n      window.addEventListener('pageshow', this.updateCountMessage.bind(this));\n    } else {\n      window.addEventListener('DOMContentLoaded', this.updateCountMessage.bind(this));\n    }\n    this.updateCountMessage();\n  }\n\n  // Read data attributes\n  ;\n  CharacterCount.getDataset = function getDataset(element) {\n    var dataset = {};\n    var attributes = element.attributes;\n    if (attributes) {\n      for (var i = 0; i < attributes.length; i++) {\n        var attribute = attributes[i];\n        var match = attribute.name.match(/^data-(.+)/);\n        if (match) {\n          dataset[match[1]] = attribute.value;\n        }\n      }\n    }\n    return dataset;\n  }\n\n  // Counts characters or words in text\n  ;\n  _proto.count = function count(text) {\n    var length;\n    if (this.options.maxwords) {\n      var tokens = text.match(/\\S+/g) || []; // Matches consecutive non-whitespace chars\n      length = tokens.length; // eslint-disable-line prefer-destructuring\n    } else {\n      length = text.length; // eslint-disable-line prefer-destructuring\n    }\n    return length;\n  }\n\n  // Bind input propertychange to the elements and update based on the change\n  ;\n  _proto.bindChangeEvents = function bindChangeEvents() {\n    var $textarea = this.$textarea;\n    $textarea.addEventListener('keyup', this.handleKeyUp.bind(this));\n\n    // Bind focus/blur events to start/stop polling\n    $textarea.addEventListener('focus', this.handleFocus.bind(this));\n    $textarea.addEventListener('blur', this.handleBlur.bind(this));\n  }\n\n  // Speech recognition software such as Dragon NaturallySpeaking will modify the\n  // fields by directly changing its `value`. These changes don't trigger events\n  // in JavaScript, so we need to poll to handle when and if they occur.\n  ;\n  _proto.checkIfValueChanged = function checkIfValueChanged() {\n    if (!this.$textarea.oldValue) {\n      this.$textarea.oldValue = '';\n    }\n    if (this.$textarea.value !== this.$textarea.oldValue) {\n      this.$textarea.oldValue = this.$textarea.value;\n      this.updateCountMessage();\n    }\n  }\n\n  // Helper function to update both the visible and screen reader-specific\n  // counters simultaneously (e.g. on init)\n  ;\n  _proto.updateCountMessage = function updateCountMessage() {\n    this.updateVisibleCountMessage();\n    this.updateScreenReaderCountMessage();\n  }\n\n  // Update visible counter\n  ;\n  _proto.updateVisibleCountMessage = function updateVisibleCountMessage() {\n    var $textarea = this.$textarea;\n    var $visibleCountMessage = this.$visibleCountMessage;\n    var remainingNumber = this.maxLength - this.count($textarea.value);\n\n    // If input is over the threshold, remove the disabled class which renders the\n    // counter invisible.\n    if (this.isOverThreshold()) {\n      $visibleCountMessage.classList.remove('nhsuk-character-count__message--disabled');\n    } else {\n      $visibleCountMessage.classList.add('nhsuk-character-count__message--disabled');\n    }\n\n    // Update styles\n    if (remainingNumber < 0) {\n      $textarea.classList.add('nhsuk-textarea--error');\n      $visibleCountMessage.classList.remove('nhsuk-hint');\n      $visibleCountMessage.classList.add('nhsuk-error-message');\n    } else {\n      $textarea.classList.remove('nhsuk-textarea--error');\n      $visibleCountMessage.classList.remove('nhsuk-error-message');\n      $visibleCountMessage.classList.add('nhsuk-hint');\n    }\n\n    // Update message\n    $visibleCountMessage.innerHTML = this.formattedUpdateMessage();\n  }\n\n  // Update screen reader-specific counter\n  ;\n  _proto.updateScreenReaderCountMessage = function updateScreenReaderCountMessage() {\n    var $screenReaderCountMessage = this.$screenReaderCountMessage;\n\n    // If over the threshold, remove the aria-hidden attribute, allowing screen\n    // readers to announce the content of the element.\n    if (this.isOverThreshold()) {\n      $screenReaderCountMessage.removeAttribute('aria-hidden');\n    } else {\n      $screenReaderCountMessage.setAttribute('aria-hidden', true);\n    }\n\n    // Update message\n    $screenReaderCountMessage.innerHTML = this.formattedUpdateMessage();\n  }\n\n  // Format update message\n  ;\n  _proto.formattedUpdateMessage = function formattedUpdateMessage() {\n    var $textarea = this.$textarea;\n    var options = this.options;\n    var remainingNumber = this.maxLength - this.count($textarea.value);\n    var charVerb = 'remaining';\n    var charNoun = 'character';\n    var displayNumber = remainingNumber;\n    if (options.maxwords) {\n      charNoun = 'word';\n    }\n    charNoun += remainingNumber === -1 || remainingNumber === 1 ? '' : 's';\n    charVerb = remainingNumber < 0 ? 'too many' : 'remaining';\n    displayNumber = Math.abs(remainingNumber);\n    return \"You have \" + displayNumber + \" \" + charNoun + \" \" + charVerb;\n  }\n\n  // Checks whether the value is over the configured threshold for the input.\n  // If there is no configured threshold, it is set to 0 and this function will\n  // always return true.\n  ;\n  _proto.isOverThreshold = function isOverThreshold() {\n    var $textarea = this.$textarea;\n    var options = this.options;\n\n    // Determine the remaining number of characters/words\n    var currentLength = this.count($textarea.value);\n    var maxLength = this.maxLength;\n\n    // Set threshold if presented in options\n    var thresholdPercent = options.threshold ? options.threshold : 0;\n    var thresholdValue = maxLength * thresholdPercent / 100;\n    return thresholdValue <= currentLength;\n  }\n\n  // Update the visible character counter and keep track of when the last update\n  // happened for each keypress\n  ;\n  _proto.handleKeyUp = function handleKeyUp() {\n    this.updateVisibleCountMessage();\n    this.lastInputTimestamp = Date.now();\n  };\n  _proto.handleFocus = function handleFocus() {\n    var _this = this;\n    // If the field is focused, and a keyup event hasn't been detected for at\n    // least 1000 ms (1 second), then run the manual change check.\n    // This is so that the update triggered by the manual comparison doesn't\n    // conflict with debounced KeyboardEvent updates.\n    this.valueChecker = setInterval(function () {\n      if (!_this.lastInputTimestamp || Date.now() - 500 >= _this.lastInputTimestamp) {\n        _this.checkIfValueChanged();\n      }\n    }, 1000);\n  };\n  _proto.handleBlur = function handleBlur() {\n    // Cancel value checking on blur\n    clearInterval(this.valueChecker);\n  };\n  return CharacterCount;\n}();\nCharacterCount.prototype.defaults = {\n  characterCountAttribute: 'data-maxlength',\n  wordCountAttribute: 'data-maxwords'\n};\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  var characterCounts = scope.querySelectorAll('[data-module=\"nhsuk-character-count\"]');\n  characterCounts.forEach(function (el) {\n    new CharacterCount(el).init();\n  });\n};\n\n/***/ }),\n\n/***/ 305:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar _require = __webpack_require__(848),\n  toggleConditionalInput = _require.toggleConditionalInput;\n\n/**\n * Conditionally show content when a checkbox button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/checkboxes/conditional.html\n */\nvar syncAllConditionalReveals = function syncAllConditionalReveals(input) {\n  var allInputsInForm = input.form.querySelectorAll('input[type=\"checkbox\"]');\n  allInputsInForm.forEach(function (item) {\n    return toggleConditionalInput(item, 'nhsuk-checkboxes__conditional--hidden');\n  });\n};\n\n/**\n * Uncheck other checkboxes\n *\n * Find any other checkbox inputs with the checkbox group value, and uncheck them.\n * This is useful for when a “None of these\" checkbox is checked.\n */\nvar unCheckAllInputsExcept = function unCheckAllInputsExcept(input) {\n  var allInputsInSameExclusiveGroup = input.form.querySelectorAll(\"input[type=\\\"checkbox\\\"][data-checkbox-exclusive-group=\\\"\" + input.getAttribute('data-checkbox-exclusive-group') + \"\\\"]\");\n  allInputsInSameExclusiveGroup.forEach(function (inputWithSameName) {\n    var hasSameFormOwner = input.form === inputWithSameName.form;\n    if (hasSameFormOwner && inputWithSameName !== input) {\n      inputWithSameName.checked = false; // eslint-disable-line no-param-reassign\n    }\n  });\n  syncAllConditionalReveals(input);\n};\n\n/**\n * Uncheck exclusive inputs\n *\n * Find any checkbox inputs with the same checkbox group value and the 'exclusive' behaviour,\n * and uncheck them. This helps prevent someone checking both a regular checkbox and a\n * \"None of these\" checkbox in the same fieldset.\n */\nvar unCheckExclusiveInputs = function unCheckExclusiveInputs(input) {\n  var allExclusiveInputsInSameExclusiveGroup = input.form.querySelectorAll(\"input[type=\\\"checkbox\\\"][data-checkbox-exclusive][data-checkbox-exclusive-group=\\\"\" + input.getAttribute('data-checkbox-exclusive-group') + \"\\\"]\");\n  allExclusiveInputsInSameExclusiveGroup.forEach(function (exclusiveInput) {\n    var hasSameFormOwner = input.form === exclusiveInput.form;\n    if (hasSameFormOwner) {\n      exclusiveInput.checked = false; // eslint-disable-line no-param-reassign\n    }\n  });\n  syncAllConditionalReveals(input);\n};\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Checkbox input DOMElements inside a conditional form group\n  var checkboxInputs = scope.querySelectorAll('.nhsuk-checkboxes .nhsuk-checkboxes__input');\n\n  /**\n   * Toggle classes and attributes\n   * @param {Object} event click event object\n   */\n  var handleClick = function handleClick(event) {\n    // Toggle conditional content based on checked state\n    toggleConditionalInput(event.target, 'nhsuk-checkboxes__conditional--hidden');\n    if (!event.target.checked) {\n      return;\n    }\n\n    // Handle 'exclusive' checkbox behaviour (ie \"None of these\")\n    if (event.target.hasAttribute('data-checkbox-exclusive')) {\n      unCheckAllInputsExcept(event.target);\n    } else {\n      unCheckExclusiveInputs(event.target);\n    }\n  };\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', function () {\n      return checkboxInputs.forEach(function (input) {\n        return syncAllConditionalReveals(input);\n      });\n    });\n  } else {\n    window.addEventListener('DOMContentLoaded', function () {\n      return checkboxInputs.forEach(function (input) {\n        return syncAllConditionalReveals(input);\n      });\n    });\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  checkboxInputs.forEach(function (input) {\n    return syncAllConditionalReveals(input);\n  });\n\n  // Attach handleClick as click to checkboxInputs\n  checkboxInputs.forEach(function (checkboxButton) {\n    checkboxButton.addEventListener('change', handleClick);\n  });\n};\n\n/***/ }),\n\n/***/ 277:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar _require = __webpack_require__(848),\n  toggleAttribute = _require.toggleAttribute;\n\n/**\n * Ensure details component is cross browser and accessible\n * Test at http://localhost:3000/nhsuk-frontend/components/details/index.html\n */\n\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Does the browser support details component\n  var nativeSupport = typeof document.createElement('details').open === 'boolean';\n  if (nativeSupport) {\n    return;\n  }\n\n  // Nodelist of all details elements\n  var allDetails = scope.querySelectorAll('details');\n\n  /**\n   * Adds all necessary functionality to a details element\n   * @param {HTMLElement} element details element to initialise\n   * @param {number} index number to be appended to dynamic IDs\n   */\n  var initDetails = function initDetails(element, index) {\n    // Set details element as polyfilled to prevent duplicate events being added\n    element.setAttribute('nhsuk-polyfilled', 'true');\n\n    // Give details element an ID if it doesn't already have one\n    if (!element.id) element.setAttribute('id', \"nhsuk-details\" + index);\n\n    // Set content element and give it an ID if it doesn't already have one\n    var content = scope.querySelector(\"#\" + element.id + \" .nhsuk-details__text\");\n    if (!content.id) content.setAttribute('id', \"nhsuk-details__text\" + index);\n\n    // Set summary element\n    var summary = scope.querySelector(\"#\" + element.id + \" .nhsuk-details__summary\");\n\n    // Set initial summary aria attributes\n    summary.setAttribute('role', 'button');\n    summary.setAttribute('aria-controls', content.id);\n    summary.setAttribute('tabIndex', '0');\n    var openAttr = element.getAttribute('open') !== null;\n    if (openAttr === true) {\n      summary.setAttribute('aria-expanded', 'true');\n      content.setAttribute('aria-hidden', 'false');\n    } else {\n      summary.setAttribute('aria-expanded', 'false');\n      content.setAttribute('aria-hidden', 'true');\n      content.style.display = 'none';\n    }\n    var toggleDetails = function toggleDetails() {\n      toggleAttribute(summary, 'aria-expanded');\n      toggleAttribute(content, 'aria-hidden');\n      content.style.display = content.getAttribute('aria-hidden') === 'true' ? 'none' : '';\n      if (element.hasAttribute('open')) {\n        element.removeAttribute('open');\n      } else {\n        element.setAttribute('open', 'open');\n      }\n    };\n\n    // Toggle details onclick\n    summary.addEventListener('click', toggleDetails);\n\n    // Call toggle details on enter and space key events\n    summary.addEventListener('keydown', function (event) {\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        summary.click();\n      }\n    });\n  };\n\n  // Initialise details for any new details element\n  if (allDetails.length) {\n    allDetails.forEach(function (element, index) {\n      if (!element.hasAttribute('nhsuk-polyfilled')) initDetails(element, index);\n    });\n  }\n};\n\n/***/ }),\n\n/***/ 673:\n/***/ (function(module) {\n\n/**\n * Adapted from https://github.com/alphagov/govuk-frontend/blob/master/src/govuk/components/error-summary/error-summary.js\n */\n\n/**\n * Get associated legend or label\n *\n * Returns the first element that exists from this list:\n *\n * - The `<legend>` associated with the closest `<fieldset>` ancestor, as long\n *   as the top of it is no more than half a viewport height away from the\n *   bottom of the input\n * - The first `<label>` that is associated with the input using for='inputId'\n * - The closest parent `<label>`\n */\nfunction getAssociatedLegendOrLabel(input) {\n  var fieldset = input.closest('fieldset');\n  if (fieldset) {\n    var legends = fieldset.getElementsByTagName('legend');\n    if (legends.length) {\n      var candidateLegend = legends[0]; // eslint-disable-line prefer-destructuring\n\n      // If the input type is radio or checkbox, always use the legend if there\n      // is one.\n      if (input.type === 'checkbox' || input.type === 'radio') {\n        return candidateLegend;\n      }\n\n      // For other input types, only scroll to the fieldset’s legend (instead of\n      // the label associated with the input) if the input would end up in the\n      // top half of the screen.\n      //\n      // This should avoid situations where the input either ends up off the\n      // screen, or obscured by a software keyboard.\n      var legendTop = candidateLegend.getBoundingClientRect().top;\n      var inputRect = input.getBoundingClientRect();\n\n      // If the browser doesn't support Element.getBoundingClientRect().height\n      // or window.innerHeight (like IE8), bail and just link to the label.\n      if (inputRect.height && window.innerHeight) {\n        var inputBottom = inputRect.top + inputRect.height;\n        if (inputBottom - legendTop < window.innerHeight / 2) {\n          return candidateLegend;\n        }\n      }\n    }\n  }\n  return document.querySelector(\"label[for='\" + input.getAttribute('id') + \"']\") || input.closest('label');\n}\n\n/**\n * Focus the target element\n *\n * By default, the browser will scroll the target into view. Because our labels\n * or legends appear above the input, this means the user will be presented with\n * an input without any context, as the label or legend will be off the top of\n * the screen.\n *\n * Manually handling the click event, scrolling the question into view and then\n * focussing the element solves this.\n *\n * This also results in the label and/or legend being announced correctly in\n * NVDA - without this only the field type is announced\n * (e.g. 'Edit, has autocomplete').\n */\nfunction focusTarget(target) {\n  // If the element that was clicked was not a link, return early\n  if (target.tagName !== 'A' || target.href === false) {\n    return false;\n  }\n  var input = document.querySelector(target.hash);\n  if (!input) {\n    return false;\n  }\n  var legendOrLabel = getAssociatedLegendOrLabel(input);\n  if (!legendOrLabel) {\n    return false;\n  }\n\n  // Scroll the legend or label into view *before* calling focus on the input to\n  // avoid extra scrolling in browsers that don't support `preventScroll` (which\n  // at time of writing is most of them...)\n  legendOrLabel.scrollIntoView();\n  input.focus({\n    preventScroll: true\n  });\n  return true;\n}\n\n/**\n * Handle click events on the error summary\n */\nfunction handleClick(event) {\n  if (focusTarget(event.target)) {\n    event.preventDefault();\n  }\n}\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$focusOnPageLoad = _ref.focusOnPageLoad,\n    focusOnPageLoad = _ref$focusOnPageLoad === void 0 ? true : _ref$focusOnPageLoad,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Error summary component\n  var errorSummary = scope.querySelector('.nhsuk-error-summary');\n  if (errorSummary) {\n    // Focus error summary component if it exists\n\n    if (focusOnPageLoad) {\n      errorSummary.focus();\n    }\n    errorSummary.addEventListener('click', handleClick);\n  }\n};\n\n/***/ }),\n\n/***/ 649:\n/***/ (function(module) {\n\n/**\n * Header component\n *\n */\nvar Header = /*#__PURE__*/function () {\n  function Header() {\n    this.menuIsEnabled = false;\n    this.menuIsOpen = false;\n    this.navigation = document.querySelector('.nhsuk-navigation');\n    this.navigationList = null;\n    this.navigationItems = null;\n    if (!this.navigation) {\n      return;\n    }\n    this.navigationList = this.navigation.querySelector('.nhsuk-header__navigation-list');\n    this.navigationItems = this.navigation.querySelectorAll('.nhsuk-header__navigation-item');\n    this.mobileMenu = document.createElement('ul');\n    this.mobileMenuToggleButton = document.querySelector('.nhsuk-header__menu-toggle');\n    this.mobileMenuContainer = document.querySelector('.nhsuk-mobile-menu-container');\n    this.width = 0;\n  }\n  var _proto = Header.prototype;\n  _proto.init = function init() {\n    if (!this.navigation || !this.navigationList || !this.navigationItems || !this.navigationItems.length || !this.mobileMenuToggleButton || !this.mobileMenuContainer) {\n      return;\n    }\n    this.handleEscapeKey = this.onEscapeKey.bind(this);\n    this.handleUpdateNavigation = this.debounce(this.updateNavigation);\n    this.handleToggleMobileMenu = this.toggleMobileMenu.bind(this);\n    this.setupNavigation();\n    this.updateNavigation();\n  };\n  _proto.debounce = function debounce(func, timeout) {\n    var _this = this;\n    if (timeout === void 0) {\n      timeout = 100;\n    }\n    var timer;\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        func.apply(_this, args);\n      }, timeout);\n    };\n  }\n\n  /**\n   * Reset navigation\n   *\n   * Calculate available space by summing the width of each navigation item\n   */;\n  _proto.resetNavigation = function resetNavigation() {\n    var _this2 = this;\n    var right = 0;\n\n    // Reset and calculate widths on every resize\n    this.breakpoints.forEach(function (breakpoint) {\n      _this2.navigationList.insertBefore(breakpoint.element, _this2.mobileMenuContainer);\n\n      // Calculate widths\n      right += breakpoint.element.offsetWidth;\n      breakpoint.right = right;\n    });\n\n    // Reset space for menu button\n    this.width = this.navigationList.offsetWidth;\n  }\n\n  /**\n   * Add the breakpoints with default positions\n   */;\n  _proto.setupNavigation = function setupNavigation() {\n    var _this3 = this;\n    this.breakpoints = [];\n    this.navigationItems.forEach(function (element) {\n      _this3.breakpoints.push({\n        element: element,\n        right: 0\n      });\n    });\n\n    // Add resize listener for next update\n    window.addEventListener('resize', this.handleUpdateNavigation);\n  }\n\n  /**\n   * Add the mobile menu to the DOM\n   */;\n  _proto.setupMobileMenu = function setupMobileMenu() {\n    if (this.mobileMenu.parentElement) {\n      return;\n    }\n    this.mobileMenuContainer.appendChild(this.mobileMenu);\n    this.mobileMenu.classList.add('nhsuk-header__drop-down', 'nhsuk-header__drop-down--hidden');\n  }\n\n  /**\n   * Enable the mobile menu\n   */;\n  _proto.enableMobileMenu = function enableMobileMenu() {\n    if (this.menuIsEnabled) {\n      return;\n    }\n    this.menuIsEnabled = true;\n    this.mobileMenuToggleButton.classList.add('nhsuk-header__menu-toggle--visible');\n    this.mobileMenuContainer.classList.add('nhsuk-mobile-menu-container--visible');\n\n    // Add click listener to toggle menu\n    this.mobileMenuToggleButton.addEventListener('click', this.handleToggleMobileMenu);\n  }\n\n  /**\n   * Disable the mobile menu\n   */;\n  _proto.disableMobileMenu = function disableMobileMenu() {\n    if (!this.menuIsEnabled) {\n      return;\n    }\n    this.closeMobileMenu();\n    this.menuIsEnabled = false;\n    this.mobileMenuToggleButton.classList.remove('nhsuk-header__menu-toggle--visible');\n    this.mobileMenuContainer.classList.remove('nhsuk-mobile-menu-container--visible');\n\n    // Remove click listener to toggle menu\n    this.mobileMenuToggleButton.removeEventListener('click', this.handleToggleMobileMenu);\n  }\n\n  /**\n   * Close the mobile menu\n   *\n   * Closes the mobile menu and updates accessibility state.\n   *\n   * Removes the margin-bottom from the navigation\n   */;\n  _proto.closeMobileMenu = function closeMobileMenu() {\n    if (!this.menuIsEnabled || !this.menuIsOpen) {\n      return;\n    }\n    this.menuIsOpen = false;\n    this.mobileMenu.classList.add('nhsuk-header__drop-down--hidden');\n    this.navigation.style.marginBottom = 0;\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'false');\n\n    // Remove escape key listener to close menu\n    document.removeEventListener('keydown', this.handleEscapeKey);\n  }\n\n  /**\n   * Escape key handler\n   *\n   * This function is called when the user\n   * presses the escape key to close the mobile menu.\n   *\n   * @param {KeyboardEvent} event - Key press event\n   */;\n  _proto.onEscapeKey = function onEscapeKey(event) {\n    if (event.key === 'Escape') {\n      this.closeMobileMenu(event);\n    }\n  }\n\n  /**\n   * Open the mobile menu\n   *\n   * Opens the mobile menu and updates accessibility state.\n   *\n   * The mobile menu is absolutely positioned, so it adds a margin\n   * to the bottom of the navigation to prevent it from overlapping\n   *\n   * Adds event listeners for the close button,\n   */;\n  _proto.openMobileMenu = function openMobileMenu() {\n    if (!this.menuIsEnabled || this.menuIsOpen) {\n      return;\n    }\n    this.menuIsOpen = true;\n    this.mobileMenu.classList.remove('nhsuk-header__drop-down--hidden');\n    var marginBody = this.mobileMenu.offsetHeight;\n    this.navigation.style.marginBottom = marginBody + \"px\";\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'true');\n\n    // Add escape key listener to close menu\n    document.addEventListener('keydown', this.handleEscapeKey);\n  }\n\n  /**\n   * Handle menu button click\n   *\n   * Toggles the mobile menu between open and closed\n   */;\n  _proto.toggleMobileMenu = function toggleMobileMenu() {\n    if (!this.menuIsEnabled) {\n      return;\n    }\n    if (this.menuIsOpen) {\n      this.closeMobileMenu();\n    } else {\n      this.openMobileMenu();\n    }\n  }\n\n  /**\n   * Update navigation for the available space\n   *\n   * Moves all items that overflow the available space into the mobile menu\n   */;\n  _proto.updateNavigation = function updateNavigation() {\n    var _this4 = this;\n    this.resetNavigation();\n\n    // Check for items that overflow\n    var menuItems = this.breakpoints.filter(function (breakpoint) {\n      return breakpoint.right > _this4.width;\n    });\n\n    // Disable mobile menu if empty\n    if (!menuItems.length) {\n      this.disableMobileMenu();\n      return;\n    }\n    this.setupMobileMenu();\n    this.enableMobileMenu();\n\n    // Subtract space for menu button\n    this.width -= this.mobileMenuContainer.offsetWidth;\n\n    // Move items based on available width\n    this.breakpoints.forEach(function (breakpoint) {\n      if (breakpoint.right > _this4.width) {\n        _this4.mobileMenu.insertAdjacentElement('beforeend', breakpoint.element);\n      }\n    });\n  };\n  return Header;\n}();\nmodule.exports = function () {\n  new Header().init();\n};\n\n/***/ }),\n\n/***/ 551:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar _require = __webpack_require__(848),\n  toggleConditionalInput = _require.toggleConditionalInput;\n\n/**\n * Conditionally show content when a radio button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/radios/conditional.html\n */\n\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Radio input HTMLElements inside a conditional form group\n  var radioInputs = scope.querySelectorAll('.nhsuk-radios--conditional .nhsuk-radios__input');\n\n  /**\n   * Update all conditional reveals to match checked state\n   */\n  var syncAllConditionalReveals = function syncAllConditionalReveals() {\n    radioInputs.forEach(function (input) {\n      return toggleConditionalInput(input, 'nhsuk-radios__conditional--hidden');\n    });\n  };\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', syncAllConditionalReveals);\n  } else {\n    window.addEventListener('DOMContentLoaded', syncAllConditionalReveals);\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  syncAllConditionalReveals();\n\n  // Attach event handler to radioInputs\n  radioInputs.forEach(function (radioButton) {\n    radioButton.addEventListener('change', syncAllConditionalReveals);\n  });\n};\n\n/***/ }),\n\n/***/ 829:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar _require = __webpack_require__(848),\n  setFocus = _require.setFocus;\n\n/*\n * NHS.UK skip link.\n *\n * When using VoiceOver on iOS, focus remains on the skip link anchor\n * when elected so the next focusable element is not at the jumped to area.\n */\n\nmodule.exports = function () {\n  var $skipLink = document.querySelector('.nhsuk-skip-link');\n\n  // Check for skip link\n  if (!$skipLink || !($skipLink instanceof HTMLAnchorElement)) {\n    return;\n  }\n  var linkedElementId = $skipLink.hash.split('#').pop();\n  var $linkedElement = linkedElementId ? document.getElementById(linkedElementId) : null;\n\n  // Check for linked element\n  if (!$linkedElement) {\n    return;\n  }\n\n  /**\n   * Focus the linked element on click\n   *\n   * Adds a helper CSS class to hide native focus styles,\n   * but removes it on blur to restore native focus styles\n   */\n  $skipLink.addEventListener('click', function () {\n    return setFocus($linkedElement, {\n      onBeforeFocus: function onBeforeFocus() {\n        $linkedElement.classList.add('nhsuk-skip-link-focused-element');\n      },\n      onBlur: function onBlur() {\n        $linkedElement.classList.remove('nhsuk-skip-link-focused-element');\n      }\n    });\n  });\n};\n\n/***/ }),\n\n/***/ 303:\n/***/ (function(module) {\n\nvar Tabs = /*#__PURE__*/function () {\n  function Tabs($module, namespace, responsive, historyEnabled) {\n    this.$module = $module;\n    this.namespace = namespace;\n    this.responsive = responsive;\n    this.historyEnabled = historyEnabled;\n    this.$tabs = $module.querySelectorAll(\".\" + this.namespace + \"__tab\");\n    this.keys = {\n      down: 40,\n      left: 37,\n      right: 39,\n      up: 38\n    };\n    this.jsHiddenClass = this.namespace + \"__panel--hidden\";\n    this.showEvent = new CustomEvent('tab.show');\n    this.hideEvent = new CustomEvent('tab.hide');\n  }\n  var _proto = Tabs.prototype;\n  _proto.init = function init() {\n    if (typeof window.matchMedia === 'function' && this.responsive) {\n      this.setupResponsiveChecks();\n    } else {\n      this.setup();\n    }\n  };\n  _proto.setupResponsiveChecks = function setupResponsiveChecks() {\n    // $mq-breakpoints: (\n    // mobile: 320px,\n    // tablet: 641px,\n    // desktop: 769px,\n    // large - desktop: 990px\n    // );\n    this.mql = window.matchMedia('(min-width: 641px)');\n\n    // MediaQueryList.addEventListener isn't supported by Safari < 14 so we need\n    // to be able to fall back to the deprecated MediaQueryList.addListener\n    if ('addEventListener' in this.mql) {\n      this.mql.addEventListener('change', this.checkMode.bind(this));\n    } else {\n      // addListener is a deprecated function, however addEventListener\n      // isn't supported by Safari < 14. We therefore add this in as\n      // a fallback for those browsers\n      this.mql.addListener(this.checkMode.bind(this));\n    }\n    this.checkMode();\n  };\n  _proto.checkMode = function checkMode() {\n    if (this.mql.matches) {\n      this.setup();\n    } else {\n      this.teardown();\n    }\n  };\n  _proto.setup = function setup() {\n    var _this = this;\n    var $module = this.$module;\n    var $tabs = this.$tabs;\n    var $tabList = $module.querySelector(\".\" + this.namespace + \"__list\");\n    var $tabListItems = $module.querySelectorAll(\".\" + this.namespace + \"__list-item\");\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return;\n    }\n    $tabList.setAttribute('role', 'tablist');\n    $tabListItems.forEach(function ($item) {\n      $item.setAttribute('role', 'presentation');\n    });\n    $tabs.forEach(function ($tab) {\n      // Set HTML attributes\n      _this.setAttributes($tab);\n\n      // Save bounded functions to use when removing event listeners during teardown\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabClick = _this.onTabClick.bind(_this);\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabKeydown = _this.onTabKeydown.bind(_this);\n\n      // Handle events\n      $tab.addEventListener('click', $tab.boundTabClick, true);\n      $tab.addEventListener('keydown', $tab.boundTabKeydown, true);\n\n      // Remove old active panels\n      _this.hideTab($tab);\n    });\n\n    // Show either the active tab according to the URL's hash or the first tab\n    var $activeTab = this.getTab(window.location.hash) || this.$tabs[0];\n    this.showTab($activeTab);\n\n    // Handle hashchange events\n    if (this.historyEnabled) {\n      $module.boundOnHashChange = this.onHashChange.bind(this);\n      window.addEventListener('hashchange', $module.boundOnHashChange, true);\n    }\n  };\n  _proto.teardown = function teardown() {\n    var _this2 = this;\n    var $module = this.$module;\n    var $tabs = this.$tabs;\n    var $tabList = $module.querySelector(\".\" + this.namespace + \"__list\");\n    var $tabListItems = $module.querySelectorAll(\".\" + this.namespace + \"__list-item\");\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return;\n    }\n    $tabList.removeAttribute('role');\n    $tabListItems.forEach(function ($item) {\n      $item.removeAttribute('role', 'presentation');\n    });\n    $tabs.forEach(function ($tab) {\n      // Remove events\n      $tab.removeEventListener('click', $tab.boundTabClick, true);\n      $tab.removeEventListener('keydown', $tab.boundTabKeydown, true);\n\n      // Unset HTML attributes\n      _this2.unsetAttributes($tab);\n    });\n    if (this.historyEnabled) {\n      // Remove hashchange event handler\n      window.removeEventListener('hashchange', $module.boundOnHashChange, true);\n    }\n  };\n  _proto.onHashChange = function onHashChange() {\n    var hash = window.location.hash;\n    var $tabWithHash = this.getTab(hash);\n    if (!$tabWithHash) {\n      return;\n    }\n\n    // Prevent changing the hash\n    if (this.changingHash) {\n      this.changingHash = false;\n      return;\n    }\n\n    // Show either the active tab according to the URL's hash or the first tab\n    var $previousTab = this.getCurrentTab();\n    this.hideTab($previousTab);\n    this.showTab($tabWithHash);\n    $tabWithHash.focus();\n  };\n  _proto.hideTab = function hideTab($tab) {\n    this.unhighlightTab($tab);\n    this.hidePanel($tab);\n  };\n  _proto.showTab = function showTab($tab) {\n    this.highlightTab($tab);\n    this.showPanel($tab);\n  };\n  _proto.getTab = function getTab(hash) {\n    return this.$module.querySelector(\".\" + this.namespace + \"__tab[href=\\\"\" + hash + \"\\\"]\");\n  };\n  _proto.setAttributes = function setAttributes($tab) {\n    // set tab attributes\n    var panelId = Tabs.getHref($tab).slice(1);\n    $tab.setAttribute('id', \"tab_\" + panelId);\n    $tab.setAttribute('role', 'tab');\n    $tab.setAttribute('aria-controls', panelId);\n    $tab.setAttribute('aria-selected', 'false');\n    $tab.setAttribute('tabindex', '-1');\n\n    // set panel attributes\n    var $panel = this.getPanel($tab);\n    $panel.setAttribute('role', 'tabpanel');\n    $panel.setAttribute('aria-labelledby', $tab.id);\n    $panel.classList.add(this.jsHiddenClass);\n  };\n  _proto.unsetAttributes = function unsetAttributes($tab) {\n    // unset tab attributes\n    $tab.removeAttribute('id');\n    $tab.removeAttribute('role');\n    $tab.removeAttribute('aria-controls');\n    $tab.removeAttribute('aria-selected');\n    $tab.removeAttribute('tabindex');\n\n    // unset panel attributes\n    var $panel = this.getPanel($tab);\n    $panel.removeAttribute('role');\n    $panel.removeAttribute('aria-labelledby');\n    $panel.removeAttribute('tabindex');\n    $panel.classList.remove(this.jsHiddenClass);\n  };\n  _proto.onTabClick = function onTabClick(e) {\n    if (!e.target.classList.contains(this.namespace + \"__tab\")) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n    e.preventDefault();\n    var $newTab = e.target;\n    var $currentTab = this.getCurrentTab();\n    this.hideTab($currentTab);\n    this.showTab($newTab);\n    this.createHistoryEntry($newTab);\n  };\n  _proto.createHistoryEntry = function createHistoryEntry($tab) {\n    if (this.historyEnabled) {\n      var $panel = this.getPanel($tab);\n\n      // Save and restore the id\n      // so the page doesn't jump when a user clicks a tab (which changes the hash)\n      var id = $panel.id;\n      $panel.id = '';\n      this.changingHash = true;\n      window.location.hash = Tabs.getHref($tab).slice(1);\n      $panel.id = id;\n    }\n  };\n  _proto.onTabKeydown = function onTabKeydown(e) {\n    switch (e.keyCode) {\n      case this.keys.left:\n      case this.keys.up:\n        this.activatePreviousTab();\n        e.preventDefault();\n        break;\n      case this.keys.right:\n      case this.keys.down:\n        this.activateNextTab();\n        e.preventDefault();\n        break;\n      default:\n    }\n  };\n  _proto.activateNextTab = function activateNextTab() {\n    var currentTab = this.getCurrentTab();\n    var nextTabListItem = currentTab.parentNode.nextElementSibling;\n    var nextTab;\n    if (nextTabListItem) {\n      nextTab = nextTabListItem.querySelector(\".\" + this.namespace + \"__tab\");\n    }\n    if (nextTab) {\n      this.hideTab(currentTab);\n      this.showTab(nextTab);\n      nextTab.focus();\n      this.createHistoryEntry(nextTab);\n    }\n  };\n  _proto.activatePreviousTab = function activatePreviousTab() {\n    var currentTab = this.getCurrentTab();\n    var previousTabListItem = currentTab.parentNode.previousElementSibling;\n    var previousTab;\n    if (previousTabListItem) {\n      previousTab = previousTabListItem.querySelector(\".\" + this.namespace + \"__tab\");\n    }\n    if (previousTab) {\n      this.hideTab(currentTab);\n      this.showTab(previousTab);\n      previousTab.focus();\n      this.createHistoryEntry(previousTab);\n    }\n  };\n  _proto.getPanel = function getPanel($tab) {\n    var $panel = this.$module.querySelector(Tabs.getHref($tab));\n    return $panel;\n  };\n  _proto.showPanel = function showPanel($tab) {\n    var $panel = this.getPanel($tab);\n    $panel.classList.remove(this.jsHiddenClass);\n    $panel.dispatchEvent(this.showEvent);\n  };\n  _proto.hidePanel = function hidePanel(tab) {\n    var $panel = this.getPanel(tab);\n    $panel.classList.add(this.jsHiddenClass);\n    $panel.dispatchEvent(this.hideEvent);\n  };\n  _proto.unhighlightTab = function unhighlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'false');\n    $tab.parentNode.classList.remove(this.namespace + \"__list-item--selected\");\n    $tab.setAttribute('tabindex', '-1');\n  };\n  _proto.highlightTab = function highlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'true');\n    $tab.parentNode.classList.add(this.namespace + \"__list-item--selected\");\n    $tab.setAttribute('tabindex', '0');\n  };\n  _proto.getCurrentTab = function getCurrentTab() {\n    return this.$module.querySelector(\".\" + this.namespace + \"__list-item--selected .\" + this.namespace + \"__tab\");\n  }\n\n  // this is because IE doesn't always return the actual value but a relative full path\n  // should be a utility function most prob\n  // http://labs.thesedays.com/blog/2010/01/08/getting-the-href-value-with-jquery-in-ie/\n  ;\n  Tabs.getHref = function getHref($tab) {\n    var href = $tab.getAttribute('href');\n    var hash = href.slice(href.indexOf('#'), href.length);\n    return hash;\n  };\n  return Tabs;\n}();\n/**\n * Main function to invoke tabs. Can be called as follows to alter various features\n *\n * Tabs({historyEnabled: false});\n * Tabs({responsive: false});\n * Tabs({namespace: 'my-custom-namespace'});  // Alters classes allowing alternative css\n */\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$namespace = _ref.namespace,\n    namespace = _ref$namespace === void 0 ? 'nhsuk-tabs' : _ref$namespace,\n    _ref$responsive = _ref.responsive,\n    responsive = _ref$responsive === void 0 ? true : _ref$responsive,\n    _ref$historyEnabled = _ref.historyEnabled,\n    historyEnabled = _ref$historyEnabled === void 0 ? true : _ref$historyEnabled,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  var tabs = scope.querySelectorAll(\"[data-module=\\\"\" + namespace + \"\\\"]\");\n  tabs.forEach(function (el) {\n    new Tabs(el, namespace, responsive, historyEnabled).init();\n  });\n};\n\n/***/ }),\n\n/***/ 930:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n/* eslint-disable import/prefer-default-export */\n\n// Components\nvar initButton = __webpack_require__(807);\nvar initCharacterCount = __webpack_require__(997);\nvar initCheckboxes = __webpack_require__(305);\nvar initDetails = __webpack_require__(277);\nvar initErrorSummary = __webpack_require__(673);\nvar initHeader = __webpack_require__(649);\nvar initRadios = __webpack_require__(551);\nvar initSkipLink = __webpack_require__(829);\nvar initTabs = __webpack_require__(303);\n__webpack_require__(621);\n\n/**\n * Use this function to initialise nhsuk-frontend components within a\n * given scope. This function is called by default with the document\n * element, but you can call it again later with a new DOM element\n * containing nhsuk-frontend components which you wish to initialise.\n *\n * @param {HTMLElement} scope\n */\nfunction initAll(scope) {\n  initButton({\n    scope: scope\n  });\n  initCharacterCount({\n    scope: scope\n  });\n  initCheckboxes({\n    scope: scope\n  });\n  initDetails({\n    scope: scope\n  });\n  initErrorSummary({\n    scope: scope\n  });\n  initRadios({\n    scope: scope\n  });\n  initTabs({\n    scope: scope\n  });\n}\n\n// Initialize components\ndocument.addEventListener('DOMContentLoaded', function () {\n  initHeader();\n  initSkipLink();\n  initAll(document);\n});\nmodule.exports = {\n  initAll: initAll\n};\n\n/***/ }),\n\n/***/ 621:\n/***/ (function() {\n\n/**\n * IE polyfill for NodeList.forEach()\n */\nif (!NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach;\n}\n\n/**\n * IE polyfill for Array.includes()\n */\nif (!Array.prototype.includes) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Array.prototype, 'includes', {\n    enumerable: false,\n    value: function value(obj) {\n      return this.filter(function (el) {\n        return el === obj;\n      }).length > 0;\n    }\n  });\n}\n\n/**\n * IE polyfill for Element.closest()\n */\nif (!Element.prototype.matches) {\n  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n}\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this;\n    do {\n      if (Element.prototype.matches.call(el, s)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n    return null;\n  };\n}\n\n/**\n * IE polyfill for CustomEvent\n */\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function (event, params) {\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: null\n    };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  };\n}\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(930);\n/******/ \t\n/******/ })()\n;\n","/**\n * Toggle a boolean attribute on a HTML element\n * @param {HTMLElement} element\n * @param {string} attr\n */\nconst toggleAttribute = (element, attr) => {\n  // Return without error if element or attr are missing\n  if (!element || !attr) return\n  // Toggle attribute value. Treat no existing attr same as when set to false\n  const value = element.getAttribute(attr) === 'true' ? 'false' : 'true'\n  element.setAttribute(attr, value)\n}\n\n/**\n * Toggle a toggle a class on conditional content for an input based on checked state\n * @param {HTMLElement} input input element\n * @param {string} className class to toggle\n */\nconst toggleConditionalInput = (input, className) => {\n  // Return without error if input or class are missing\n  if (!input || !className) return\n  // If the input has conditional content it had a data-aria-controls attribute\n  const conditionalId = input.getAttribute('aria-controls')\n  if (conditionalId) {\n    // Get the conditional element from the input data-aria-controls attribute\n    const conditionalElement = document.getElementById(conditionalId)\n    if (conditionalElement) {\n      if (input.checked) {\n        conditionalElement.classList.remove(className)\n        input.setAttribute('aria-expanded', true)\n      } else {\n        conditionalElement.classList.add(className)\n        input.setAttribute('aria-expanded', false)\n      }\n    }\n  }\n}\n\n/**\n * Move focus to element\n *\n * Sets tabindex to -1 to make the element programmatically focusable,\n * but removes it on blur as the element doesn't need to be focused again.\n *\n * Original code taken from GDS (Government Digital Service)\n * {@link https://github.com/alphagov/govuk-frontend}\n *\n * @template {HTMLElement} FocusElement\n * @param {FocusElement} $element - HTML element\n * @param {object} [options] - Handler options\n * @param {function(this: FocusElement): void} [options.onBeforeFocus] - Callback before focus\n * @param {function(this: FocusElement): void} [options.onBlur] - Callback on blur\n */\nfunction setFocus($element, options = {}) {\n  const isFocusable = $element.getAttribute('tabindex')\n\n  if (!isFocusable) {\n    $element.setAttribute('tabindex', '-1')\n  }\n\n  /**\n   * Handle element focus\n   */\n  function onFocus() {\n    $element.removeEventListener('focus', onFocus)\n    $element.addEventListener('blur', onBlur)\n  }\n\n  /**\n   * Handle element blur\n   */\n  function onBlur() {\n    $element.removeEventListener('blur', onBlur)\n\n    if (options.onBlur) {\n      options.onBlur.call($element)\n    }\n\n    if (!isFocusable) {\n      $element.removeAttribute('tabindex')\n    }\n  }\n\n  // Add listener to reset element on blur, after focus\n  $element.addEventListener('focus', onFocus)\n\n  // Focus element\n  if (options.onBeforeFocus) {\n    options.onBeforeFocus.call($element)\n  }\n\n  $element.focus()\n}\n\nmodule.exports = {\n  toggleAttribute,\n  toggleConditionalInput,\n  setFocus\n}\n","class Button {\n  constructor($module) {\n    this.KEY_SPACE = 32\n    this.DEBOUNCE_TIMEOUT_IN_SECONDS = 1\n\n    this.$module = $module\n    this.debounceFormSubmitTimer = null\n  }\n\n  /**\n   * JavaScript 'shim' to trigger the click event of element(s) when the space key is pressed.\n   *\n   * Created since some Assistive Technologies (for example some Screenreaders)\n   * will tell a user to press space on a 'button', so this functionality needs to be shimmed\n   * See https://github.com/alphagov/govuk_elements/pull/272#issuecomment-233028270\n   *\n   * @param {object} event event\n   */\n  handleKeyDown(event) {\n    // get the target element\n\n    const { target } = event\n    // if the element has a role='button' and the pressed key is a space, we'll simulate a click\n    if (\n      target.getAttribute('role') === 'button' &&\n      event.keyCode === this.KEY_SPACE\n    ) {\n      event.preventDefault()\n      // trigger the target's click event\n      target.click()\n    }\n  }\n\n  /**\n   * If the click quickly succeeds a previous click then nothing will happen.\n   * This stops people accidentally causing multiple form submissions by\n   * double clicking buttons.\n   */\n  debounce(event) {\n    const { target } = event\n    // Check the button that is clicked on has the preventDoubleClick feature enabled\n    if (target.getAttribute('data-prevent-double-click') !== 'true') {\n      return\n    }\n\n    // If the timer is still running then we want to prevent the click from submitting the form\n    if (this.debounceFormSubmitTimer) {\n      event.preventDefault()\n      return false // eslint-disable-line consistent-return\n    }\n\n    this.debounceFormSubmitTimer = setTimeout(() => {\n      this.debounceFormSubmitTimer = null\n    }, this.DEBOUNCE_TIMEOUT_IN_SECONDS * 1000)\n  }\n\n  /**\n   * Initialise an event listener for keydown at document level\n   * this will help listening for later inserted elements with a role=\"button\"\n   */\n  init() {\n    this.$module.addEventListener('keydown', this.handleKeyDown.bind(this))\n    this.$module.addEventListener('click', this.debounce.bind(this))\n  }\n}\n\nmodule.exports = ({ scope = document } = {}) => {\n  const buttons = scope.querySelectorAll('[data-module=\"nhsuk-button\"]')\n  buttons.forEach((el) => {\n    new Button(el).init()\n  })\n}\n","class CharacterCount {\n  constructor($module) {\n    this.$module = $module\n    this.$textarea = $module.querySelector('.nhsuk-js-character-count')\n    this.$visibleCountMessage = null\n    this.$screenReaderCountMessage = null\n    this.lastInputTimestamp = null\n  }\n\n  // Initialize component\n  init() {\n    // Check that required elements are present\n    if (!this.$textarea) {\n      return\n    }\n\n    // Check for module\n    const { $module } = this\n    const { $textarea } = this\n    const $fallbackLimitMessage = document.getElementById(\n      `${$textarea.id}-info`\n    )\n\n    // Move the fallback count message to be immediately after the textarea\n    // Kept for backwards compatibility\n    $textarea.insertAdjacentElement('afterend', $fallbackLimitMessage)\n\n    // Create the *screen reader* specific live-updating counter\n    // This doesn't need any styling classes, as it is never visible\n    const $screenReaderCountMessage = document.createElement('div')\n    $screenReaderCountMessage.className =\n      'nhsuk-character-count__sr-status nhsuk-u-visually-hidden'\n    $screenReaderCountMessage.setAttribute('aria-live', 'polite')\n    this.$screenReaderCountMessage = $screenReaderCountMessage\n    $fallbackLimitMessage.insertAdjacentElement(\n      'afterend',\n      $screenReaderCountMessage\n    )\n\n    // Create our live-updating counter element, copying the classes from the\n    // fallback element for backwards compatibility as these may have been configured\n    const $visibleCountMessage = document.createElement('div')\n    $visibleCountMessage.className = $fallbackLimitMessage.className\n    $visibleCountMessage.classList.add('nhsuk-character-count__status')\n    $visibleCountMessage.setAttribute('aria-hidden', 'true')\n    this.$visibleCountMessage = $visibleCountMessage\n    $fallbackLimitMessage.insertAdjacentElement(\n      'afterend',\n      $visibleCountMessage\n    )\n\n    // Hide the fallback limit message\n    $fallbackLimitMessage.classList.add('nhsuk-u-visually-hidden')\n\n    // Read options set using dataset ('data-' values)\n    this.options = CharacterCount.getDataset($module)\n\n    // Determine the limit attribute (characters or words)\n    let countAttribute = this.defaults.characterCountAttribute\n    if (this.options.maxwords) {\n      countAttribute = this.defaults.wordCountAttribute\n    }\n\n    // Save the element limit\n    this.maxLength = $module.getAttribute(countAttribute)\n\n    // Check for limit\n    if (!this.maxLength) {\n      return\n    }\n\n    // Remove hard limit if set\n    $textarea.removeAttribute('maxlength')\n\n    this.bindChangeEvents()\n\n    // When the page is restored after navigating 'back' in some browsers the\n    // state of the character count is not restored until *after* the DOMContentLoaded\n    // event is fired, so we need to manually update it after the pageshow event\n    // in browsers that support it.\n    if ('onpageshow' in window) {\n      window.addEventListener('pageshow', this.updateCountMessage.bind(this))\n    } else {\n      window.addEventListener(\n        'DOMContentLoaded',\n        this.updateCountMessage.bind(this)\n      )\n    }\n    this.updateCountMessage()\n  }\n\n  // Read data attributes\n  static getDataset(element) {\n    const dataset = {}\n    const { attributes } = element\n    if (attributes) {\n      for (let i = 0; i < attributes.length; i++) {\n        const attribute = attributes[i]\n        const match = attribute.name.match(/^data-(.+)/)\n        if (match) {\n          dataset[match[1]] = attribute.value\n        }\n      }\n    }\n    return dataset\n  }\n\n  // Counts characters or words in text\n  count(text) {\n    let length\n    if (this.options.maxwords) {\n      const tokens = text.match(/\\S+/g) || [] // Matches consecutive non-whitespace chars\n      length = tokens.length // eslint-disable-line prefer-destructuring\n    } else {\n      length = text.length // eslint-disable-line prefer-destructuring\n    }\n    return length\n  }\n\n  // Bind input propertychange to the elements and update based on the change\n  bindChangeEvents() {\n    const { $textarea } = this\n    $textarea.addEventListener('keyup', this.handleKeyUp.bind(this))\n\n    // Bind focus/blur events to start/stop polling\n    $textarea.addEventListener('focus', this.handleFocus.bind(this))\n    $textarea.addEventListener('blur', this.handleBlur.bind(this))\n  }\n\n  // Speech recognition software such as Dragon NaturallySpeaking will modify the\n  // fields by directly changing its `value`. These changes don't trigger events\n  // in JavaScript, so we need to poll to handle when and if they occur.\n  checkIfValueChanged() {\n    if (!this.$textarea.oldValue) {\n      this.$textarea.oldValue = ''\n    }\n    if (this.$textarea.value !== this.$textarea.oldValue) {\n      this.$textarea.oldValue = this.$textarea.value\n      this.updateCountMessage()\n    }\n  }\n\n  // Helper function to update both the visible and screen reader-specific\n  // counters simultaneously (e.g. on init)\n  updateCountMessage() {\n    this.updateVisibleCountMessage()\n    this.updateScreenReaderCountMessage()\n  }\n\n  // Update visible counter\n  updateVisibleCountMessage() {\n    const { $textarea } = this\n    const { $visibleCountMessage } = this\n    const remainingNumber = this.maxLength - this.count($textarea.value)\n\n    // If input is over the threshold, remove the disabled class which renders the\n    // counter invisible.\n    if (this.isOverThreshold()) {\n      $visibleCountMessage.classList.remove(\n        'nhsuk-character-count__message--disabled'\n      )\n    } else {\n      $visibleCountMessage.classList.add(\n        'nhsuk-character-count__message--disabled'\n      )\n    }\n\n    // Update styles\n    if (remainingNumber < 0) {\n      $textarea.classList.add('nhsuk-textarea--error')\n      $visibleCountMessage.classList.remove('nhsuk-hint')\n      $visibleCountMessage.classList.add('nhsuk-error-message')\n    } else {\n      $textarea.classList.remove('nhsuk-textarea--error')\n      $visibleCountMessage.classList.remove('nhsuk-error-message')\n      $visibleCountMessage.classList.add('nhsuk-hint')\n    }\n\n    // Update message\n    $visibleCountMessage.innerHTML = this.formattedUpdateMessage()\n  }\n\n  // Update screen reader-specific counter\n  updateScreenReaderCountMessage() {\n    const { $screenReaderCountMessage } = this\n\n    // If over the threshold, remove the aria-hidden attribute, allowing screen\n    // readers to announce the content of the element.\n    if (this.isOverThreshold()) {\n      $screenReaderCountMessage.removeAttribute('aria-hidden')\n    } else {\n      $screenReaderCountMessage.setAttribute('aria-hidden', true)\n    }\n\n    // Update message\n    $screenReaderCountMessage.innerHTML = this.formattedUpdateMessage()\n  }\n\n  // Format update message\n  formattedUpdateMessage() {\n    const { $textarea } = this\n    const { options } = this\n    const remainingNumber = this.maxLength - this.count($textarea.value)\n\n    let charVerb = 'remaining'\n    let charNoun = 'character'\n    let displayNumber = remainingNumber\n    if (options.maxwords) {\n      charNoun = 'word'\n    }\n    charNoun += remainingNumber === -1 || remainingNumber === 1 ? '' : 's'\n\n    charVerb = remainingNumber < 0 ? 'too many' : 'remaining'\n    displayNumber = Math.abs(remainingNumber)\n\n    return `You have ${displayNumber} ${charNoun} ${charVerb}`\n  }\n\n  // Checks whether the value is over the configured threshold for the input.\n  // If there is no configured threshold, it is set to 0 and this function will\n  // always return true.\n  isOverThreshold() {\n    const { $textarea } = this\n    const { options } = this\n\n    // Determine the remaining number of characters/words\n    const currentLength = this.count($textarea.value)\n    const { maxLength } = this\n\n    // Set threshold if presented in options\n    const thresholdPercent = options.threshold ? options.threshold : 0\n    const thresholdValue = (maxLength * thresholdPercent) / 100\n\n    return thresholdValue <= currentLength\n  }\n\n  // Update the visible character counter and keep track of when the last update\n  // happened for each keypress\n  handleKeyUp() {\n    this.updateVisibleCountMessage()\n    this.lastInputTimestamp = Date.now()\n  }\n\n  handleFocus() {\n    // If the field is focused, and a keyup event hasn't been detected for at\n    // least 1000 ms (1 second), then run the manual change check.\n    // This is so that the update triggered by the manual comparison doesn't\n    // conflict with debounced KeyboardEvent updates.\n    this.valueChecker = setInterval(() => {\n      if (\n        !this.lastInputTimestamp ||\n        Date.now() - 500 >= this.lastInputTimestamp\n      ) {\n        this.checkIfValueChanged()\n      }\n    }, 1000)\n  }\n\n  handleBlur() {\n    // Cancel value checking on blur\n    clearInterval(this.valueChecker)\n  }\n}\n\nCharacterCount.prototype.defaults = {\n  characterCountAttribute: 'data-maxlength',\n  wordCountAttribute: 'data-maxwords'\n}\n\nmodule.exports = ({ scope = document } = {}) => {\n  const characterCounts = scope.querySelectorAll(\n    '[data-module=\"nhsuk-character-count\"]'\n  )\n  characterCounts.forEach((el) => {\n    new CharacterCount(el).init()\n  })\n}\n","const { toggleConditionalInput } = require('../../common')\n\n/**\n * Conditionally show content when a checkbox button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/checkboxes/conditional.html\n */\nconst syncAllConditionalReveals = function syncAllConditionalReveals(input) {\n  const allInputsInForm = input.form.querySelectorAll('input[type=\"checkbox\"]')\n  allInputsInForm.forEach((item) =>\n    toggleConditionalInput(item, 'nhsuk-checkboxes__conditional--hidden')\n  )\n}\n\n/**\n * Uncheck other checkboxes\n *\n * Find any other checkbox inputs with the checkbox group value, and uncheck them.\n * This is useful for when a “None of these\" checkbox is checked.\n */\nconst unCheckAllInputsExcept = function unCheckAllInputsExcept(input) {\n  const allInputsInSameExclusiveGroup = input.form.querySelectorAll(\n    `input[type=\"checkbox\"][data-checkbox-exclusive-group=\"${input.getAttribute('data-checkbox-exclusive-group')}\"]`\n  )\n\n  allInputsInSameExclusiveGroup.forEach((inputWithSameName) => {\n    const hasSameFormOwner = input.form === inputWithSameName.form\n    if (hasSameFormOwner && inputWithSameName !== input) {\n      inputWithSameName.checked = false // eslint-disable-line no-param-reassign\n    }\n  })\n\n  syncAllConditionalReveals(input)\n}\n\n/**\n * Uncheck exclusive inputs\n *\n * Find any checkbox inputs with the same checkbox group value and the 'exclusive' behaviour,\n * and uncheck them. This helps prevent someone checking both a regular checkbox and a\n * \"None of these\" checkbox in the same fieldset.\n */\nconst unCheckExclusiveInputs = function unCheckExclusiveInputs(input) {\n  const allExclusiveInputsInSameExclusiveGroup = input.form.querySelectorAll(\n    `input[type=\"checkbox\"][data-checkbox-exclusive][data-checkbox-exclusive-group=\"${input.getAttribute(\n      'data-checkbox-exclusive-group'\n    )}\"]`\n  )\n\n  allExclusiveInputsInSameExclusiveGroup.forEach((exclusiveInput) => {\n    const hasSameFormOwner = input.form === exclusiveInput.form\n    if (hasSameFormOwner) {\n      exclusiveInput.checked = false // eslint-disable-line no-param-reassign\n    }\n  })\n\n  syncAllConditionalReveals(input)\n}\n\nmodule.exports = ({ scope = document } = {}) => {\n  // Checkbox input DOMElements inside a conditional form group\n  const checkboxInputs = scope.querySelectorAll(\n    '.nhsuk-checkboxes .nhsuk-checkboxes__input'\n  )\n\n  /**\n   * Toggle classes and attributes\n   * @param {Object} event click event object\n   */\n  const handleClick = (event) => {\n    // Toggle conditional content based on checked state\n    toggleConditionalInput(\n      event.target,\n      'nhsuk-checkboxes__conditional--hidden'\n    )\n\n    if (!event.target.checked) {\n      return\n    }\n\n    // Handle 'exclusive' checkbox behaviour (ie \"None of these\")\n    if (event.target.hasAttribute('data-checkbox-exclusive')) {\n      unCheckAllInputsExcept(event.target)\n    } else {\n      unCheckExclusiveInputs(event.target)\n    }\n  }\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', () =>\n      checkboxInputs.forEach((input) => syncAllConditionalReveals(input))\n    )\n  } else {\n    window.addEventListener('DOMContentLoaded', () =>\n      checkboxInputs.forEach((input) => syncAllConditionalReveals(input))\n    )\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  checkboxInputs.forEach((input) => syncAllConditionalReveals(input))\n\n  // Attach handleClick as click to checkboxInputs\n  checkboxInputs.forEach((checkboxButton) => {\n    checkboxButton.addEventListener('change', handleClick)\n  })\n}\n","const { toggleAttribute } = require('../../common')\n\n/**\n * Ensure details component is cross browser and accessible\n * Test at http://localhost:3000/nhsuk-frontend/components/details/index.html\n */\n\nmodule.exports = ({ scope = document } = {}) => {\n  // Does the browser support details component\n  const nativeSupport =\n    typeof document.createElement('details').open === 'boolean'\n  if (nativeSupport) {\n    return\n  }\n\n  // Nodelist of all details elements\n  const allDetails = scope.querySelectorAll('details')\n\n  /**\n   * Adds all necessary functionality to a details element\n   * @param {HTMLElement} element details element to initialise\n   * @param {number} index number to be appended to dynamic IDs\n   */\n  const initDetails = (element, index) => {\n    // Set details element as polyfilled to prevent duplicate events being added\n    element.setAttribute('nhsuk-polyfilled', 'true')\n\n    // Give details element an ID if it doesn't already have one\n    if (!element.id) element.setAttribute('id', `nhsuk-details${index}`)\n\n    // Set content element and give it an ID if it doesn't already have one\n    const content = scope.querySelector(`#${element.id} .nhsuk-details__text`)\n    if (!content.id) content.setAttribute('id', `nhsuk-details__text${index}`)\n\n    // Set summary element\n    const summary = scope.querySelector(\n      `#${element.id} .nhsuk-details__summary`\n    )\n\n    // Set initial summary aria attributes\n    summary.setAttribute('role', 'button')\n    summary.setAttribute('aria-controls', content.id)\n    summary.setAttribute('tabIndex', '0')\n    const openAttr = element.getAttribute('open') !== null\n    if (openAttr === true) {\n      summary.setAttribute('aria-expanded', 'true')\n      content.setAttribute('aria-hidden', 'false')\n    } else {\n      summary.setAttribute('aria-expanded', 'false')\n      content.setAttribute('aria-hidden', 'true')\n      content.style.display = 'none'\n    }\n\n    const toggleDetails = () => {\n      toggleAttribute(summary, 'aria-expanded')\n      toggleAttribute(content, 'aria-hidden')\n\n      content.style.display =\n        content.getAttribute('aria-hidden') === 'true' ? 'none' : ''\n      if (element.hasAttribute('open')) {\n        element.removeAttribute('open')\n      } else {\n        element.setAttribute('open', 'open')\n      }\n    }\n\n    // Toggle details onclick\n    summary.addEventListener('click', toggleDetails)\n\n    // Call toggle details on enter and space key events\n    summary.addEventListener('keydown', (event) => {\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault()\n        summary.click()\n      }\n    })\n  }\n\n  // Initialise details for any new details element\n  if (allDetails.length) {\n    allDetails.forEach((element, index) => {\n      if (!element.hasAttribute('nhsuk-polyfilled')) initDetails(element, index)\n    })\n  }\n}\n","/**\n * Adapted from https://github.com/alphagov/govuk-frontend/blob/master/src/govuk/components/error-summary/error-summary.js\n */\n\n/**\n * Get associated legend or label\n *\n * Returns the first element that exists from this list:\n *\n * - The `<legend>` associated with the closest `<fieldset>` ancestor, as long\n *   as the top of it is no more than half a viewport height away from the\n *   bottom of the input\n * - The first `<label>` that is associated with the input using for='inputId'\n * - The closest parent `<label>`\n */\nfunction getAssociatedLegendOrLabel(input) {\n  const fieldset = input.closest('fieldset')\n\n  if (fieldset) {\n    const legends = fieldset.getElementsByTagName('legend')\n\n    if (legends.length) {\n      const candidateLegend = legends[0] // eslint-disable-line prefer-destructuring\n\n      // If the input type is radio or checkbox, always use the legend if there\n      // is one.\n      if (input.type === 'checkbox' || input.type === 'radio') {\n        return candidateLegend\n      }\n\n      // For other input types, only scroll to the fieldset’s legend (instead of\n      // the label associated with the input) if the input would end up in the\n      // top half of the screen.\n      //\n      // This should avoid situations where the input either ends up off the\n      // screen, or obscured by a software keyboard.\n      const legendTop = candidateLegend.getBoundingClientRect().top\n      const inputRect = input.getBoundingClientRect()\n\n      // If the browser doesn't support Element.getBoundingClientRect().height\n      // or window.innerHeight (like IE8), bail and just link to the label.\n      if (inputRect.height && window.innerHeight) {\n        const inputBottom = inputRect.top + inputRect.height\n\n        if (inputBottom - legendTop < window.innerHeight / 2) {\n          return candidateLegend\n        }\n      }\n    }\n  }\n\n  return (\n    document.querySelector(`label[for='${input.getAttribute('id')}']`) ||\n    input.closest('label')\n  )\n}\n\n/**\n * Focus the target element\n *\n * By default, the browser will scroll the target into view. Because our labels\n * or legends appear above the input, this means the user will be presented with\n * an input without any context, as the label or legend will be off the top of\n * the screen.\n *\n * Manually handling the click event, scrolling the question into view and then\n * focussing the element solves this.\n *\n * This also results in the label and/or legend being announced correctly in\n * NVDA - without this only the field type is announced\n * (e.g. 'Edit, has autocomplete').\n */\nfunction focusTarget(target) {\n  // If the element that was clicked was not a link, return early\n  if (target.tagName !== 'A' || target.href === false) {\n    return false\n  }\n\n  const input = document.querySelector(target.hash)\n  if (!input) {\n    return false\n  }\n\n  const legendOrLabel = getAssociatedLegendOrLabel(input)\n  if (!legendOrLabel) {\n    return false\n  }\n\n  // Scroll the legend or label into view *before* calling focus on the input to\n  // avoid extra scrolling in browsers that don't support `preventScroll` (which\n  // at time of writing is most of them...)\n  legendOrLabel.scrollIntoView()\n  input.focus({ preventScroll: true })\n\n  return true\n}\n\n/**\n * Handle click events on the error summary\n */\nfunction handleClick(event) {\n  if (focusTarget(event.target)) {\n    event.preventDefault()\n  }\n}\n\nmodule.exports = ({ focusOnPageLoad = true, scope = document } = {}) => {\n  // Error summary component\n  const errorSummary = scope.querySelector('.nhsuk-error-summary')\n\n  if (errorSummary) {\n    // Focus error summary component if it exists\n\n    if (focusOnPageLoad) {\n      errorSummary.focus()\n    }\n    errorSummary.addEventListener('click', handleClick)\n  }\n}\n","/**\n * Header component\n *\n */\n\nclass Header {\n  constructor() {\n    this.menuIsEnabled = false\n    this.menuIsOpen = false\n\n    this.navigation = document.querySelector('.nhsuk-navigation')\n    this.navigationList = null\n    this.navigationItems = null\n\n    if (!this.navigation) {\n      return\n    }\n\n    this.navigationList = this.navigation.querySelector(\n      '.nhsuk-header__navigation-list'\n    )\n    this.navigationItems = this.navigation.querySelectorAll(\n      '.nhsuk-header__navigation-item'\n    )\n\n    this.mobileMenu = document.createElement('ul')\n    this.mobileMenuToggleButton = document.querySelector(\n      '.nhsuk-header__menu-toggle'\n    )\n    this.mobileMenuContainer = document.querySelector(\n      '.nhsuk-mobile-menu-container'\n    )\n\n    this.width = 0\n  }\n\n  init() {\n    if (\n      !this.navigation ||\n      !this.navigationList ||\n      !this.navigationItems ||\n      !this.navigationItems.length ||\n      !this.mobileMenuToggleButton ||\n      !this.mobileMenuContainer\n    ) {\n      return\n    }\n\n    this.handleEscapeKey = this.onEscapeKey.bind(this)\n    this.handleUpdateNavigation = this.debounce(this.updateNavigation)\n    this.handleToggleMobileMenu = this.toggleMobileMenu.bind(this)\n\n    this.setupNavigation()\n    this.updateNavigation()\n  }\n\n  debounce(func, timeout = 100) {\n    let timer\n    return (...args) => {\n      clearTimeout(timer)\n      timer = setTimeout(() => {\n        func.apply(this, args)\n      }, timeout)\n    }\n  }\n\n  /**\n   * Reset navigation\n   *\n   * Calculate available space by summing the width of each navigation item\n   */\n  resetNavigation() {\n    let right = 0\n\n    // Reset and calculate widths on every resize\n    this.breakpoints.forEach((breakpoint) => {\n      this.navigationList.insertBefore(\n        breakpoint.element,\n        this.mobileMenuContainer\n      )\n\n      // Calculate widths\n      right += breakpoint.element.offsetWidth\n      breakpoint.right = right\n    })\n\n    // Reset space for menu button\n    this.width = this.navigationList.offsetWidth\n  }\n\n  /**\n   * Add the breakpoints with default positions\n   */\n  setupNavigation() {\n    this.breakpoints = []\n\n    this.navigationItems.forEach((element) => {\n      this.breakpoints.push({ element, right: 0 })\n    })\n\n    // Add resize listener for next update\n    window.addEventListener('resize', this.handleUpdateNavigation)\n  }\n\n  /**\n   * Add the mobile menu to the DOM\n   */\n  setupMobileMenu() {\n    if (this.mobileMenu.parentElement) {\n      return\n    }\n\n    this.mobileMenuContainer.appendChild(this.mobileMenu)\n    this.mobileMenu.classList.add(\n      'nhsuk-header__drop-down',\n      'nhsuk-header__drop-down--hidden'\n    )\n  }\n\n  /**\n   * Enable the mobile menu\n   */\n  enableMobileMenu() {\n    if (this.menuIsEnabled) {\n      return\n    }\n\n    this.menuIsEnabled = true\n\n    this.mobileMenuToggleButton.classList.add(\n      'nhsuk-header__menu-toggle--visible'\n    )\n\n    this.mobileMenuContainer.classList.add(\n      'nhsuk-mobile-menu-container--visible'\n    )\n\n    // Add click listener to toggle menu\n    this.mobileMenuToggleButton.addEventListener(\n      'click',\n      this.handleToggleMobileMenu\n    )\n  }\n\n  /**\n   * Disable the mobile menu\n   */\n  disableMobileMenu() {\n    if (!this.menuIsEnabled) {\n      return\n    }\n\n    this.closeMobileMenu()\n    this.menuIsEnabled = false\n\n    this.mobileMenuToggleButton.classList.remove(\n      'nhsuk-header__menu-toggle--visible'\n    )\n\n    this.mobileMenuContainer.classList.remove(\n      'nhsuk-mobile-menu-container--visible'\n    )\n\n    // Remove click listener to toggle menu\n    this.mobileMenuToggleButton.removeEventListener(\n      'click',\n      this.handleToggleMobileMenu\n    )\n  }\n\n  /**\n   * Close the mobile menu\n   *\n   * Closes the mobile menu and updates accessibility state.\n   *\n   * Removes the margin-bottom from the navigation\n   */\n  closeMobileMenu() {\n    if (!this.menuIsEnabled || !this.menuIsOpen) {\n      return\n    }\n\n    this.menuIsOpen = false\n    this.mobileMenu.classList.add('nhsuk-header__drop-down--hidden')\n    this.navigation.style.marginBottom = 0\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'false')\n\n    // Remove escape key listener to close menu\n    document.removeEventListener('keydown', this.handleEscapeKey)\n  }\n\n  /**\n   * Escape key handler\n   *\n   * This function is called when the user\n   * presses the escape key to close the mobile menu.\n   *\n   * @param {KeyboardEvent} event - Key press event\n   */\n  onEscapeKey(event) {\n    if (event.key === 'Escape') {\n      this.closeMobileMenu(event)\n    }\n  }\n\n  /**\n   * Open the mobile menu\n   *\n   * Opens the mobile menu and updates accessibility state.\n   *\n   * The mobile menu is absolutely positioned, so it adds a margin\n   * to the bottom of the navigation to prevent it from overlapping\n   *\n   * Adds event listeners for the close button,\n   */\n  openMobileMenu() {\n    if (!this.menuIsEnabled || this.menuIsOpen) {\n      return\n    }\n\n    this.menuIsOpen = true\n    this.mobileMenu.classList.remove('nhsuk-header__drop-down--hidden')\n    const marginBody = this.mobileMenu.offsetHeight\n    this.navigation.style.marginBottom = `${marginBody}px`\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'true')\n\n    // Add escape key listener to close menu\n    document.addEventListener('keydown', this.handleEscapeKey)\n  }\n\n  /**\n   * Handle menu button click\n   *\n   * Toggles the mobile menu between open and closed\n   */\n  toggleMobileMenu() {\n    if (!this.menuIsEnabled) {\n      return\n    }\n\n    if (this.menuIsOpen) {\n      this.closeMobileMenu()\n    } else {\n      this.openMobileMenu()\n    }\n  }\n\n  /**\n   * Update navigation for the available space\n   *\n   * Moves all items that overflow the available space into the mobile menu\n   */\n  updateNavigation() {\n    this.resetNavigation()\n\n    // Check for items that overflow\n    let menuItems = this.breakpoints.filter((breakpoint) => {\n      return breakpoint.right > this.width\n    })\n\n    // Disable mobile menu if empty\n    if (!menuItems.length) {\n      this.disableMobileMenu()\n      return\n    }\n\n    this.setupMobileMenu()\n    this.enableMobileMenu()\n\n    // Subtract space for menu button\n    this.width -= this.mobileMenuContainer.offsetWidth\n\n    // Move items based on available width\n    this.breakpoints.forEach((breakpoint) => {\n      if (breakpoint.right > this.width) {\n        this.mobileMenu.insertAdjacentElement('beforeend', breakpoint.element)\n      }\n    })\n  }\n}\n\nmodule.exports = () => {\n  new Header().init()\n}\n","const { toggleConditionalInput } = require('../../common')\n\n/**\n * Conditionally show content when a radio button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/radios/conditional.html\n */\n\nmodule.exports = ({ scope = document } = {}) => {\n  // Radio input HTMLElements inside a conditional form group\n  const radioInputs = scope.querySelectorAll(\n    '.nhsuk-radios--conditional .nhsuk-radios__input'\n  )\n\n  /**\n   * Update all conditional reveals to match checked state\n   */\n  const syncAllConditionalReveals = () => {\n    radioInputs.forEach((input) =>\n      toggleConditionalInput(input, 'nhsuk-radios__conditional--hidden')\n    )\n  }\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', syncAllConditionalReveals)\n  } else {\n    window.addEventListener('DOMContentLoaded', syncAllConditionalReveals)\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  syncAllConditionalReveals()\n\n  // Attach event handler to radioInputs\n  radioInputs.forEach((radioButton) => {\n    radioButton.addEventListener('change', syncAllConditionalReveals)\n  })\n}\n","const { setFocus } = require('../../common')\n\n/*\n * NHS.UK skip link.\n *\n * When using VoiceOver on iOS, focus remains on the skip link anchor\n * when elected so the next focusable element is not at the jumped to area.\n */\n\nmodule.exports = () => {\n  const $skipLink = document.querySelector('.nhsuk-skip-link')\n\n  // Check for skip link\n  if (!$skipLink || !($skipLink instanceof HTMLAnchorElement)) {\n    return\n  }\n\n  const linkedElementId = $skipLink.hash.split('#').pop()\n  const $linkedElement = linkedElementId\n    ? document.getElementById(linkedElementId)\n    : null\n\n  // Check for linked element\n  if (!$linkedElement) {\n    return\n  }\n\n  /**\n   * Focus the linked element on click\n   *\n   * Adds a helper CSS class to hide native focus styles,\n   * but removes it on blur to restore native focus styles\n   */\n  $skipLink.addEventListener('click', () =>\n    setFocus($linkedElement, {\n      onBeforeFocus() {\n        $linkedElement.classList.add('nhsuk-skip-link-focused-element')\n      },\n      onBlur() {\n        $linkedElement.classList.remove('nhsuk-skip-link-focused-element')\n      }\n    })\n  )\n}\n","class Tabs {\n  constructor($module, namespace, responsive, historyEnabled) {\n    this.$module = $module\n    this.namespace = namespace\n    this.responsive = responsive\n    this.historyEnabled = historyEnabled\n    this.$tabs = $module.querySelectorAll(`.${this.namespace}__tab`)\n\n    this.keys = {\n      down: 40,\n      left: 37,\n      right: 39,\n      up: 38\n    }\n    this.jsHiddenClass = `${this.namespace}__panel--hidden`\n\n    this.showEvent = new CustomEvent('tab.show')\n    this.hideEvent = new CustomEvent('tab.hide')\n  }\n\n  init() {\n    if (typeof window.matchMedia === 'function' && this.responsive) {\n      this.setupResponsiveChecks()\n    } else {\n      this.setup()\n    }\n  }\n\n  setupResponsiveChecks() {\n    // $mq-breakpoints: (\n    // mobile: 320px,\n    // tablet: 641px,\n    // desktop: 769px,\n    // large - desktop: 990px\n    // );\n    this.mql = window.matchMedia('(min-width: 641px)')\n\n    // MediaQueryList.addEventListener isn't supported by Safari < 14 so we need\n    // to be able to fall back to the deprecated MediaQueryList.addListener\n    if ('addEventListener' in this.mql) {\n      this.mql.addEventListener('change', this.checkMode.bind(this))\n    } else {\n      // addListener is a deprecated function, however addEventListener\n      // isn't supported by Safari < 14. We therefore add this in as\n      // a fallback for those browsers\n      this.mql.addListener(this.checkMode.bind(this))\n    }\n\n    this.checkMode()\n  }\n\n  checkMode() {\n    if (this.mql.matches) {\n      this.setup()\n    } else {\n      this.teardown()\n    }\n  }\n\n  setup() {\n    const { $module } = this\n    const { $tabs } = this\n    const $tabList = $module.querySelector(`.${this.namespace}__list`)\n    const $tabListItems = $module.querySelectorAll(\n      `.${this.namespace}__list-item`\n    )\n\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return\n    }\n\n    $tabList.setAttribute('role', 'tablist')\n\n    $tabListItems.forEach(($item) => {\n      $item.setAttribute('role', 'presentation')\n    })\n\n    $tabs.forEach(($tab) => {\n      // Set HTML attributes\n      this.setAttributes($tab)\n\n      // Save bounded functions to use when removing event listeners during teardown\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabClick = this.onTabClick.bind(this)\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabKeydown = this.onTabKeydown.bind(this)\n\n      // Handle events\n      $tab.addEventListener('click', $tab.boundTabClick, true)\n      $tab.addEventListener('keydown', $tab.boundTabKeydown, true)\n\n      // Remove old active panels\n      this.hideTab($tab)\n    })\n\n    // Show either the active tab according to the URL's hash or the first tab\n    const $activeTab = this.getTab(window.location.hash) || this.$tabs[0]\n    this.showTab($activeTab)\n\n    // Handle hashchange events\n    if (this.historyEnabled) {\n      $module.boundOnHashChange = this.onHashChange.bind(this)\n      window.addEventListener('hashchange', $module.boundOnHashChange, true)\n    }\n  }\n\n  teardown() {\n    const { $module } = this\n    const { $tabs } = this\n    const $tabList = $module.querySelector(`.${this.namespace}__list`)\n    const $tabListItems = $module.querySelectorAll(\n      `.${this.namespace}__list-item`\n    )\n\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return\n    }\n\n    $tabList.removeAttribute('role')\n\n    $tabListItems.forEach(($item) => {\n      $item.removeAttribute('role', 'presentation')\n    })\n\n    $tabs.forEach(($tab) => {\n      // Remove events\n      $tab.removeEventListener('click', $tab.boundTabClick, true)\n      $tab.removeEventListener('keydown', $tab.boundTabKeydown, true)\n\n      // Unset HTML attributes\n      this.unsetAttributes($tab)\n    })\n\n    if (this.historyEnabled) {\n      // Remove hashchange event handler\n      window.removeEventListener('hashchange', $module.boundOnHashChange, true)\n    }\n  }\n\n  onHashChange() {\n    const { hash } = window.location\n    const $tabWithHash = this.getTab(hash)\n    if (!$tabWithHash) {\n      return\n    }\n\n    // Prevent changing the hash\n    if (this.changingHash) {\n      this.changingHash = false\n      return\n    }\n\n    // Show either the active tab according to the URL's hash or the first tab\n    const $previousTab = this.getCurrentTab()\n\n    this.hideTab($previousTab)\n    this.showTab($tabWithHash)\n    $tabWithHash.focus()\n  }\n\n  hideTab($tab) {\n    this.unhighlightTab($tab)\n    this.hidePanel($tab)\n  }\n\n  showTab($tab) {\n    this.highlightTab($tab)\n    this.showPanel($tab)\n  }\n\n  getTab(hash) {\n    return this.$module.querySelector(`.${this.namespace}__tab[href=\"${hash}\"]`)\n  }\n\n  setAttributes($tab) {\n    // set tab attributes\n    const panelId = Tabs.getHref($tab).slice(1)\n    $tab.setAttribute('id', `tab_${panelId}`)\n    $tab.setAttribute('role', 'tab')\n    $tab.setAttribute('aria-controls', panelId)\n    $tab.setAttribute('aria-selected', 'false')\n    $tab.setAttribute('tabindex', '-1')\n\n    // set panel attributes\n    const $panel = this.getPanel($tab)\n    $panel.setAttribute('role', 'tabpanel')\n    $panel.setAttribute('aria-labelledby', $tab.id)\n    $panel.classList.add(this.jsHiddenClass)\n  }\n\n  unsetAttributes($tab) {\n    // unset tab attributes\n    $tab.removeAttribute('id')\n    $tab.removeAttribute('role')\n    $tab.removeAttribute('aria-controls')\n    $tab.removeAttribute('aria-selected')\n    $tab.removeAttribute('tabindex')\n\n    // unset panel attributes\n    const $panel = this.getPanel($tab)\n    $panel.removeAttribute('role')\n    $panel.removeAttribute('aria-labelledby')\n    $panel.removeAttribute('tabindex')\n    $panel.classList.remove(this.jsHiddenClass)\n  }\n\n  onTabClick(e) {\n    if (!e.target.classList.contains(`${this.namespace}__tab`)) {\n      e.stopPropagation()\n      e.preventDefault()\n    }\n    e.preventDefault()\n    const $newTab = e.target\n    const $currentTab = this.getCurrentTab()\n    this.hideTab($currentTab)\n    this.showTab($newTab)\n    this.createHistoryEntry($newTab)\n  }\n\n  createHistoryEntry($tab) {\n    if (this.historyEnabled) {\n      const $panel = this.getPanel($tab)\n\n      // Save and restore the id\n      // so the page doesn't jump when a user clicks a tab (which changes the hash)\n      const { id } = $panel\n      $panel.id = ''\n      this.changingHash = true\n      window.location.hash = Tabs.getHref($tab).slice(1)\n      $panel.id = id\n    }\n  }\n\n  onTabKeydown(e) {\n    switch (e.keyCode) {\n      case this.keys.left:\n      case this.keys.up:\n        this.activatePreviousTab()\n        e.preventDefault()\n        break\n      case this.keys.right:\n      case this.keys.down:\n        this.activateNextTab()\n        e.preventDefault()\n        break\n\n      default:\n    }\n  }\n\n  activateNextTab() {\n    const currentTab = this.getCurrentTab()\n    const nextTabListItem = currentTab.parentNode.nextElementSibling\n    let nextTab\n\n    if (nextTabListItem) {\n      nextTab = nextTabListItem.querySelector(`.${this.namespace}__tab`)\n    }\n    if (nextTab) {\n      this.hideTab(currentTab)\n      this.showTab(nextTab)\n      nextTab.focus()\n      this.createHistoryEntry(nextTab)\n    }\n  }\n\n  activatePreviousTab() {\n    const currentTab = this.getCurrentTab()\n    const previousTabListItem = currentTab.parentNode.previousElementSibling\n    let previousTab\n\n    if (previousTabListItem) {\n      previousTab = previousTabListItem.querySelector(`.${this.namespace}__tab`)\n    }\n    if (previousTab) {\n      this.hideTab(currentTab)\n      this.showTab(previousTab)\n      previousTab.focus()\n      this.createHistoryEntry(previousTab)\n    }\n  }\n\n  getPanel($tab) {\n    const $panel = this.$module.querySelector(Tabs.getHref($tab))\n    return $panel\n  }\n\n  showPanel($tab) {\n    const $panel = this.getPanel($tab)\n    $panel.classList.remove(this.jsHiddenClass)\n    $panel.dispatchEvent(this.showEvent)\n  }\n\n  hidePanel(tab) {\n    const $panel = this.getPanel(tab)\n    $panel.classList.add(this.jsHiddenClass)\n    $panel.dispatchEvent(this.hideEvent)\n  }\n\n  unhighlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'false')\n    $tab.parentNode.classList.remove(`${this.namespace}__list-item--selected`)\n    $tab.setAttribute('tabindex', '-1')\n  }\n\n  highlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'true')\n    $tab.parentNode.classList.add(`${this.namespace}__list-item--selected`)\n    $tab.setAttribute('tabindex', '0')\n  }\n\n  getCurrentTab() {\n    return this.$module.querySelector(\n      `.${this.namespace}__list-item--selected .${this.namespace}__tab`\n    )\n  }\n\n  // this is because IE doesn't always return the actual value but a relative full path\n  // should be a utility function most prob\n  // http://labs.thesedays.com/blog/2010/01/08/getting-the-href-value-with-jquery-in-ie/\n  static getHref($tab) {\n    const href = $tab.getAttribute('href')\n    const hash = href.slice(href.indexOf('#'), href.length)\n    return hash\n  }\n}\n\n/**\n * Main function to invoke tabs. Can be called as follows to alter various features\n *\n * Tabs({historyEnabled: false});\n * Tabs({responsive: false});\n * Tabs({namespace: 'my-custom-namespace'});  // Alters classes allowing alternative css\n */\nmodule.exports = ({\n  namespace = 'nhsuk-tabs',\n  responsive = true,\n  historyEnabled = true,\n  scope = document\n} = {}) => {\n  const tabs = scope.querySelectorAll(`[data-module=\"${namespace}\"]`)\n  tabs.forEach((el) => {\n    new Tabs(el, namespace, responsive, historyEnabled).init()\n  })\n}\n","/* eslint-disable import/prefer-default-export */\n\n// Components\nconst initButton = require('./components/button/button')\nconst initCharacterCount = require('./components/character-count/character-count')\nconst initCheckboxes = require('./components/checkboxes/checkboxes')\nconst initDetails = require('./components/details/details')\nconst initErrorSummary = require('./components/error-summary/error-summary')\nconst initHeader = require('./components/header/header')\nconst initRadios = require('./components/radios/radios')\nconst initSkipLink = require('./components/skip-link/skip-link')\nconst initTabs = require('./components/tabs/tabs')\n\nrequire('./polyfills.js')\n\n/**\n * Use this function to initialise nhsuk-frontend components within a\n * given scope. This function is called by default with the document\n * element, but you can call it again later with a new DOM element\n * containing nhsuk-frontend components which you wish to initialise.\n *\n * @param {HTMLElement} scope\n */\nfunction initAll(scope) {\n  initButton({ scope })\n  initCharacterCount({ scope })\n  initCheckboxes({ scope })\n  initDetails({ scope })\n  initErrorSummary({ scope })\n  initRadios({ scope })\n  initTabs({ scope })\n}\n\n// Initialize components\ndocument.addEventListener('DOMContentLoaded', () => {\n  initHeader()\n  initSkipLink()\n\n  initAll(document)\n})\n\nmodule.exports = {\n  initAll\n}\n","/**\n * IE polyfill for NodeList.forEach()\n */\nif (!NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach\n}\n\n/**\n * IE polyfill for Array.includes()\n */\nif (!Array.prototype.includes) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Array.prototype, 'includes', {\n    enumerable: false,\n    value(obj) {\n      return this.filter((el) => el === obj).length > 0\n    }\n  })\n}\n\n/**\n * IE polyfill for Element.closest()\n */\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector\n}\n\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this\n\n    do {\n      if (Element.prototype.matches.call(el, s)) return el\n      el = el.parentElement || el.parentNode\n    } while (el !== null && el.nodeType === 1)\n    return null\n  }\n}\n\n/**\n * IE polyfill for CustomEvent\n */\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function (event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null }\n    var evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n    return evt\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(930);\n"]}