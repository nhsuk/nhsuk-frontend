{"version":3,"sources":["nhsuk.js","../packages/common.js","../packages/components/button/button.js","../packages/components/character-count/character-count.js","../packages/components/checkboxes/checkboxes.js","../packages/components/details/details.js","../packages/components/error-summary/error-summary.js","../packages/components/header/header.js","../packages/components/radios/radios.js","../packages/components/skip-link/skip-link.js","../packages/components/tabs/tabs.js","../packages/nhsuk.js","../packages/polyfills.js","../webpack/bootstrap","../webpack/startup"],"names":["__webpack_modules__","module","exports","toggleAttribute","element","attr","value","getAttribute","setAttribute","toggleConditionalInput","input","className","conditionalId","conditionalElement","document","getElementById","checked","classList","remove","add","setFocus","$element","options","isFocusable","onBlur","removeEventListener","call","removeAttribute","addEventListener","onFocus","onBeforeFocus","focus","Button","$module","this","KEY_SPACE","DEBOUNCE_TIMEOUT_IN_SECONDS","debounceFormSubmitTimer","_proto","prototype","handleKeyDown","event","target","keyCode","preventDefault","click","debounce","_this","setTimeout","init","bind","_temp","_ref$scope","scope","querySelectorAll","forEach","el","CharacterCount","$textarea","querySelector","$visibleCountMessage","$screenReaderCountMessage","lastInputTimestamp","$fallbackLimitMessage","id","insertAdjacentElement","createElement","getDataset","countAttribute","defaults","characterCountAttribute","maxwords","wordCountAttribute","maxLength","bindChangeEvents","window","updateCountMessage","dataset","attributes","i","length","attribute","match","name","count","text","handleKeyUp","handleFocus","handleBlur","checkIfValueChanged","oldValue","updateVisibleCountMessage","updateScreenReaderCountMessage","remainingNumber","isOverThreshold","innerHTML","formattedUpdateMessage","charVerb","charNoun","Math","abs","currentLength","threshold","Date","now","valueChecker","setInterval","clearInterval","__unused_webpack_exports","__webpack_require__","require","syncAllConditionalReveals","form","item","checkboxInputs","handleClick","hasAttribute","inputWithSameName","exclusiveInput","unCheckExclusiveInputs","checkboxButton","open","allDetails","index","content","summary","style","display","initDetails","focusTarget","tagName","href","hash","legendOrLabel","fieldset","closest","legends","getElementsByTagName","candidateLegend","type","legendTop","getBoundingClientRect","top","inputRect","height","innerHeight","getAssociatedLegendOrLabel","scrollIntoView","preventScroll","_ref","_ref$focusOnPageLoad","focusOnPageLoad","errorSummary","Header","menuIsOpen","navigation","navigationList","mobileMenu","mobileMenuToggleButton","mobileMenuCloseButton","mobileMenuContainer","breakpoints","width","body","offsetWidth","setupMobileMenu","calculateBreakpoints","updateNavigation","doOnOrientationChange","handleResize","toggleMobileMenu","func","timeout","timer","_this2","_len","arguments","args","Array","_key","clearTimeout","apply","gapPixels","getComputedStyle","getPropertyValue","gap","Number","replace","childrenWidth","children","appendChild","closeMobileMenu","marginBottom","handleEscapeKey","e","key","openMobileMenu","marginBody","offsetHeight","availableSpace","itemsVisible","insertBefore","firstChild","removeChild","_this3","orientation","radioInputs","radioButton","$skipLink","HTMLAnchorElement","linkedElementId","split","pop","$linkedElement","Tabs","namespace","responsive","historyEnabled","$tabs","keys","down","left","right","up","jsHiddenClass","showEvent","CustomEvent","hideEvent","matchMedia","setupResponsiveChecks","setup","mql","checkMode","addListener","matches","teardown","$tabList","$tabListItems","$item","$tab","setAttributes","boundTabClick","onTabClick","boundTabKeydown","onTabKeydown","hideTab","$activeTab","getTab","location","showTab","boundOnHashChange","onHashChange","unsetAttributes","$tabWithHash","changingHash","$previousTab","getCurrentTab","unhighlightTab","hidePanel","highlightTab","showPanel","panelId","getHref","slice","$panel","getPanel","contains","stopPropagation","$newTab","$currentTab","createHistoryEntry","activatePreviousTab","activateNextTab","nextTab","currentTab","nextTabListItem","parentNode","nextElementSibling","previousTab","previousTabListItem","previousElementSibling","dispatchEvent","tab","indexOf","_ref$namespace","_ref$responsive","_ref$historyEnabled","initButton","initCharacterCount","initCheckboxes","initErrorSummary","initHeader","initRadios","initSkipLink","initTabs","initAll","NodeList","includes","Object","defineProperty","enumerable","obj","filter","Element","msMatchesSelector","webkitMatchesSelector","s","parentElement","nodeType","params","bubbles","cancelable","detail","evt","createEvent","initCustomEvent","__webpack_module_cache__","moduleId","cachedModule","undefined"],"mappings":"CAAS,WACC,IAAIA,EAAsB,CAE9B,IACA,SAAUC,GC0FhBA,EAAOC,QAAU,CACfC,gBA1FsB,SAACC,EAASC,GAEhC,GAAKD,GAAYC,EAAjB,CAEA,IAAMC,EAAuC,SAA/BF,EAAQG,aAAaF,GAAmB,QAAU,OAChED,EAAQI,aAAaH,EAAMC,EAHJ,CAIzB,EAqFEG,uBA9E6B,SAACC,EAAOC,GAErC,GAAKD,GAAUC,EAAf,CAEA,IAAMC,EAAgBF,EAAMH,aAAa,iBACzC,GAAIK,EAAe,CAEjB,IAAMC,EAAqBC,SAASC,eAAeH,GAC/CC,IACEH,EAAMM,SACRH,EAAmBI,UAAUC,OAAOP,GACpCD,EAAMF,aAAa,iBAAiB,KAEpCK,EAAmBI,UAAUE,IAAIR,GACjCD,EAAMF,aAAa,iBAAiB,IAG1C,CAf0B,CAgB5B,EA6DEY,SA5CF,SAAkBC,EAAUC,QAAO,IAAPA,IAAAA,EAAU,CAAC,GACrC,IAAMC,EAAcF,EAASd,aAAa,YAiB1C,SAASiB,IACPH,EAASI,oBAAoB,OAAQD,GAEjCF,EAAQE,QACVF,EAAQE,OAAOE,KAAKL,GAGjBE,GACHF,EAASM,gBAAgB,WAE7B,CAzBKJ,GACHF,EAASb,aAAa,WAAY,MA2BpCa,EAASO,iBAAiB,SArB1B,SAASC,IACPR,EAASI,oBAAoB,QAASI,GACtCR,EAASO,iBAAiB,OAAQJ,EACpC,IAqBIF,EAAQQ,eACVR,EAAQQ,cAAcJ,KAAKL,GAG7BA,EAASU,OACX,EDYO,EAED,IACA,SAAU9B,GAEhB,IE7GM+B,EAAM,WACV,SAAAA,EAAYC,GACVC,KAAKC,UAAY,GACjBD,KAAKE,4BAA8B,EAEnCF,KAAKD,QAAUA,EACfC,KAAKG,wBAA0B,IACjC,CAEA,IAAAC,EAAAN,EAAAO,UAsDC,OAtDDD,EASAE,cAAA,SAAcC,GAGZ,IAAQC,EAAWD,EAAXC,OAG0B,WAAhCA,EAAOnC,aAAa,SACpBkC,EAAME,UAAYT,KAAKC,YAEvBM,EAAMG,iBAENF,EAAOG,QAEX,EAEAP,EAKAQ,SAAA,SAASL,GAAO,IAAAM,EAAAb,KAGd,GAAyD,SAFtCO,EAAXC,OAEGnC,aAAa,6BAKxB,OAAI2B,KAAKG,yBACPI,EAAMG,kBACC,QAGTV,KAAKG,wBAA0BW,YAAW,WACxCD,EAAKV,wBAA0B,IACjC,GAAsC,IAAnCH,KAAKE,6BACV,EAEAE,EAIAW,KAAA,WACEf,KAAKD,QAAQL,iBAAiB,UAAWM,KAAKM,cAAcU,KAAKhB,OACjEA,KAAKD,QAAQL,iBAAiB,QAASM,KAAKY,SAASI,KAAKhB,MAC5D,EAACF,CAAA,CA/DS,GAkEZ/B,EAAOC,QAAU,SAAAiD,GAA+B,IAALC,QAAK,IAAAD,EAAP,CAAC,EAACA,GAAvBE,YAAK,IAAAD,EAAGtC,SAAQsC,GACZE,iBAAiB,gCAC/BC,SAAQ,SAACC,GACf,IAAIxB,EAAOwB,GAAIP,MACjB,GACF,CF+GO,EAED,IACA,SAAUhD,GAEhB,IG3LMwD,EAAc,WAClB,SAAAA,EAAYxB,GACVC,KAAKD,QAAUA,EACfC,KAAKwB,UAAYzB,EAAQ0B,cAAc,6BACvCzB,KAAK0B,qBAAuB,KAC5B1B,KAAK2B,0BAA4B,KACjC3B,KAAK4B,mBAAqB,IAC5B,CAEA,IAAAxB,EAAAmB,EAAAlB,UA4PC,OA5PDD,EACAW,KAAA,WAEE,GAAKf,KAAKwB,UAAV,CAKA,IAAQzB,EAAYC,KAAZD,QACAyB,EAAcxB,KAAdwB,UACFK,EAAwBjD,SAASC,eAClC2C,EAAUM,GAAE,SAKjBN,EAAUO,sBAAsB,WAAYF,GAI5C,IAAMF,EAA4B/C,SAASoD,cAAc,OACzDL,EAA0BlD,UACxB,2DACFkD,EAA0BrD,aAAa,YAAa,UACpD0B,KAAK2B,0BAA4BA,EACjCE,EAAsBE,sBACpB,WACAJ,GAKF,IAAMD,EAAuB9C,SAASoD,cAAc,OACpDN,EAAqBjD,UAAYoD,EAAsBpD,UACvDiD,EAAqB3C,UAAUE,IAAI,iCACnCyC,EAAqBpD,aAAa,cAAe,QACjD0B,KAAK0B,qBAAuBA,EAC5BG,EAAsBE,sBACpB,WACAL,GAIFG,EAAsB9C,UAAUE,IAAI,2BAGpCe,KAAKZ,QAAUmC,EAAeU,WAAWlC,GAGzC,IAAImC,EAAiBlC,KAAKmC,SAASC,wBAC/BpC,KAAKZ,QAAQiD,WACfH,EAAiBlC,KAAKmC,SAASG,oBAIjCtC,KAAKuC,UAAYxC,EAAQ1B,aAAa6D,GAGjClC,KAAKuC,YAKVf,EAAU/B,gBAAgB,aAE1BO,KAAKwC,mBAMD,eAAgBC,OAClBA,OAAO/C,iBAAiB,WAAYM,KAAK0C,mBAAmB1B,KAAKhB,OAEjEyC,OAAO/C,iBACL,mBACAM,KAAK0C,mBAAmB1B,KAAKhB,OAGjCA,KAAK0C,qBA1EL,CA2EF,EAEAnB,EACOU,WAAP,SAAkB/D,GAChB,IAAMyE,EAAU,CAAC,EACTC,EAAe1E,EAAf0E,WACR,GAAIA,EACF,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAWE,OAAQD,IAAK,CAC1C,IAAME,EAAYH,EAAWC,GACvBG,EAAQD,EAAUE,KAAKD,MAAM,cAC/BA,IACFL,EAAQK,EAAM,IAAMD,EAAU3E,MAElC,CAEF,OAAOuE,CACT,EAEAvC,EACA8C,MAAA,SAAMC,GACJ,IAAIL,EACA9C,KAAKZ,QAAQiD,SAEfS,GADeK,EAAKH,MAAM,SAAW,IACrBF,OAEhBA,EAASK,EAAKL,OAEhB,OAAOA,CACT,EAEA1C,EACAoC,iBAAA,WACE,IAAQhB,EAAcxB,KAAdwB,UACRA,EAAU9B,iBAAiB,QAASM,KAAKoD,YAAYpC,KAAKhB,OAG1DwB,EAAU9B,iBAAiB,QAASM,KAAKqD,YAAYrC,KAAKhB,OAC1DwB,EAAU9B,iBAAiB,OAAQM,KAAKsD,WAAWtC,KAAKhB,MAC1D,EAIAI,EACAmD,oBAAA,WACOvD,KAAKwB,UAAUgC,WAClBxD,KAAKwB,UAAUgC,SAAW,IAExBxD,KAAKwB,UAAUpD,QAAU4B,KAAKwB,UAAUgC,WAC1CxD,KAAKwB,UAAUgC,SAAWxD,KAAKwB,UAAUpD,MACzC4B,KAAK0C,qBAET,EAGAtC,EACAsC,mBAAA,WACE1C,KAAKyD,4BACLzD,KAAK0D,gCACP,EAEAtD,EACAqD,0BAAA,WACE,IAAQjC,EAAcxB,KAAdwB,UACAE,EAAyB1B,KAAzB0B,qBACFiC,EAAkB3D,KAAKuC,UAAYvC,KAAKkD,MAAM1B,EAAUpD,OAI1D4B,KAAK4D,kBACPlC,EAAqB3C,UAAUC,OAC7B,4CAGF0C,EAAqB3C,UAAUE,IAC7B,4CAKA0E,EAAkB,GACpBnC,EAAUzC,UAAUE,IAAI,yBACxByC,EAAqB3C,UAAUC,OAAO,cACtC0C,EAAqB3C,UAAUE,IAAI,yBAEnCuC,EAAUzC,UAAUC,OAAO,yBAC3B0C,EAAqB3C,UAAUC,OAAO,uBACtC0C,EAAqB3C,UAAUE,IAAI,eAIrCyC,EAAqBmC,UAAY7D,KAAK8D,wBACxC,EAEA1D,EACAsD,+BAAA,WACE,IAAQ/B,EAA8B3B,KAA9B2B,0BAIJ3B,KAAK4D,kBACPjC,EAA0BlC,gBAAgB,eAE1CkC,EAA0BrD,aAAa,eAAe,GAIxDqD,EAA0BkC,UAAY7D,KAAK8D,wBAC7C,EAEA1D,EACA0D,uBAAA,WACE,IAIIC,EAJIvC,EAAcxB,KAAdwB,UACApC,EAAYY,KAAZZ,QACFuE,EAAkB3D,KAAKuC,UAAYvC,KAAKkD,MAAM1B,EAAUpD,OAG1D4F,EAAW,YAUf,OARI5E,EAAQiD,WACV2B,EAAW,QAEbA,IAAiC,IAArBL,GAA8C,IAApBA,EAAwB,GAAK,IAEnEI,EAAWJ,EAAkB,EAAI,WAAa,YAG9C,YAFgBM,KAAKC,IAAIP,GAEO,IAAIK,EAAQ,IAAID,CAClD,EAIA3D,EACAwD,gBAAA,WACE,IAAQpC,EAAcxB,KAAdwB,UACApC,EAAYY,KAAZZ,QAGF+E,EAAgBnE,KAAKkD,MAAM1B,EAAUpD,OAO3C,OANsB4B,KAAduC,WAGiBnD,EAAQgF,UAAYhF,EAAQgF,UAAY,GACT,KAE/BD,CAC3B,EAGA/D,EACAgD,YAAA,WACEpD,KAAKyD,4BACLzD,KAAK4B,mBAAqByC,KAAKC,KACjC,EAAClE,EAEDiD,YAAA,WAAc,IAAAxC,EAAAb,KAKZA,KAAKuE,aAAeC,aAAY,aAE3B3D,EAAKe,oBACNyC,KAAKC,MAAQ,KAAOzD,EAAKe,qBAEzBf,EAAK0C,qBAET,GAAG,IACL,EAACnD,EAEDkD,WAAA,WAEEmB,cAAczE,KAAKuE,aACrB,EAAChD,CAAA,CArQiB,GAwQpBA,EAAelB,UAAU8B,SAAW,CAClCC,wBAAyB,iBACzBE,mBAAoB,iBAGtBvE,EAAOC,QAAU,SAAAiD,GAA+B,IAALC,QAAK,IAAAD,EAAP,CAAC,EAACA,GAAvBE,YAAK,IAAAD,EAAGtC,SAAQsC,GACJE,iBAC5B,yCAEcC,SAAQ,SAACC,GACvB,IAAIC,EAAeD,GAAIP,MACzB,GACF,CH+KO,EAED,IACA,SAAUhD,EAAQ2G,EAA0BC,GItclD,IAAQpG,EAA2BqG,EAAQ,KAAnCrG,uBAMFsG,EAA4B,SAAmCrG,GAC3CA,EAAMsG,KAAK1D,iBAAiB,0BACpCC,SAAQ,SAAC0D,GAAI,OAC3BxG,EAAuBwG,EAAM,wCAAwC,GAEzE,EA+CAhH,EAAOC,QAAU,SAAAiD,GAA+B,IAALC,QAAK,IAAAD,EAAP,CAAC,EAACA,GAAvBE,MAEZ6D,QAFiB,IAAA9D,EAAGtC,SAAQsC,GAELE,iBAC3B,8CAOI6D,EAAc,SAAC1E,GAjDQ,IAAgC/B,GAmD3DD,EACEgC,EAAMC,OACN,yCAGGD,EAAMC,OAAO1B,WAKdyB,EAAMC,OAAO0E,aAAa,6BA7D6B1G,EA8DlC+B,EAAMC,QA7DWsE,KAAK1D,iBAAgB,yDACN5C,EAAMH,aAAa,iCAAgC,MAGhFgD,SAAQ,SAAC8D,GACZ3G,EAAMsG,OAASK,EAAkBL,MAClCK,IAAsB3G,IAC5C2G,EAAkBrG,SAAU,EAEhC,IAEA+F,EAA0BrG,IAUG,SAAgCA,GACdA,EAAMsG,KAAK1D,iBAAgB,kFACU5C,EAAMH,aACtF,iCACD,MAGoCgD,SAAQ,SAAC+D,GACrB5G,EAAMsG,OAASM,EAAeN,OAErDM,EAAetG,SAAU,EAE7B,IAEA+F,EAA0BrG,EAC5B,CA2BM6G,CAAuB9E,EAAMC,QAEjC,EAMI,eAAgBiC,OAClBA,OAAO/C,iBAAiB,YAAY,WAAA,OAClCsF,EAAe3D,SAAQ,SAAC7C,GAAK,OAAKqG,EAA0BrG,EAAM,GAAC,IAGrEiE,OAAO/C,iBAAiB,oBAAoB,WAAA,OAC1CsF,EAAe3D,SAAQ,SAAC7C,GAAK,OAAKqG,EAA0BrG,EAAM,GAAC,IAOvEwG,EAAe3D,SAAQ,SAAC7C,GAAK,OAAKqG,EAA0BrG,EAAM,IAGlEwG,EAAe3D,SAAQ,SAACiE,GACtBA,EAAe5F,iBAAiB,SAAUuF,EAC5C,GACF,CJmcO,EAED,IACA,SAAUlH,EAAQ2G,EAA0BC,GKpjBlD,IAAQ1G,EAAoB2G,EAAQ,KAA5B3G,gBAORF,EAAOC,QAAU,SAAAiD,GAA+B,IAALC,QAAK,IAAAD,EAAP,CAAC,EAACA,GAAvBE,MAAAA,OAAK,IAAAD,EAAGtC,SAAQsC,EAIlC,KADoD,kBAA3CtC,SAASoD,cAAc,WAAWuD,MAC3C,CAKA,IAAMC,EAAarE,EAAMC,iBAAiB,WA+DtCoE,EAAW1C,QACb0C,EAAWnE,SAAQ,SAACnD,EAASuH,GACtBvH,EAAQgH,aAAa,qBA1DV,SAAChH,EAASuH,GAE5BvH,EAAQI,aAAa,mBAAoB,QAGpCJ,EAAQ4D,IAAI5D,EAAQI,aAAa,KAAI,gBAAkBmH,GAG5D,IAAMC,EAAUvE,EAAMM,cAAa,IAAKvD,EAAQ4D,GAAE,yBAC7C4D,EAAQ5D,IAAI4D,EAAQpH,aAAa,KAAI,sBAAwBmH,GAGlE,IAAME,EAAUxE,EAAMM,cAAa,IAC7BvD,EAAQ4D,GAAE,4BAIhB6D,EAAQrH,aAAa,OAAQ,UAC7BqH,EAAQrH,aAAa,gBAAiBoH,EAAQ5D,IAC9C6D,EAAQrH,aAAa,WAAY,MAEhB,IADiC,OAAjCJ,EAAQG,aAAa,UAEpCsH,EAAQrH,aAAa,gBAAiB,QACtCoH,EAAQpH,aAAa,cAAe,WAEpCqH,EAAQrH,aAAa,gBAAiB,SACtCoH,EAAQpH,aAAa,cAAe,QACpCoH,EAAQE,MAAMC,QAAU,QAiB1BF,EAAQjG,iBAAiB,SAdH,WACpBzB,EAAgB0H,EAAS,iBACzB1H,EAAgByH,EAAS,eAEzBA,EAAQE,MAAMC,QAC4B,SAAxCH,EAAQrH,aAAa,eAA4B,OAAS,GACxDH,EAAQgH,aAAa,QACvBhH,EAAQuB,gBAAgB,QAExBvB,EAAQI,aAAa,OAAQ,OAEjC,IAMAqH,EAAQjG,iBAAiB,WAAW,SAACa,GACb,KAAlBA,EAAME,SAAoC,KAAlBF,EAAME,UAChCF,EAAMG,iBACNiF,EAAQhF,QAEZ,GACF,CAKmDmF,CAAY5H,EAASuH,EACtE,GArEF,CAuEF,CLsjBO,EAED,IACA,SAAU1H,GMrkBhB,SAASgI,EAAYvF,GAEnB,GAAuB,MAAnBA,EAAOwF,UAAmC,IAAhBxF,EAAOyF,KACnC,OAAO,EAGT,IAAMzH,EAAQI,SAAS6C,cAAcjB,EAAO0F,MAC5C,IAAK1H,EACH,OAAO,EAGT,IAAM2H,EApER,SAAoC3H,GAClC,IAAM4H,EAAW5H,EAAM6H,QAAQ,YAE/B,GAAID,EAAU,CACZ,IAAME,EAAUF,EAASG,qBAAqB,UAE9C,GAAID,EAAQxD,OAAQ,CAClB,IAAM0D,EAAkBF,EAAQ,GAIhC,GAAmB,aAAf9H,EAAMiI,MAAsC,UAAfjI,EAAMiI,KACrC,OAAOD,EAST,IAAME,EAAYF,EAAgBG,wBAAwBC,IACpDC,EAAYrI,EAAMmI,wBAIxB,GAAIE,EAAUC,QAAUrE,OAAOsE,aACTF,EAAUD,IAAMC,EAAUC,OAE5BJ,EAAYjE,OAAOsE,YAAc,EACjD,OAAOP,CAGb,CACF,CAEA,OACE5H,SAAS6C,cAAa,cAAejD,EAAMH,aAAa,MAAK,OAC7DG,EAAM6H,QAAQ,QAElB,CA4BwBW,CAA2BxI,GACjD,QAAK2H,IAOLA,EAAcc,iBACdzI,EAAMqB,MAAM,CAAEqH,eAAe,KAEtB,EACT,CAKA,SAASjC,EAAY1E,GACfwF,EAAYxF,EAAMC,SACpBD,EAAMG,gBAEV,CAEA3C,EAAOC,QAAU,SAAAiD,GAAuD,IAAAkG,OAAA,IAAAlG,EAAP,CAAC,EAACA,EAAAmG,EAAAD,EAA/CE,gBAAAA,OAAe,IAAAD,GAAOA,EAAAlG,EAAAiG,EAAEhG,MAEpCmG,QAFyC,IAAApG,EAAGtC,SAAQsC,GAE/BO,cAAc,wBAErC6F,IAGED,GACFC,EAAazH,QAEfyH,EAAa5H,iBAAiB,QAASuF,GAE3C,CN4oBO,EAED,IACA,SAAUlH,GOrwBhB,IAKMwJ,EAAM,WACV,SAAAA,IACEvH,KAAKwH,YAAa,EAClBxH,KAAKyH,WAAa7I,SAAS6C,cAAc,qBACzCzB,KAAK0H,eAAiB9I,SAAS6C,cAC7B,kCAEFzB,KAAK2H,WAAa/I,SAASoD,cAAc,MACzChC,KAAK4H,uBAAyBhJ,SAAS6C,cACrC,8BAEFzB,KAAK6H,sBAAwBjJ,SAASoD,cAAc,UACpDhC,KAAK8H,oBAAsBlJ,SAAS6C,cAClC,gCAEFzB,KAAK+H,YAAc,GACnB/H,KAAKgI,MAAQpJ,SAASqJ,KAAKC,WAC7B,CAAC,IAAA9H,EAAAmH,EAAAlH,UA2NA,OA3NAD,EAEDW,KAAA,WAAO,IAAAF,EAAAb,KAEFA,KAAKyH,YACLzH,KAAK0H,gBACL1H,KAAK4H,wBACL5H,KAAK8H,sBAKR9H,KAAKmI,kBACLnI,KAAKoI,uBACLpI,KAAKqI,mBACLrI,KAAKsI,wBAELtI,KAAKuI,aAAevI,KAAKY,UAAS,WAChCC,EAAKuH,uBACLvH,EAAKwH,kBACP,IAEArI,KAAK4H,uBAAuBlI,iBAC1B,QACAM,KAAKwI,iBAAiBxH,KAAKhB,OAE7ByC,OAAO/C,iBAAiB,SAAUM,KAAKuI,cACvC9F,OAAO/C,iBAAiB,oBAAqBM,KAAKsI,yBACpD,EAAClI,EAEDQ,SAAA,SAAS6H,EAAMC,GAAe,IACxBC,EADwBC,EAAA5I,KAE5B,YAFoB,IAAP0I,IAAAA,EAAU,KAEhB,WAAa,IAAA,IAAAG,EAAAC,UAAAhG,OAATiG,EAAI,IAAAC,MAAAH,GAAAI,EAAA,EAAAA,EAAAJ,EAAAI,IAAJF,EAAIE,GAAAH,UAAAG,GACbC,aAAaP,GACbA,EAAQ7H,YAAW,WACjB2H,EAAKU,MAAMP,EAAMG,EACnB,GAAGL,EACL,CACF,EAEAtI,EAOAgI,qBAAA,WAOE,IALA,IACMgB,EADuB3G,OAAO4G,iBAAiBrJ,KAAK0H,gBACnB4B,iBAAiB,OAClDC,EAAMC,OAAOJ,EAAUK,QAAQ,KAAM,KAEvCC,EAAgB,EACX7G,EAAI,EAAGA,EAAI7C,KAAK0H,eAAeiC,SAAS7G,OAAQD,IACvD6G,GAAiB1J,KAAK0H,eAAeiC,SAAS9G,GAAGqF,YAAcqB,EAC/DvJ,KAAK+H,YAAYlF,GAAK6G,CAE1B,EAEAtJ,EACA+H,gBAAA,WACEnI,KAAK8H,oBAAoB8B,YAAY5J,KAAK2H,YAC1C3H,KAAK2H,WAAW5I,UAAUE,IACxB,0BACA,kCAEJ,EAEAmB,EAOAyJ,gBAAA,WACE7J,KAAKwH,YAAa,EAClBxH,KAAK2H,WAAW5I,UAAUE,IAAI,mCAC9Be,KAAKyH,WAAW7B,MAAMkE,aAAe,EACrC9J,KAAK4H,uBAAuBtJ,aAAa,gBAAiB,SAC1D0B,KAAK4H,uBAAuB/H,QAC5BG,KAAK6H,sBAAsBtI,oBACzB,QACAS,KAAK6J,gBAAgB7I,KAAKhB,OAE5BpB,SAASW,oBAAoB,UAAWS,KAAK+J,gBAAgB/I,KAAKhB,MACpE,EAEAI,EAOA2J,gBAAA,SAAgBC,GACA,WAAVA,EAAEC,KACJjK,KAAK6J,iBAET,EAEAzJ,EAWA8J,eAAA,WACElK,KAAKwH,YAAa,EAClBxH,KAAK2H,WAAW5I,UAAUC,OAAO,mCACjC,IAAMmL,EAAanK,KAAK2H,WAAWyC,aACnCpK,KAAKyH,WAAW7B,MAAMkE,aAAkBK,EAAU,KAClDnK,KAAK4H,uBAAuBtJ,aAAa,gBAAiB,QAG1DM,SAASc,iBAAiB,UAAWM,KAAK+J,gBAAgB/I,KAAKhB,OAG/DA,KAAK6H,sBAAsBnI,iBACzB,QACAM,KAAK6J,gBAAgB7I,KAAKhB,MAE9B,EAEAI,EAKAoI,iBAAA,WACMxI,KAAKwH,WACPxH,KAAK6J,kBAEL7J,KAAKkK,gBAET,EAEA9J,EAcAiI,iBAAA,WACE,IAAMgC,EAAiBrK,KAAK0H,eAAeQ,YACvCoC,EAAetK,KAAK0H,eAAeiC,SAAS7G,OAEhD,GAAIuH,EAAiBrK,KAAK+H,YAAYuC,EAAe,GAAI,CAOvD,GANAtK,KAAK4H,uBAAuB7I,UAAUE,IACpC,sCAEFe,KAAK8H,oBAAoB/I,UAAUE,IACjC,wCAEmB,IAAjBqL,EACF,OAEF,KAAOD,EAAiBrK,KAAK+H,YAAYuC,EAAe,IACtDtK,KAAK2H,WAAW4C,aACdvK,KAAK0H,eAAeiC,SAASW,EAAe,GAC5CtK,KAAK2H,WAAW6C,YAElBF,GAAgB,CAEpB,MAAO,GAAID,EAAiBrK,KAAK+H,YAAYuC,GAC3C,KAAOD,EAAiBrK,KAAK+H,YAAYuC,IACvCtK,KAAK0H,eAAe6C,aAClBvK,KAAK2H,WAAW8C,YAAYzK,KAAK2H,WAAW6C,YAC5CxK,KAAK8H,qBAEPwC,GAAgB,EAIftK,KAAK2H,WAAWgC,SAAS7G,SAC5B9C,KAAK4H,uBAAuB7I,UAAUC,OACpC,sCAEFgB,KAAK8H,oBAAoB/I,UAAUC,OACjC,yCAIAJ,SAASqJ,KAAKC,cAAgBlI,KAAKgI,OAAShI,KAAKwH,YACnDxH,KAAK6J,iBAET,EAEAzJ,EAMAkI,sBAAA,WAAwB,IAAAoC,EAAA1K,KACtB,GACO,KADCyC,OAAOkI,YAEX7J,YAAW,WACT4J,EAAKtC,uBACLsC,EAAKrC,kBACP,GAAG,IAKT,EAACd,CAAA,CA5OS,GA+OZxJ,EAAOC,QAAU,YACf,IAAIuJ,GAASxG,MACf,CPmuBO,EAED,IACA,SAAUhD,EAAQ2G,EAA0BC,GQ59BlD,IAAQpG,EAA2BqG,EAAQ,KAAnCrG,uBAORR,EAAOC,QAAU,SAAAiD,GAA+B,IAALC,QAAK,IAAAD,EAAP,CAAC,EAACA,GAAvBE,MAEZyJ,QAFiB,IAAA1J,EAAGtC,SAAQsC,GAERE,iBACxB,mDAMIyD,EAA4B,WAChC+F,EAAYvJ,SAAQ,SAAC7C,GAAK,OACxBD,EAAuBC,EAAO,oCAAoC,GAEtE,EAMI,eAAgBiE,OAClBA,OAAO/C,iBAAiB,WAAYmF,GAEpCpC,OAAO/C,iBAAiB,mBAAoBmF,GAM9CA,IAGA+F,EAAYvJ,SAAQ,SAACwJ,GACnBA,EAAYnL,iBAAiB,SAAUmF,EACzC,GACF,CRk+BO,EAED,IACA,SAAU9G,EAAQ2G,EAA0BC,GS9gClD,IAAQzF,EAAa0F,EAAQ,KAArB1F,SASRnB,EAAOC,QAAU,WACf,IAAM8M,EAAYlM,SAAS6C,cAAc,oBAGzC,GAAKqJ,GAAeA,aAAqBC,kBAAzC,CAIA,IAAMC,EAAkBF,EAAU5E,KAAK+E,MAAM,KAAKC,MAC5CC,EAAiBH,EACnBpM,SAASC,eAAemM,GACxB,KAGCG,GAULL,EAAUpL,iBAAiB,SAAS,WAAA,OAClCR,EAASiM,EAAgB,CACvBvL,cAAa,WACXuL,EAAepM,UAAUE,IAAI,kCAC/B,EACAK,OAAM,WACJ6L,EAAepM,UAAUC,OAAO,kCAClC,GACA,GA1BJ,CA4BF,CTghCO,EAED,IACA,SAAUjB,GAEhB,IUhkCMqN,EAAI,WACR,SAAAA,EAAYrL,EAASsL,EAAWC,EAAYC,GAC1CvL,KAAKD,QAAUA,EACfC,KAAKqL,UAAYA,EACjBrL,KAAKsL,WAAaA,EAClBtL,KAAKuL,eAAiBA,EACtBvL,KAAKwL,MAAQzL,EAAQqB,iBAAgB,IAAKpB,KAAKqL,UAAS,SAExDrL,KAAKyL,KAAO,CACVC,KAAM,GACNC,KAAM,GACNC,MAAO,GACPC,GAAI,IAEN7L,KAAK8L,cAAmB9L,KAAKqL,UAAS,kBAEtCrL,KAAK+L,UAAY,IAAIC,YAAY,YACjChM,KAAKiM,UAAY,IAAID,YAAY,WACnC,CAAC,IAAA5L,EAAAgL,EAAA/K,UAkTA,OAlTAD,EAEDW,KAAA,WACmC,mBAAtB0B,OAAOyJ,YAA6BlM,KAAKsL,WAClDtL,KAAKmM,wBAELnM,KAAKoM,OAET,EAAChM,EAED+L,sBAAA,WAOEnM,KAAKqM,IAAM5J,OAAOyJ,WAAW,sBAIzB,qBAAsBlM,KAAKqM,IAC7BrM,KAAKqM,IAAI3M,iBAAiB,SAAUM,KAAKsM,UAAUtL,KAAKhB,OAKxDA,KAAKqM,IAAIE,YAAYvM,KAAKsM,UAAUtL,KAAKhB,OAG3CA,KAAKsM,WACP,EAAClM,EAEDkM,UAAA,WACMtM,KAAKqM,IAAIG,QACXxM,KAAKoM,QAELpM,KAAKyM,UAET,EAACrM,EAEDgM,MAAA,WAAQ,IAAAvL,EAAAb,KACED,EAAYC,KAAZD,QACAyL,EAAUxL,KAAVwL,MACFkB,EAAW3M,EAAQ0B,cAAa,IAAKzB,KAAKqL,UAAS,UACnDsB,EAAgB5M,EAAQqB,iBAAgB,IACxCpB,KAAKqL,UAAS,eAGpB,GAAKG,GAAUkB,GAAaC,EAA5B,CAIAD,EAASpO,aAAa,OAAQ,WAE9BqO,EAActL,SAAQ,SAACuL,GACrBA,EAAMtO,aAAa,OAAQ,eAC7B,IAEAkN,EAAMnK,SAAQ,SAACwL,GAEbhM,EAAKiM,cAAcD,GAInBA,EAAKE,cAAgBlM,EAAKmM,WAAWhM,KAAKH,GAE1CgM,EAAKI,gBAAkBpM,EAAKqM,aAAalM,KAAKH,GAG9CgM,EAAKnN,iBAAiB,QAASmN,EAAKE,eAAe,GACnDF,EAAKnN,iBAAiB,UAAWmN,EAAKI,iBAAiB,GAGvDpM,EAAKsM,QAAQN,EACf,IAGA,IAAMO,EAAapN,KAAKqN,OAAO5K,OAAO6K,SAASpH,OAASlG,KAAKwL,MAAM,GACnExL,KAAKuN,QAAQH,GAGTpN,KAAKuL,iBACPxL,EAAQyN,kBAAoBxN,KAAKyN,aAAazM,KAAKhB,MACnDyC,OAAO/C,iBAAiB,aAAcK,EAAQyN,mBAAmB,GAjCnE,CAmCF,EAACpN,EAEDqM,SAAA,WAAW,IAAA7D,EAAA5I,KACDD,EAAYC,KAAZD,QACAyL,EAAUxL,KAAVwL,MACFkB,EAAW3M,EAAQ0B,cAAa,IAAKzB,KAAKqL,UAAS,UACnDsB,EAAgB5M,EAAQqB,iBAAgB,IACxCpB,KAAKqL,UAAS,eAGfG,GAAUkB,GAAaC,IAI5BD,EAASjN,gBAAgB,QAEzBkN,EAActL,SAAQ,SAACuL,GACrBA,EAAMnN,gBAAgB,OAAQ,eAChC,IAEA+L,EAAMnK,SAAQ,SAACwL,GAEbA,EAAKtN,oBAAoB,QAASsN,EAAKE,eAAe,GACtDF,EAAKtN,oBAAoB,UAAWsN,EAAKI,iBAAiB,GAG1DrE,EAAK8E,gBAAgBb,EACvB,IAEI7M,KAAKuL,gBAEP9I,OAAOlD,oBAAoB,aAAcQ,EAAQyN,mBAAmB,GAExE,EAACpN,EAEDqN,aAAA,WACE,IAAQvH,EAASzD,OAAO6K,SAAhBpH,KACFyH,EAAe3N,KAAKqN,OAAOnH,GACjC,GAAKyH,EAKL,GAAI3N,KAAK4N,aACP5N,KAAK4N,cAAe,MADtB,CAMA,IAAMC,EAAe7N,KAAK8N,gBAE1B9N,KAAKmN,QAAQU,GACb7N,KAAKuN,QAAQI,GACbA,EAAa9N,OAPb,CAQF,EAACO,EAED+M,QAAA,SAAQN,GACN7M,KAAK+N,eAAelB,GACpB7M,KAAKgO,UAAUnB,EACjB,EAACzM,EAEDmN,QAAA,SAAQV,GACN7M,KAAKiO,aAAapB,GAClB7M,KAAKkO,UAAUrB,EACjB,EAACzM,EAEDiN,OAAA,SAAOnH,GACL,OAAOlG,KAAKD,QAAQ0B,cAAa,IAAKzB,KAAKqL,UAAS,eAAenF,EAAI,KACzE,EAAC9F,EAED0M,cAAA,SAAcD,GAEZ,IAAMsB,EAAU/C,EAAKgD,QAAQvB,GAAMwB,MAAM,GACzCxB,EAAKvO,aAAa,KAAI,OAAS6P,GAC/BtB,EAAKvO,aAAa,OAAQ,OAC1BuO,EAAKvO,aAAa,gBAAiB6P,GACnCtB,EAAKvO,aAAa,gBAAiB,SACnCuO,EAAKvO,aAAa,WAAY,MAG9B,IAAMgQ,EAAStO,KAAKuO,SAAS1B,GAC7ByB,EAAOhQ,aAAa,OAAQ,YAC5BgQ,EAAOhQ,aAAa,kBAAmBuO,EAAK/K,IAC5CwM,EAAOvP,UAAUE,IAAIe,KAAK8L,cAC5B,EAAC1L,EAEDsN,gBAAA,SAAgBb,GAEdA,EAAKpN,gBAAgB,MACrBoN,EAAKpN,gBAAgB,QACrBoN,EAAKpN,gBAAgB,iBACrBoN,EAAKpN,gBAAgB,iBACrBoN,EAAKpN,gBAAgB,YAGrB,IAAM6O,EAAStO,KAAKuO,SAAS1B,GAC7ByB,EAAO7O,gBAAgB,QACvB6O,EAAO7O,gBAAgB,mBACvB6O,EAAO7O,gBAAgB,YACvB6O,EAAOvP,UAAUC,OAAOgB,KAAK8L,cAC/B,EAAC1L,EAED4M,WAAA,SAAWhD,GACJA,EAAExJ,OAAOzB,UAAUyP,SAAYxO,KAAKqL,UAAS,WAChDrB,EAAEyE,kBACFzE,EAAEtJ,kBAEJsJ,EAAEtJ,iBACF,IAAMgO,EAAU1E,EAAExJ,OACZmO,EAAc3O,KAAK8N,gBACzB9N,KAAKmN,QAAQwB,GACb3O,KAAKuN,QAAQmB,GACb1O,KAAK4O,mBAAmBF,EAC1B,EAACtO,EAEDwO,mBAAA,SAAmB/B,GACjB,GAAI7M,KAAKuL,eAAgB,CACvB,IAAM+C,EAAStO,KAAKuO,SAAS1B,GAIrB/K,EAAOwM,EAAPxM,GACRwM,EAAOxM,GAAK,GACZ9B,KAAK4N,cAAe,EACpBnL,OAAO6K,SAASpH,KAAOkF,EAAKgD,QAAQvB,GAAMwB,MAAM,GAChDC,EAAOxM,GAAKA,CACd,CACF,EAAC1B,EAED8M,aAAA,SAAalD,GACX,OAAQA,EAAEvJ,SACR,KAAKT,KAAKyL,KAAKE,KACf,KAAK3L,KAAKyL,KAAKI,GACb7L,KAAK6O,sBACL7E,EAAEtJ,iBACF,MACF,KAAKV,KAAKyL,KAAKG,MACf,KAAK5L,KAAKyL,KAAKC,KACb1L,KAAK8O,kBACL9E,EAAEtJ,iBAKR,EAACN,EAED0O,gBAAA,WACE,IAEIC,EAFEC,EAAahP,KAAK8N,gBAClBmB,EAAkBD,EAAWE,WAAWC,mBAG1CF,IACFF,EAAUE,EAAgBxN,cAAa,IAAKzB,KAAKqL,UAAS,UAExD0D,IACF/O,KAAKmN,QAAQ6B,GACbhP,KAAKuN,QAAQwB,GACbA,EAAQlP,QACRG,KAAK4O,mBAAmBG,GAE5B,EAAC3O,EAEDyO,oBAAA,WACE,IAEIO,EAFEJ,EAAahP,KAAK8N,gBAClBuB,EAAsBL,EAAWE,WAAWI,uBAG9CD,IACFD,EAAcC,EAAoB5N,cAAa,IAAKzB,KAAKqL,UAAS,UAEhE+D,IACFpP,KAAKmN,QAAQ6B,GACbhP,KAAKuN,QAAQ6B,GACbA,EAAYvP,QACZG,KAAK4O,mBAAmBQ,GAE5B,EAAChP,EAEDmO,SAAA,SAAS1B,GAEP,OADe7M,KAAKD,QAAQ0B,cAAc2J,EAAKgD,QAAQvB,GAEzD,EAACzM,EAED8N,UAAA,SAAUrB,GACR,IAAMyB,EAAStO,KAAKuO,SAAS1B,GAC7ByB,EAAOvP,UAAUC,OAAOgB,KAAK8L,eAC7BwC,EAAOiB,cAAcvP,KAAK+L,UAC5B,EAAC3L,EAED4N,UAAA,SAAUwB,GACR,IAAMlB,EAAStO,KAAKuO,SAASiB,GAC7BlB,EAAOvP,UAAUE,IAAIe,KAAK8L,eAC1BwC,EAAOiB,cAAcvP,KAAKiM,UAC5B,EAAC7L,EAED2N,eAAA,SAAelB,GACbA,EAAKvO,aAAa,gBAAiB,SACnCuO,EAAKqC,WAAWnQ,UAAUC,OAAUgB,KAAKqL,UAAS,yBAClDwB,EAAKvO,aAAa,WAAY,KAChC,EAAC8B,EAED6N,aAAA,SAAapB,GACXA,EAAKvO,aAAa,gBAAiB,QACnCuO,EAAKqC,WAAWnQ,UAAUE,IAAOe,KAAKqL,UAAS,yBAC/CwB,EAAKvO,aAAa,WAAY,IAChC,EAAC8B,EAED0N,cAAA,WACE,OAAO9N,KAAKD,QAAQ0B,cAAa,IAC3BzB,KAAKqL,UAAS,0BAA0BrL,KAAKqL,UAAS,QAE9D,EAIAD,EACOgD,QAAP,SAAevB,GACb,IAAM5G,EAAO4G,EAAKxO,aAAa,QAE/B,OADa4H,EAAKoI,MAAMpI,EAAKwJ,QAAQ,KAAMxJ,EAAKnD,OAElD,EAACsI,CAAA,CApUO,GA8UVrN,EAAOC,QAAU,SAAAiD,GAKN,IAAAkG,OAAA,IAAAlG,EAAP,CAAC,EAACA,EAAAyO,EAAAvI,EAJJkE,UAAAA,OAAS,IAAAqE,EAAG,aAAYA,EAAAC,EAAAxI,EACxBmE,WAAAA,OAAU,IAAAqE,GAAOA,EAAAC,EAAAzI,EACjBoE,eAAAA,OAAc,IAAAqE,GAAOA,EAAA1O,EAAAiG,EACrBhG,YAAK,IAAAD,EAAGtC,SAAQsC,GAEGE,iBAAgB,iBAAkBiK,EAAS,MACzDhK,SAAQ,SAACC,GACZ,IAAI8J,EAAK9J,EAAI+J,EAAWC,EAAYC,GAAgBxK,MACtD,GACF,CV8hCO,EAED,IACA,SAAUhD,EAAQ2G,EAA0BC,GWt3ClD,IAAMkL,EAAajL,EAAQ,KACrBkL,EAAqBlL,EAAQ,KAC7BmL,EAAiBnL,EAAQ,KACzBkB,EAAclB,EAAQ,KACtBoL,EAAmBpL,EAAQ,KAC3BqL,EAAarL,EAAQ,KACrBsL,EAAatL,EAAQ,KACrBuL,EAAevL,EAAQ,KACvBwL,EAAWxL,EAAQ,KAYzB,SAASyL,EAAQlP,GACf0O,EAAW,CAAE1O,MAAAA,IACb2O,EAAmB,CAAE3O,MAAAA,IACrB4O,EAAe,CAAE5O,MAAAA,IACjB2E,EAAY,CAAE3E,MAAAA,IACd6O,EAAiB,CAAE7O,MAAAA,IACnB+O,EAAW,CAAE/O,MAAAA,IACbiP,EAAS,CAAEjP,MAAAA,GACb,CAlBAyD,EAAQ,KAqBRhG,SAASc,iBAAiB,oBAAoB,WAC5CuQ,IACAE,IAEAE,EAAQzR,SACV,IAEAb,EAAOC,QAAU,CACfqS,QAAAA,EXy4CK,EAED,IACA,WYn7CDC,SAASjQ,UAAUgB,UACtBiP,SAASjQ,UAAUgB,QAAU2H,MAAM3I,UAAUgB,SAM1C2H,MAAM3I,UAAUkQ,UAEnBC,OAAOC,eAAezH,MAAM3I,UAAW,WAAY,CACjDqQ,YAAY,EACZtS,MAAK,SAACuS,GACJ,OAAO3Q,KAAK4Q,QAAO,SAACtP,GAAE,OAAKA,IAAOqP,CAAG,IAAE7N,OAAS,CAClD,IAOC+N,QAAQxQ,UAAUmM,UACrBqE,QAAQxQ,UAAUmM,QAChBqE,QAAQxQ,UAAUyQ,mBAClBD,QAAQxQ,UAAU0Q,uBAGjBF,QAAQxQ,UAAUgG,UACrBwK,QAAQxQ,UAAUgG,QAAU,SAAU2K,GACpC,IAAI1P,EAAKtB,KAET,EAAG,CACD,GAAI6Q,QAAQxQ,UAAUmM,QAAQhN,KAAK8B,EAAI0P,GAAI,OAAO1P,EAClDA,EAAKA,EAAG2P,eAAiB3P,EAAG4N,UAC9B,OAAgB,OAAP5N,GAA+B,IAAhBA,EAAG4P,UAC3B,OAAO,IACT,GAMgC,mBAAvBzO,OAAOuJ,cAChBvJ,OAAOuJ,YAAc,SAAUzL,EAAO4Q,GACpCA,EAASA,GAAU,CAAEC,SAAS,EAAOC,YAAY,EAAOC,OAAQ,MAChE,IAAIC,EAAM3S,SAAS4S,YAAY,eAE/B,OADAD,EAAIE,gBAAgBlR,EAAO4Q,EAAOC,QAASD,EAAOE,WAAYF,EAAOG,QAC9DC,CACT,EZ67CK,Ga9+CPG,EAAA,CAAA,GAGA,SAAA/M,EAAAgN,GAEA,IAAAC,EAAAF,EAAAC,GACA,QAAAE,IAAAD,EACA,OAAAA,EAAA5T,QAGA,IAAAD,EAAA2T,EAAAC,GAAA,CAGA3T,QAAA,CAAA,GAOA,OAHAF,EAAA6T,GAAA5T,EAAAA,EAAAC,QAAA2G,GAGA5G,EAAAC,OACA,ECnBA2G,CAAA,Id+gDU,CAlhDD","file":"nhsuk-9.3.0.min.js","sourcesContent":["/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 848:\n/***/ (function(module) {\n\n/**\n * Toggle a boolean attribute on a HTML element\n * @param {HTMLElement} element\n * @param {string} attr\n */\nvar toggleAttribute = function toggleAttribute(element, attr) {\n  // Return without error if element or attr are missing\n  if (!element || !attr) return;\n  // Toggle attribute value. Treat no existing attr same as when set to false\n  var value = element.getAttribute(attr) === 'true' ? 'false' : 'true';\n  element.setAttribute(attr, value);\n};\n\n/**\n * Toggle a toggle a class on conditional content for an input based on checked state\n * @param {HTMLElement} input input element\n * @param {string} className class to toggle\n */\nvar toggleConditionalInput = function toggleConditionalInput(input, className) {\n  // Return without error if input or class are missing\n  if (!input || !className) return;\n  // If the input has conditional content it had a data-aria-controls attribute\n  var conditionalId = input.getAttribute('aria-controls');\n  if (conditionalId) {\n    // Get the conditional element from the input data-aria-controls attribute\n    var conditionalElement = document.getElementById(conditionalId);\n    if (conditionalElement) {\n      if (input.checked) {\n        conditionalElement.classList.remove(className);\n        input.setAttribute('aria-expanded', true);\n      } else {\n        conditionalElement.classList.add(className);\n        input.setAttribute('aria-expanded', false);\n      }\n    }\n  }\n};\n\n/**\n * Move focus to element\n *\n * Sets tabindex to -1 to make the element programmatically focusable,\n * but removes it on blur as the element doesn't need to be focused again.\n *\n * Original code taken from GDS (Government Digital Service)\n * {@link https://github.com/alphagov/govuk-frontend}\n *\n * @template {HTMLElement} FocusElement\n * @param {FocusElement} $element - HTML element\n * @param {object} [options] - Handler options\n * @param {function(this: FocusElement): void} [options.onBeforeFocus] - Callback before focus\n * @param {function(this: FocusElement): void} [options.onBlur] - Callback on blur\n */\nfunction setFocus($element, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var isFocusable = $element.getAttribute('tabindex');\n  if (!isFocusable) {\n    $element.setAttribute('tabindex', '-1');\n  }\n\n  /**\n   * Handle element focus\n   */\n  function onFocus() {\n    $element.removeEventListener('focus', onFocus);\n    $element.addEventListener('blur', onBlur);\n  }\n\n  /**\n   * Handle element blur\n   */\n  function onBlur() {\n    $element.removeEventListener('blur', onBlur);\n    if (options.onBlur) {\n      options.onBlur.call($element);\n    }\n    if (!isFocusable) {\n      $element.removeAttribute('tabindex');\n    }\n  }\n\n  // Add listener to reset element on blur, after focus\n  $element.addEventListener('focus', onFocus);\n\n  // Focus element\n  if (options.onBeforeFocus) {\n    options.onBeforeFocus.call($element);\n  }\n  $element.focus();\n}\nmodule.exports = {\n  toggleAttribute: toggleAttribute,\n  toggleConditionalInput: toggleConditionalInput,\n  setFocus: setFocus\n};\n\n/***/ }),\n\n/***/ 807:\n/***/ (function(module) {\n\nvar Button = /*#__PURE__*/function () {\n  function Button($module) {\n    this.KEY_SPACE = 32;\n    this.DEBOUNCE_TIMEOUT_IN_SECONDS = 1;\n    this.$module = $module;\n    this.debounceFormSubmitTimer = null;\n  }\n\n  /**\n   * JavaScript 'shim' to trigger the click event of element(s) when the space key is pressed.\n   *\n   * Created since some Assistive Technologies (for example some Screenreaders)\n   * will tell a user to press space on a 'button', so this functionality needs to be shimmed\n   * See https://github.com/alphagov/govuk_elements/pull/272#issuecomment-233028270\n   *\n   * @param {object} event event\n   */\n  var _proto = Button.prototype;\n  _proto.handleKeyDown = function handleKeyDown(event) {\n    // get the target element\n\n    var target = event.target;\n    // if the element has a role='button' and the pressed key is a space, we'll simulate a click\n    if (target.getAttribute('role') === 'button' && event.keyCode === this.KEY_SPACE) {\n      event.preventDefault();\n      // trigger the target's click event\n      target.click();\n    }\n  }\n\n  /**\n   * If the click quickly succeeds a previous click then nothing will happen.\n   * This stops people accidentally causing multiple form submissions by\n   * double clicking buttons.\n   */;\n  _proto.debounce = function debounce(event) {\n    var _this = this;\n    var target = event.target;\n    // Check the button that is clicked on has the preventDoubleClick feature enabled\n    if (target.getAttribute('data-prevent-double-click') !== 'true') {\n      return;\n    }\n\n    // If the timer is still running then we want to prevent the click from submitting the form\n    if (this.debounceFormSubmitTimer) {\n      event.preventDefault();\n      return false; // eslint-disable-line consistent-return\n    }\n    this.debounceFormSubmitTimer = setTimeout(function () {\n      _this.debounceFormSubmitTimer = null;\n    }, this.DEBOUNCE_TIMEOUT_IN_SECONDS * 1000);\n  }\n\n  /**\n   * Initialise an event listener for keydown at document level\n   * this will help listening for later inserted elements with a role=\"button\"\n   */;\n  _proto.init = function init() {\n    this.$module.addEventListener('keydown', this.handleKeyDown.bind(this));\n    this.$module.addEventListener('click', this.debounce.bind(this));\n  };\n  return Button;\n}();\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  var buttons = scope.querySelectorAll('[data-module=\"nhsuk-button\"]');\n  buttons.forEach(function (el) {\n    new Button(el).init();\n  });\n};\n\n/***/ }),\n\n/***/ 997:\n/***/ (function(module) {\n\nvar CharacterCount = /*#__PURE__*/function () {\n  function CharacterCount($module) {\n    this.$module = $module;\n    this.$textarea = $module.querySelector('.nhsuk-js-character-count');\n    this.$visibleCountMessage = null;\n    this.$screenReaderCountMessage = null;\n    this.lastInputTimestamp = null;\n  }\n\n  // Initialize component\n  var _proto = CharacterCount.prototype;\n  _proto.init = function init() {\n    // Check that required elements are present\n    if (!this.$textarea) {\n      return;\n    }\n\n    // Check for module\n    var $module = this.$module;\n    var $textarea = this.$textarea;\n    var $fallbackLimitMessage = document.getElementById($textarea.id + \"-info\");\n\n    // Move the fallback count message to be immediately after the textarea\n    // Kept for backwards compatibility\n    $textarea.insertAdjacentElement('afterend', $fallbackLimitMessage);\n\n    // Create the *screen reader* specific live-updating counter\n    // This doesn't need any styling classes, as it is never visible\n    var $screenReaderCountMessage = document.createElement('div');\n    $screenReaderCountMessage.className = 'nhsuk-character-count__sr-status nhsuk-u-visually-hidden';\n    $screenReaderCountMessage.setAttribute('aria-live', 'polite');\n    this.$screenReaderCountMessage = $screenReaderCountMessage;\n    $fallbackLimitMessage.insertAdjacentElement('afterend', $screenReaderCountMessage);\n\n    // Create our live-updating counter element, copying the classes from the\n    // fallback element for backwards compatibility as these may have been configured\n    var $visibleCountMessage = document.createElement('div');\n    $visibleCountMessage.className = $fallbackLimitMessage.className;\n    $visibleCountMessage.classList.add('nhsuk-character-count__status');\n    $visibleCountMessage.setAttribute('aria-hidden', 'true');\n    this.$visibleCountMessage = $visibleCountMessage;\n    $fallbackLimitMessage.insertAdjacentElement('afterend', $visibleCountMessage);\n\n    // Hide the fallback limit message\n    $fallbackLimitMessage.classList.add('nhsuk-u-visually-hidden');\n\n    // Read options set using dataset ('data-' values)\n    this.options = CharacterCount.getDataset($module);\n\n    // Determine the limit attribute (characters or words)\n    var countAttribute = this.defaults.characterCountAttribute;\n    if (this.options.maxwords) {\n      countAttribute = this.defaults.wordCountAttribute;\n    }\n\n    // Save the element limit\n    this.maxLength = $module.getAttribute(countAttribute);\n\n    // Check for limit\n    if (!this.maxLength) {\n      return;\n    }\n\n    // Remove hard limit if set\n    $textarea.removeAttribute('maxlength');\n    this.bindChangeEvents();\n\n    // When the page is restored after navigating 'back' in some browsers the\n    // state of the character count is not restored until *after* the DOMContentLoaded\n    // event is fired, so we need to manually update it after the pageshow event\n    // in browsers that support it.\n    if ('onpageshow' in window) {\n      window.addEventListener('pageshow', this.updateCountMessage.bind(this));\n    } else {\n      window.addEventListener('DOMContentLoaded', this.updateCountMessage.bind(this));\n    }\n    this.updateCountMessage();\n  }\n\n  // Read data attributes\n  ;\n  CharacterCount.getDataset = function getDataset(element) {\n    var dataset = {};\n    var attributes = element.attributes;\n    if (attributes) {\n      for (var i = 0; i < attributes.length; i++) {\n        var attribute = attributes[i];\n        var match = attribute.name.match(/^data-(.+)/);\n        if (match) {\n          dataset[match[1]] = attribute.value;\n        }\n      }\n    }\n    return dataset;\n  }\n\n  // Counts characters or words in text\n  ;\n  _proto.count = function count(text) {\n    var length;\n    if (this.options.maxwords) {\n      var tokens = text.match(/\\S+/g) || []; // Matches consecutive non-whitespace chars\n      length = tokens.length; // eslint-disable-line prefer-destructuring\n    } else {\n      length = text.length; // eslint-disable-line prefer-destructuring\n    }\n    return length;\n  }\n\n  // Bind input propertychange to the elements and update based on the change\n  ;\n  _proto.bindChangeEvents = function bindChangeEvents() {\n    var $textarea = this.$textarea;\n    $textarea.addEventListener('keyup', this.handleKeyUp.bind(this));\n\n    // Bind focus/blur events to start/stop polling\n    $textarea.addEventListener('focus', this.handleFocus.bind(this));\n    $textarea.addEventListener('blur', this.handleBlur.bind(this));\n  }\n\n  // Speech recognition software such as Dragon NaturallySpeaking will modify the\n  // fields by directly changing its `value`. These changes don't trigger events\n  // in JavaScript, so we need to poll to handle when and if they occur.\n  ;\n  _proto.checkIfValueChanged = function checkIfValueChanged() {\n    if (!this.$textarea.oldValue) {\n      this.$textarea.oldValue = '';\n    }\n    if (this.$textarea.value !== this.$textarea.oldValue) {\n      this.$textarea.oldValue = this.$textarea.value;\n      this.updateCountMessage();\n    }\n  }\n\n  // Helper function to update both the visible and screen reader-specific\n  // counters simultaneously (e.g. on init)\n  ;\n  _proto.updateCountMessage = function updateCountMessage() {\n    this.updateVisibleCountMessage();\n    this.updateScreenReaderCountMessage();\n  }\n\n  // Update visible counter\n  ;\n  _proto.updateVisibleCountMessage = function updateVisibleCountMessage() {\n    var $textarea = this.$textarea;\n    var $visibleCountMessage = this.$visibleCountMessage;\n    var remainingNumber = this.maxLength - this.count($textarea.value);\n\n    // If input is over the threshold, remove the disabled class which renders the\n    // counter invisible.\n    if (this.isOverThreshold()) {\n      $visibleCountMessage.classList.remove('nhsuk-character-count__message--disabled');\n    } else {\n      $visibleCountMessage.classList.add('nhsuk-character-count__message--disabled');\n    }\n\n    // Update styles\n    if (remainingNumber < 0) {\n      $textarea.classList.add('nhsuk-textarea--error');\n      $visibleCountMessage.classList.remove('nhsuk-hint');\n      $visibleCountMessage.classList.add('nhsuk-error-message');\n    } else {\n      $textarea.classList.remove('nhsuk-textarea--error');\n      $visibleCountMessage.classList.remove('nhsuk-error-message');\n      $visibleCountMessage.classList.add('nhsuk-hint');\n    }\n\n    // Update message\n    $visibleCountMessage.innerHTML = this.formattedUpdateMessage();\n  }\n\n  // Update screen reader-specific counter\n  ;\n  _proto.updateScreenReaderCountMessage = function updateScreenReaderCountMessage() {\n    var $screenReaderCountMessage = this.$screenReaderCountMessage;\n\n    // If over the threshold, remove the aria-hidden attribute, allowing screen\n    // readers to announce the content of the element.\n    if (this.isOverThreshold()) {\n      $screenReaderCountMessage.removeAttribute('aria-hidden');\n    } else {\n      $screenReaderCountMessage.setAttribute('aria-hidden', true);\n    }\n\n    // Update message\n    $screenReaderCountMessage.innerHTML = this.formattedUpdateMessage();\n  }\n\n  // Format update message\n  ;\n  _proto.formattedUpdateMessage = function formattedUpdateMessage() {\n    var $textarea = this.$textarea;\n    var options = this.options;\n    var remainingNumber = this.maxLength - this.count($textarea.value);\n    var charVerb = 'remaining';\n    var charNoun = 'character';\n    var displayNumber = remainingNumber;\n    if (options.maxwords) {\n      charNoun = 'word';\n    }\n    charNoun += remainingNumber === -1 || remainingNumber === 1 ? '' : 's';\n    charVerb = remainingNumber < 0 ? 'too many' : 'remaining';\n    displayNumber = Math.abs(remainingNumber);\n    return \"You have \" + displayNumber + \" \" + charNoun + \" \" + charVerb;\n  }\n\n  // Checks whether the value is over the configured threshold for the input.\n  // If there is no configured threshold, it is set to 0 and this function will\n  // always return true.\n  ;\n  _proto.isOverThreshold = function isOverThreshold() {\n    var $textarea = this.$textarea;\n    var options = this.options;\n\n    // Determine the remaining number of characters/words\n    var currentLength = this.count($textarea.value);\n    var maxLength = this.maxLength;\n\n    // Set threshold if presented in options\n    var thresholdPercent = options.threshold ? options.threshold : 0;\n    var thresholdValue = maxLength * thresholdPercent / 100;\n    return thresholdValue <= currentLength;\n  }\n\n  // Update the visible character counter and keep track of when the last update\n  // happened for each keypress\n  ;\n  _proto.handleKeyUp = function handleKeyUp() {\n    this.updateVisibleCountMessage();\n    this.lastInputTimestamp = Date.now();\n  };\n  _proto.handleFocus = function handleFocus() {\n    var _this = this;\n    // If the field is focused, and a keyup event hasn't been detected for at\n    // least 1000 ms (1 second), then run the manual change check.\n    // This is so that the update triggered by the manual comparison doesn't\n    // conflict with debounced KeyboardEvent updates.\n    this.valueChecker = setInterval(function () {\n      if (!_this.lastInputTimestamp || Date.now() - 500 >= _this.lastInputTimestamp) {\n        _this.checkIfValueChanged();\n      }\n    }, 1000);\n  };\n  _proto.handleBlur = function handleBlur() {\n    // Cancel value checking on blur\n    clearInterval(this.valueChecker);\n  };\n  return CharacterCount;\n}();\nCharacterCount.prototype.defaults = {\n  characterCountAttribute: 'data-maxlength',\n  wordCountAttribute: 'data-maxwords'\n};\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  var characterCounts = scope.querySelectorAll('[data-module=\"nhsuk-character-count\"]');\n  characterCounts.forEach(function (el) {\n    new CharacterCount(el).init();\n  });\n};\n\n/***/ }),\n\n/***/ 305:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar _require = __webpack_require__(848),\n  toggleConditionalInput = _require.toggleConditionalInput;\n\n/**\n * Conditionally show content when a checkbox button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/checkboxes/conditional.html\n */\nvar syncAllConditionalReveals = function syncAllConditionalReveals(input) {\n  var allInputsInForm = input.form.querySelectorAll('input[type=\"checkbox\"]');\n  allInputsInForm.forEach(function (item) {\n    return toggleConditionalInput(item, 'nhsuk-checkboxes__conditional--hidden');\n  });\n};\n\n/**\n * Uncheck other checkboxes\n *\n * Find any other checkbox inputs with the checkbox group value, and uncheck them.\n * This is useful for when a “None of these\" checkbox is checked.\n */\nvar unCheckAllInputsExcept = function unCheckAllInputsExcept(input) {\n  var allInputsInSameExclusiveGroup = input.form.querySelectorAll(\"input[type=\\\"checkbox\\\"][data-checkbox-exclusive-group=\\\"\" + input.getAttribute('data-checkbox-exclusive-group') + \"\\\"]\");\n  allInputsInSameExclusiveGroup.forEach(function (inputWithSameName) {\n    var hasSameFormOwner = input.form === inputWithSameName.form;\n    if (hasSameFormOwner && inputWithSameName !== input) {\n      inputWithSameName.checked = false; // eslint-disable-line no-param-reassign\n    }\n  });\n  syncAllConditionalReveals(input);\n};\n\n/**\n * Uncheck exclusive inputs\n *\n * Find any checkbox inputs with the same checkbox group value and the 'exclusive' behaviour,\n * and uncheck them. This helps prevent someone checking both a regular checkbox and a\n * \"None of these\" checkbox in the same fieldset.\n */\nvar unCheckExclusiveInputs = function unCheckExclusiveInputs(input) {\n  var allExclusiveInputsInSameExclusiveGroup = input.form.querySelectorAll(\"input[type=\\\"checkbox\\\"][data-checkbox-exclusive][data-checkbox-exclusive-group=\\\"\" + input.getAttribute('data-checkbox-exclusive-group') + \"\\\"]\");\n  allExclusiveInputsInSameExclusiveGroup.forEach(function (exclusiveInput) {\n    var hasSameFormOwner = input.form === exclusiveInput.form;\n    if (hasSameFormOwner) {\n      exclusiveInput.checked = false; // eslint-disable-line no-param-reassign\n    }\n  });\n  syncAllConditionalReveals(input);\n};\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Checkbox input DOMElements inside a conditional form group\n  var checkboxInputs = scope.querySelectorAll('.nhsuk-checkboxes .nhsuk-checkboxes__input');\n\n  /**\n   * Toggle classes and attributes\n   * @param {Object} event click event object\n   */\n  var handleClick = function handleClick(event) {\n    // Toggle conditional content based on checked state\n    toggleConditionalInput(event.target, 'nhsuk-checkboxes__conditional--hidden');\n    if (!event.target.checked) {\n      return;\n    }\n\n    // Handle 'exclusive' checkbox behaviour (ie \"None of these\")\n    if (event.target.hasAttribute('data-checkbox-exclusive')) {\n      unCheckAllInputsExcept(event.target);\n    } else {\n      unCheckExclusiveInputs(event.target);\n    }\n  };\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', function () {\n      return checkboxInputs.forEach(function (input) {\n        return syncAllConditionalReveals(input);\n      });\n    });\n  } else {\n    window.addEventListener('DOMContentLoaded', function () {\n      return checkboxInputs.forEach(function (input) {\n        return syncAllConditionalReveals(input);\n      });\n    });\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  checkboxInputs.forEach(function (input) {\n    return syncAllConditionalReveals(input);\n  });\n\n  // Attach handleClick as click to checkboxInputs\n  checkboxInputs.forEach(function (checkboxButton) {\n    checkboxButton.addEventListener('change', handleClick);\n  });\n};\n\n/***/ }),\n\n/***/ 277:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar _require = __webpack_require__(848),\n  toggleAttribute = _require.toggleAttribute;\n\n/**\n * Ensure details component is cross browser and accessible\n * Test at http://localhost:3000/nhsuk-frontend/components/details/index.html\n */\n\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Does the browser support details component\n  var nativeSupport = typeof document.createElement('details').open === 'boolean';\n  if (nativeSupport) {\n    return;\n  }\n\n  // Nodelist of all details elements\n  var allDetails = scope.querySelectorAll('details');\n\n  /**\n   * Adds all necessary functionality to a details element\n   * @param {HTMLElement} element details element to initialise\n   * @param {number} index number to be appended to dynamic IDs\n   */\n  var initDetails = function initDetails(element, index) {\n    // Set details element as polyfilled to prevent duplicate events being added\n    element.setAttribute('nhsuk-polyfilled', 'true');\n\n    // Give details element an ID if it doesn't already have one\n    if (!element.id) element.setAttribute('id', \"nhsuk-details\" + index);\n\n    // Set content element and give it an ID if it doesn't already have one\n    var content = scope.querySelector(\"#\" + element.id + \" .nhsuk-details__text\");\n    if (!content.id) content.setAttribute('id', \"nhsuk-details__text\" + index);\n\n    // Set summary element\n    var summary = scope.querySelector(\"#\" + element.id + \" .nhsuk-details__summary\");\n\n    // Set initial summary aria attributes\n    summary.setAttribute('role', 'button');\n    summary.setAttribute('aria-controls', content.id);\n    summary.setAttribute('tabIndex', '0');\n    var openAttr = element.getAttribute('open') !== null;\n    if (openAttr === true) {\n      summary.setAttribute('aria-expanded', 'true');\n      content.setAttribute('aria-hidden', 'false');\n    } else {\n      summary.setAttribute('aria-expanded', 'false');\n      content.setAttribute('aria-hidden', 'true');\n      content.style.display = 'none';\n    }\n    var toggleDetails = function toggleDetails() {\n      toggleAttribute(summary, 'aria-expanded');\n      toggleAttribute(content, 'aria-hidden');\n      content.style.display = content.getAttribute('aria-hidden') === 'true' ? 'none' : '';\n      if (element.hasAttribute('open')) {\n        element.removeAttribute('open');\n      } else {\n        element.setAttribute('open', 'open');\n      }\n    };\n\n    // Toggle details onclick\n    summary.addEventListener('click', toggleDetails);\n\n    // Call toggle details on enter and space key events\n    summary.addEventListener('keydown', function (event) {\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        summary.click();\n      }\n    });\n  };\n\n  // Initialise details for any new details element\n  if (allDetails.length) {\n    allDetails.forEach(function (element, index) {\n      if (!element.hasAttribute('nhsuk-polyfilled')) initDetails(element, index);\n    });\n  }\n};\n\n/***/ }),\n\n/***/ 673:\n/***/ (function(module) {\n\n/**\n * Adapted from https://github.com/alphagov/govuk-frontend/blob/master/src/govuk/components/error-summary/error-summary.js\n */\n\n/**\n * Get associated legend or label\n *\n * Returns the first element that exists from this list:\n *\n * - The `<legend>` associated with the closest `<fieldset>` ancestor, as long\n *   as the top of it is no more than half a viewport height away from the\n *   bottom of the input\n * - The first `<label>` that is associated with the input using for='inputId'\n * - The closest parent `<label>`\n */\nfunction getAssociatedLegendOrLabel(input) {\n  var fieldset = input.closest('fieldset');\n  if (fieldset) {\n    var legends = fieldset.getElementsByTagName('legend');\n    if (legends.length) {\n      var candidateLegend = legends[0]; // eslint-disable-line prefer-destructuring\n\n      // If the input type is radio or checkbox, always use the legend if there\n      // is one.\n      if (input.type === 'checkbox' || input.type === 'radio') {\n        return candidateLegend;\n      }\n\n      // For other input types, only scroll to the fieldset’s legend (instead of\n      // the label associated with the input) if the input would end up in the\n      // top half of the screen.\n      //\n      // This should avoid situations where the input either ends up off the\n      // screen, or obscured by a software keyboard.\n      var legendTop = candidateLegend.getBoundingClientRect().top;\n      var inputRect = input.getBoundingClientRect();\n\n      // If the browser doesn't support Element.getBoundingClientRect().height\n      // or window.innerHeight (like IE8), bail and just link to the label.\n      if (inputRect.height && window.innerHeight) {\n        var inputBottom = inputRect.top + inputRect.height;\n        if (inputBottom - legendTop < window.innerHeight / 2) {\n          return candidateLegend;\n        }\n      }\n    }\n  }\n  return document.querySelector(\"label[for='\" + input.getAttribute('id') + \"']\") || input.closest('label');\n}\n\n/**\n * Focus the target element\n *\n * By default, the browser will scroll the target into view. Because our labels\n * or legends appear above the input, this means the user will be presented with\n * an input without any context, as the label or legend will be off the top of\n * the screen.\n *\n * Manually handling the click event, scrolling the question into view and then\n * focussing the element solves this.\n *\n * This also results in the label and/or legend being announced correctly in\n * NVDA - without this only the field type is announced\n * (e.g. 'Edit, has autocomplete').\n */\nfunction focusTarget(target) {\n  // If the element that was clicked was not a link, return early\n  if (target.tagName !== 'A' || target.href === false) {\n    return false;\n  }\n  var input = document.querySelector(target.hash);\n  if (!input) {\n    return false;\n  }\n  var legendOrLabel = getAssociatedLegendOrLabel(input);\n  if (!legendOrLabel) {\n    return false;\n  }\n\n  // Scroll the legend or label into view *before* calling focus on the input to\n  // avoid extra scrolling in browsers that don't support `preventScroll` (which\n  // at time of writing is most of them...)\n  legendOrLabel.scrollIntoView();\n  input.focus({\n    preventScroll: true\n  });\n  return true;\n}\n\n/**\n * Handle click events on the error summary\n */\nfunction handleClick(event) {\n  if (focusTarget(event.target)) {\n    event.preventDefault();\n  }\n}\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$focusOnPageLoad = _ref.focusOnPageLoad,\n    focusOnPageLoad = _ref$focusOnPageLoad === void 0 ? true : _ref$focusOnPageLoad,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Error summary component\n  var errorSummary = scope.querySelector('.nhsuk-error-summary');\n  if (errorSummary) {\n    // Focus error summary component if it exists\n\n    if (focusOnPageLoad) {\n      errorSummary.focus();\n    }\n    errorSummary.addEventListener('click', handleClick);\n  }\n};\n\n/***/ }),\n\n/***/ 649:\n/***/ (function(module) {\n\n/**\n * Header component\n *\n */\nvar Header = /*#__PURE__*/function () {\n  function Header() {\n    this.menuIsOpen = false;\n    this.navigation = document.querySelector('.nhsuk-navigation');\n    this.navigationList = document.querySelector('.nhsuk-header__navigation-list');\n    this.mobileMenu = document.createElement('ul');\n    this.mobileMenuToggleButton = document.querySelector('.nhsuk-header__menu-toggle');\n    this.mobileMenuCloseButton = document.createElement('button');\n    this.mobileMenuContainer = document.querySelector('.nhsuk-mobile-menu-container');\n    this.breakpoints = [];\n    this.width = document.body.offsetWidth;\n  }\n  var _proto = Header.prototype;\n  _proto.init = function init() {\n    var _this = this;\n    if (!this.navigation || !this.navigationList || !this.mobileMenuToggleButton || !this.mobileMenuContainer) {\n      return;\n    }\n    this.setupMobileMenu();\n    this.calculateBreakpoints();\n    this.updateNavigation();\n    this.doOnOrientationChange();\n    this.handleResize = this.debounce(function () {\n      _this.calculateBreakpoints();\n      _this.updateNavigation();\n    });\n    this.mobileMenuToggleButton.addEventListener('click', this.toggleMobileMenu.bind(this));\n    window.addEventListener('resize', this.handleResize);\n    window.addEventListener('orientationchange', this.doOnOrientationChange());\n  };\n  _proto.debounce = function debounce(func, timeout) {\n    var _this2 = this;\n    if (timeout === void 0) {\n      timeout = 100;\n    }\n    var timer;\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        func.apply(_this2, args);\n      }, timeout);\n    };\n  }\n\n  /**\n   * Calculate breakpoints.\n   *\n   * Calculate the breakpoints by summing the widths of\n   * each navigation item.\n   *\n   */;\n  _proto.calculateBreakpoints = function calculateBreakpoints() {\n    // Get the width of the gap between each navigation item\n    var navigationListStyles = window.getComputedStyle(this.navigationList);\n    var gapPixels = navigationListStyles.getPropertyValue('gap');\n    var gap = Number(gapPixels.replace('px', ''));\n    var childrenWidth = 0;\n    for (var i = 0; i < this.navigationList.children.length; i++) {\n      childrenWidth += this.navigationList.children[i].offsetWidth + gap;\n      this.breakpoints[i] = childrenWidth;\n    }\n  }\n\n  // Add the mobile menu to the DOM\n  ;\n  _proto.setupMobileMenu = function setupMobileMenu() {\n    this.mobileMenuContainer.appendChild(this.mobileMenu);\n    this.mobileMenu.classList.add('nhsuk-header__drop-down', 'nhsuk-header__drop-down--hidden');\n  }\n\n  /**\n   * Close the mobile menu\n   *\n   * Closes the mobile menu and updates accessibility state.\n   *\n   * Removes the margin-bottom from the navigation\n   */;\n  _proto.closeMobileMenu = function closeMobileMenu() {\n    this.menuIsOpen = false;\n    this.mobileMenu.classList.add('nhsuk-header__drop-down--hidden');\n    this.navigation.style.marginBottom = 0;\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'false');\n    this.mobileMenuToggleButton.focus();\n    this.mobileMenuCloseButton.removeEventListener('click', this.closeMobileMenu.bind(this));\n    document.removeEventListener('keydown', this.handleEscapeKey.bind(this));\n  }\n\n  /**\n   * Escape key handler\n   *\n   * This function is called when the user\n   * presses the escape key to close the mobile menu.\n   *\n   */;\n  _proto.handleEscapeKey = function handleEscapeKey(e) {\n    if (e.key === 'Escape') {\n      this.closeMobileMenu();\n    }\n  }\n\n  /**\n   * Open the mobile menu\n   *\n   * Opens the mobile menu and updates accessibility state.\n   *\n   * The mobile menu is absolutely positioned, so it adds a margin\n   * to the bottom of the navigation to prevent it from overlapping\n   *\n   * Adds event listeners for the close button,\n   */;\n  _proto.openMobileMenu = function openMobileMenu() {\n    this.menuIsOpen = true;\n    this.mobileMenu.classList.remove('nhsuk-header__drop-down--hidden');\n    var marginBody = this.mobileMenu.offsetHeight;\n    this.navigation.style.marginBottom = marginBody + \"px\";\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'true');\n\n    // add event listener for esc key to close menu\n    document.addEventListener('keydown', this.handleEscapeKey.bind(this));\n\n    // add event listener for close icon to close menu\n    this.mobileMenuCloseButton.addEventListener('click', this.closeMobileMenu.bind(this));\n  }\n\n  /**\n   * Handle menu button click\n   *\n   * Toggles the mobile menu between open and closed\n   */;\n  _proto.toggleMobileMenu = function toggleMobileMenu() {\n    if (this.menuIsOpen) {\n      this.closeMobileMenu();\n    } else {\n      this.openMobileMenu();\n    }\n  }\n\n  /**\n   * Update nav for the available space\n   *\n   * If the available space is less than the current breakpoint,\n   * add the mobile menu toggle button and move the last\n   * item in the list to the drop-down list.\n   *\n   * If the available space is greater than the current breakpoint,\n   * remove the mobile menu toggle button and move the first item in the\n   *\n   * Additionally will close the mobile menu if the window gets resized\n   * and the menu is open.\n   */;\n  _proto.updateNavigation = function updateNavigation() {\n    var availableSpace = this.navigationList.offsetWidth;\n    var itemsVisible = this.navigationList.children.length;\n    if (availableSpace < this.breakpoints[itemsVisible - 1]) {\n      this.mobileMenuToggleButton.classList.add('nhsuk-header__menu-toggle--visible');\n      this.mobileMenuContainer.classList.add('nhsuk-mobile-menu-container--visible');\n      if (itemsVisible === 2) {\n        return;\n      }\n      while (availableSpace < this.breakpoints[itemsVisible - 1]) {\n        this.mobileMenu.insertBefore(this.navigationList.children[itemsVisible - 2], this.mobileMenu.firstChild);\n        itemsVisible -= 1;\n      }\n    } else if (availableSpace > this.breakpoints[itemsVisible]) {\n      while (availableSpace > this.breakpoints[itemsVisible]) {\n        this.navigationList.insertBefore(this.mobileMenu.removeChild(this.mobileMenu.firstChild), this.mobileMenuContainer);\n        itemsVisible += 1;\n      }\n    }\n    if (!this.mobileMenu.children.length) {\n      this.mobileMenuToggleButton.classList.remove('nhsuk-header__menu-toggle--visible');\n      this.mobileMenuContainer.classList.remove('nhsuk-mobile-menu-container--visible');\n    }\n    if (document.body.offsetWidth !== this.width && this.menuIsOpen) {\n      this.closeMobileMenu();\n    }\n  }\n\n  /**\n   * Orientation change\n   *\n   * Check the orientation of the device, if changed it will trigger a\n   * update to the breakpoints and navigation.\n   */;\n  _proto.doOnOrientationChange = function doOnOrientationChange() {\n    var _this3 = this;\n    switch (window.orientation) {\n      case 90:\n        setTimeout(function () {\n          _this3.calculateBreakpoints();\n          _this3.updateNavigation();\n        }, 200);\n        break;\n      default:\n        break;\n    }\n  };\n  return Header;\n}();\nmodule.exports = function () {\n  new Header().init();\n};\n\n/***/ }),\n\n/***/ 551:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar _require = __webpack_require__(848),\n  toggleConditionalInput = _require.toggleConditionalInput;\n\n/**\n * Conditionally show content when a radio button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/radios/conditional.html\n */\n\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  // Radio input HTMLElements inside a conditional form group\n  var radioInputs = scope.querySelectorAll('.nhsuk-radios--conditional .nhsuk-radios__input');\n\n  /**\n   * Update all conditional reveals to match checked state\n   */\n  var syncAllConditionalReveals = function syncAllConditionalReveals() {\n    radioInputs.forEach(function (input) {\n      return toggleConditionalInput(input, 'nhsuk-radios__conditional--hidden');\n    });\n  };\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', syncAllConditionalReveals);\n  } else {\n    window.addEventListener('DOMContentLoaded', syncAllConditionalReveals);\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  syncAllConditionalReveals();\n\n  // Attach event handler to radioInputs\n  radioInputs.forEach(function (radioButton) {\n    radioButton.addEventListener('change', syncAllConditionalReveals);\n  });\n};\n\n/***/ }),\n\n/***/ 829:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar _require = __webpack_require__(848),\n  setFocus = _require.setFocus;\n\n/*\n * NHS.UK skip link.\n *\n * When using VoiceOver on iOS, focus remains on the skip link anchor\n * when elected so the next focusable element is not at the jumped to area.\n */\n\nmodule.exports = function () {\n  var $skipLink = document.querySelector('.nhsuk-skip-link');\n\n  // Check for skip link\n  if (!$skipLink || !($skipLink instanceof HTMLAnchorElement)) {\n    return;\n  }\n  var linkedElementId = $skipLink.hash.split('#').pop();\n  var $linkedElement = linkedElementId ? document.getElementById(linkedElementId) : null;\n\n  // Check for linked element\n  if (!$linkedElement) {\n    return;\n  }\n\n  /**\n   * Focus the linked element on click\n   *\n   * Adds a helper CSS class to hide native focus styles,\n   * but removes it on blur to restore native focus styles\n   */\n  $skipLink.addEventListener('click', function () {\n    return setFocus($linkedElement, {\n      onBeforeFocus: function onBeforeFocus() {\n        $linkedElement.classList.add('nhsuk-skip-link-focused-element');\n      },\n      onBlur: function onBlur() {\n        $linkedElement.classList.remove('nhsuk-skip-link-focused-element');\n      }\n    });\n  });\n};\n\n/***/ }),\n\n/***/ 303:\n/***/ (function(module) {\n\nvar Tabs = /*#__PURE__*/function () {\n  function Tabs($module, namespace, responsive, historyEnabled) {\n    this.$module = $module;\n    this.namespace = namespace;\n    this.responsive = responsive;\n    this.historyEnabled = historyEnabled;\n    this.$tabs = $module.querySelectorAll(\".\" + this.namespace + \"__tab\");\n    this.keys = {\n      down: 40,\n      left: 37,\n      right: 39,\n      up: 38\n    };\n    this.jsHiddenClass = this.namespace + \"__panel--hidden\";\n    this.showEvent = new CustomEvent('tab.show');\n    this.hideEvent = new CustomEvent('tab.hide');\n  }\n  var _proto = Tabs.prototype;\n  _proto.init = function init() {\n    if (typeof window.matchMedia === 'function' && this.responsive) {\n      this.setupResponsiveChecks();\n    } else {\n      this.setup();\n    }\n  };\n  _proto.setupResponsiveChecks = function setupResponsiveChecks() {\n    // $mq-breakpoints: (\n    // mobile: 320px,\n    // tablet: 641px,\n    // desktop: 769px,\n    // large - desktop: 990px\n    // );\n    this.mql = window.matchMedia('(min-width: 641px)');\n\n    // MediaQueryList.addEventListener isn't supported by Safari < 14 so we need\n    // to be able to fall back to the deprecated MediaQueryList.addListener\n    if ('addEventListener' in this.mql) {\n      this.mql.addEventListener('change', this.checkMode.bind(this));\n    } else {\n      // addListener is a deprecated function, however addEventListener\n      // isn't supported by Safari < 14. We therefore add this in as\n      // a fallback for those browsers\n      this.mql.addListener(this.checkMode.bind(this));\n    }\n    this.checkMode();\n  };\n  _proto.checkMode = function checkMode() {\n    if (this.mql.matches) {\n      this.setup();\n    } else {\n      this.teardown();\n    }\n  };\n  _proto.setup = function setup() {\n    var _this = this;\n    var $module = this.$module;\n    var $tabs = this.$tabs;\n    var $tabList = $module.querySelector(\".\" + this.namespace + \"__list\");\n    var $tabListItems = $module.querySelectorAll(\".\" + this.namespace + \"__list-item\");\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return;\n    }\n    $tabList.setAttribute('role', 'tablist');\n    $tabListItems.forEach(function ($item) {\n      $item.setAttribute('role', 'presentation');\n    });\n    $tabs.forEach(function ($tab) {\n      // Set HTML attributes\n      _this.setAttributes($tab);\n\n      // Save bounded functions to use when removing event listeners during teardown\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabClick = _this.onTabClick.bind(_this);\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabKeydown = _this.onTabKeydown.bind(_this);\n\n      // Handle events\n      $tab.addEventListener('click', $tab.boundTabClick, true);\n      $tab.addEventListener('keydown', $tab.boundTabKeydown, true);\n\n      // Remove old active panels\n      _this.hideTab($tab);\n    });\n\n    // Show either the active tab according to the URL's hash or the first tab\n    var $activeTab = this.getTab(window.location.hash) || this.$tabs[0];\n    this.showTab($activeTab);\n\n    // Handle hashchange events\n    if (this.historyEnabled) {\n      $module.boundOnHashChange = this.onHashChange.bind(this);\n      window.addEventListener('hashchange', $module.boundOnHashChange, true);\n    }\n  };\n  _proto.teardown = function teardown() {\n    var _this2 = this;\n    var $module = this.$module;\n    var $tabs = this.$tabs;\n    var $tabList = $module.querySelector(\".\" + this.namespace + \"__list\");\n    var $tabListItems = $module.querySelectorAll(\".\" + this.namespace + \"__list-item\");\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return;\n    }\n    $tabList.removeAttribute('role');\n    $tabListItems.forEach(function ($item) {\n      $item.removeAttribute('role', 'presentation');\n    });\n    $tabs.forEach(function ($tab) {\n      // Remove events\n      $tab.removeEventListener('click', $tab.boundTabClick, true);\n      $tab.removeEventListener('keydown', $tab.boundTabKeydown, true);\n\n      // Unset HTML attributes\n      _this2.unsetAttributes($tab);\n    });\n    if (this.historyEnabled) {\n      // Remove hashchange event handler\n      window.removeEventListener('hashchange', $module.boundOnHashChange, true);\n    }\n  };\n  _proto.onHashChange = function onHashChange() {\n    var hash = window.location.hash;\n    var $tabWithHash = this.getTab(hash);\n    if (!$tabWithHash) {\n      return;\n    }\n\n    // Prevent changing the hash\n    if (this.changingHash) {\n      this.changingHash = false;\n      return;\n    }\n\n    // Show either the active tab according to the URL's hash or the first tab\n    var $previousTab = this.getCurrentTab();\n    this.hideTab($previousTab);\n    this.showTab($tabWithHash);\n    $tabWithHash.focus();\n  };\n  _proto.hideTab = function hideTab($tab) {\n    this.unhighlightTab($tab);\n    this.hidePanel($tab);\n  };\n  _proto.showTab = function showTab($tab) {\n    this.highlightTab($tab);\n    this.showPanel($tab);\n  };\n  _proto.getTab = function getTab(hash) {\n    return this.$module.querySelector(\".\" + this.namespace + \"__tab[href=\\\"\" + hash + \"\\\"]\");\n  };\n  _proto.setAttributes = function setAttributes($tab) {\n    // set tab attributes\n    var panelId = Tabs.getHref($tab).slice(1);\n    $tab.setAttribute('id', \"tab_\" + panelId);\n    $tab.setAttribute('role', 'tab');\n    $tab.setAttribute('aria-controls', panelId);\n    $tab.setAttribute('aria-selected', 'false');\n    $tab.setAttribute('tabindex', '-1');\n\n    // set panel attributes\n    var $panel = this.getPanel($tab);\n    $panel.setAttribute('role', 'tabpanel');\n    $panel.setAttribute('aria-labelledby', $tab.id);\n    $panel.classList.add(this.jsHiddenClass);\n  };\n  _proto.unsetAttributes = function unsetAttributes($tab) {\n    // unset tab attributes\n    $tab.removeAttribute('id');\n    $tab.removeAttribute('role');\n    $tab.removeAttribute('aria-controls');\n    $tab.removeAttribute('aria-selected');\n    $tab.removeAttribute('tabindex');\n\n    // unset panel attributes\n    var $panel = this.getPanel($tab);\n    $panel.removeAttribute('role');\n    $panel.removeAttribute('aria-labelledby');\n    $panel.removeAttribute('tabindex');\n    $panel.classList.remove(this.jsHiddenClass);\n  };\n  _proto.onTabClick = function onTabClick(e) {\n    if (!e.target.classList.contains(this.namespace + \"__tab\")) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n    e.preventDefault();\n    var $newTab = e.target;\n    var $currentTab = this.getCurrentTab();\n    this.hideTab($currentTab);\n    this.showTab($newTab);\n    this.createHistoryEntry($newTab);\n  };\n  _proto.createHistoryEntry = function createHistoryEntry($tab) {\n    if (this.historyEnabled) {\n      var $panel = this.getPanel($tab);\n\n      // Save and restore the id\n      // so the page doesn't jump when a user clicks a tab (which changes the hash)\n      var id = $panel.id;\n      $panel.id = '';\n      this.changingHash = true;\n      window.location.hash = Tabs.getHref($tab).slice(1);\n      $panel.id = id;\n    }\n  };\n  _proto.onTabKeydown = function onTabKeydown(e) {\n    switch (e.keyCode) {\n      case this.keys.left:\n      case this.keys.up:\n        this.activatePreviousTab();\n        e.preventDefault();\n        break;\n      case this.keys.right:\n      case this.keys.down:\n        this.activateNextTab();\n        e.preventDefault();\n        break;\n      default:\n    }\n  };\n  _proto.activateNextTab = function activateNextTab() {\n    var currentTab = this.getCurrentTab();\n    var nextTabListItem = currentTab.parentNode.nextElementSibling;\n    var nextTab;\n    if (nextTabListItem) {\n      nextTab = nextTabListItem.querySelector(\".\" + this.namespace + \"__tab\");\n    }\n    if (nextTab) {\n      this.hideTab(currentTab);\n      this.showTab(nextTab);\n      nextTab.focus();\n      this.createHistoryEntry(nextTab);\n    }\n  };\n  _proto.activatePreviousTab = function activatePreviousTab() {\n    var currentTab = this.getCurrentTab();\n    var previousTabListItem = currentTab.parentNode.previousElementSibling;\n    var previousTab;\n    if (previousTabListItem) {\n      previousTab = previousTabListItem.querySelector(\".\" + this.namespace + \"__tab\");\n    }\n    if (previousTab) {\n      this.hideTab(currentTab);\n      this.showTab(previousTab);\n      previousTab.focus();\n      this.createHistoryEntry(previousTab);\n    }\n  };\n  _proto.getPanel = function getPanel($tab) {\n    var $panel = this.$module.querySelector(Tabs.getHref($tab));\n    return $panel;\n  };\n  _proto.showPanel = function showPanel($tab) {\n    var $panel = this.getPanel($tab);\n    $panel.classList.remove(this.jsHiddenClass);\n    $panel.dispatchEvent(this.showEvent);\n  };\n  _proto.hidePanel = function hidePanel(tab) {\n    var $panel = this.getPanel(tab);\n    $panel.classList.add(this.jsHiddenClass);\n    $panel.dispatchEvent(this.hideEvent);\n  };\n  _proto.unhighlightTab = function unhighlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'false');\n    $tab.parentNode.classList.remove(this.namespace + \"__list-item--selected\");\n    $tab.setAttribute('tabindex', '-1');\n  };\n  _proto.highlightTab = function highlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'true');\n    $tab.parentNode.classList.add(this.namespace + \"__list-item--selected\");\n    $tab.setAttribute('tabindex', '0');\n  };\n  _proto.getCurrentTab = function getCurrentTab() {\n    return this.$module.querySelector(\".\" + this.namespace + \"__list-item--selected .\" + this.namespace + \"__tab\");\n  }\n\n  // this is because IE doesn't always return the actual value but a relative full path\n  // should be a utility function most prob\n  // http://labs.thesedays.com/blog/2010/01/08/getting-the-href-value-with-jquery-in-ie/\n  ;\n  Tabs.getHref = function getHref($tab) {\n    var href = $tab.getAttribute('href');\n    var hash = href.slice(href.indexOf('#'), href.length);\n    return hash;\n  };\n  return Tabs;\n}();\n/**\n * Main function to invoke tabs. Can be called as follows to alter various features\n *\n * Tabs({historyEnabled: false});\n * Tabs({responsive: false});\n * Tabs({namespace: 'my-custom-namespace'});  // Alters classes allowing alternative css\n */\nmodule.exports = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$namespace = _ref.namespace,\n    namespace = _ref$namespace === void 0 ? 'nhsuk-tabs' : _ref$namespace,\n    _ref$responsive = _ref.responsive,\n    responsive = _ref$responsive === void 0 ? true : _ref$responsive,\n    _ref$historyEnabled = _ref.historyEnabled,\n    historyEnabled = _ref$historyEnabled === void 0 ? true : _ref$historyEnabled,\n    _ref$scope = _ref.scope,\n    scope = _ref$scope === void 0 ? document : _ref$scope;\n  var tabs = scope.querySelectorAll(\"[data-module=\\\"\" + namespace + \"\\\"]\");\n  tabs.forEach(function (el) {\n    new Tabs(el, namespace, responsive, historyEnabled).init();\n  });\n};\n\n/***/ }),\n\n/***/ 930:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n/* eslint-disable import/prefer-default-export */\n\n// Components\nvar initButton = __webpack_require__(807);\nvar initCharacterCount = __webpack_require__(997);\nvar initCheckboxes = __webpack_require__(305);\nvar initDetails = __webpack_require__(277);\nvar initErrorSummary = __webpack_require__(673);\nvar initHeader = __webpack_require__(649);\nvar initRadios = __webpack_require__(551);\nvar initSkipLink = __webpack_require__(829);\nvar initTabs = __webpack_require__(303);\n__webpack_require__(621);\n\n/**\n * Use this function to initialise nhsuk-frontend components within a\n * given scope. This function is called by default with the document\n * element, but you can call it again later with a new DOM element\n * containing nhsuk-frontend components which you wish to initialise.\n *\n * @param {HTMLElement} scope\n */\nfunction initAll(scope) {\n  initButton({\n    scope: scope\n  });\n  initCharacterCount({\n    scope: scope\n  });\n  initCheckboxes({\n    scope: scope\n  });\n  initDetails({\n    scope: scope\n  });\n  initErrorSummary({\n    scope: scope\n  });\n  initRadios({\n    scope: scope\n  });\n  initTabs({\n    scope: scope\n  });\n}\n\n// Initialize components\ndocument.addEventListener('DOMContentLoaded', function () {\n  initHeader();\n  initSkipLink();\n  initAll(document);\n});\nmodule.exports = {\n  initAll: initAll\n};\n\n/***/ }),\n\n/***/ 621:\n/***/ (function() {\n\n/**\n * IE polyfill for NodeList.forEach()\n */\nif (!NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach;\n}\n\n/**\n * IE polyfill for Array.includes()\n */\nif (!Array.prototype.includes) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Array.prototype, 'includes', {\n    enumerable: false,\n    value: function value(obj) {\n      return this.filter(function (el) {\n        return el === obj;\n      }).length > 0;\n    }\n  });\n}\n\n/**\n * IE polyfill for Element.closest()\n */\nif (!Element.prototype.matches) {\n  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n}\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this;\n    do {\n      if (Element.prototype.matches.call(el, s)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n    return null;\n  };\n}\n\n/**\n * IE polyfill for CustomEvent\n */\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function (event, params) {\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: null\n    };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  };\n}\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(930);\n/******/ \t\n/******/ })()\n;\n","/**\n * Toggle a boolean attribute on a HTML element\n * @param {HTMLElement} element\n * @param {string} attr\n */\nconst toggleAttribute = (element, attr) => {\n  // Return without error if element or attr are missing\n  if (!element || !attr) return\n  // Toggle attribute value. Treat no existing attr same as when set to false\n  const value = element.getAttribute(attr) === 'true' ? 'false' : 'true'\n  element.setAttribute(attr, value)\n}\n\n/**\n * Toggle a toggle a class on conditional content for an input based on checked state\n * @param {HTMLElement} input input element\n * @param {string} className class to toggle\n */\nconst toggleConditionalInput = (input, className) => {\n  // Return without error if input or class are missing\n  if (!input || !className) return\n  // If the input has conditional content it had a data-aria-controls attribute\n  const conditionalId = input.getAttribute('aria-controls')\n  if (conditionalId) {\n    // Get the conditional element from the input data-aria-controls attribute\n    const conditionalElement = document.getElementById(conditionalId)\n    if (conditionalElement) {\n      if (input.checked) {\n        conditionalElement.classList.remove(className)\n        input.setAttribute('aria-expanded', true)\n      } else {\n        conditionalElement.classList.add(className)\n        input.setAttribute('aria-expanded', false)\n      }\n    }\n  }\n}\n\n/**\n * Move focus to element\n *\n * Sets tabindex to -1 to make the element programmatically focusable,\n * but removes it on blur as the element doesn't need to be focused again.\n *\n * Original code taken from GDS (Government Digital Service)\n * {@link https://github.com/alphagov/govuk-frontend}\n *\n * @template {HTMLElement} FocusElement\n * @param {FocusElement} $element - HTML element\n * @param {object} [options] - Handler options\n * @param {function(this: FocusElement): void} [options.onBeforeFocus] - Callback before focus\n * @param {function(this: FocusElement): void} [options.onBlur] - Callback on blur\n */\nfunction setFocus($element, options = {}) {\n  const isFocusable = $element.getAttribute('tabindex')\n\n  if (!isFocusable) {\n    $element.setAttribute('tabindex', '-1')\n  }\n\n  /**\n   * Handle element focus\n   */\n  function onFocus() {\n    $element.removeEventListener('focus', onFocus)\n    $element.addEventListener('blur', onBlur)\n  }\n\n  /**\n   * Handle element blur\n   */\n  function onBlur() {\n    $element.removeEventListener('blur', onBlur)\n\n    if (options.onBlur) {\n      options.onBlur.call($element)\n    }\n\n    if (!isFocusable) {\n      $element.removeAttribute('tabindex')\n    }\n  }\n\n  // Add listener to reset element on blur, after focus\n  $element.addEventListener('focus', onFocus)\n\n  // Focus element\n  if (options.onBeforeFocus) {\n    options.onBeforeFocus.call($element)\n  }\n\n  $element.focus()\n}\n\nmodule.exports = {\n  toggleAttribute,\n  toggleConditionalInput,\n  setFocus\n}\n","class Button {\n  constructor($module) {\n    this.KEY_SPACE = 32\n    this.DEBOUNCE_TIMEOUT_IN_SECONDS = 1\n\n    this.$module = $module\n    this.debounceFormSubmitTimer = null\n  }\n\n  /**\n   * JavaScript 'shim' to trigger the click event of element(s) when the space key is pressed.\n   *\n   * Created since some Assistive Technologies (for example some Screenreaders)\n   * will tell a user to press space on a 'button', so this functionality needs to be shimmed\n   * See https://github.com/alphagov/govuk_elements/pull/272#issuecomment-233028270\n   *\n   * @param {object} event event\n   */\n  handleKeyDown(event) {\n    // get the target element\n\n    const { target } = event\n    // if the element has a role='button' and the pressed key is a space, we'll simulate a click\n    if (\n      target.getAttribute('role') === 'button' &&\n      event.keyCode === this.KEY_SPACE\n    ) {\n      event.preventDefault()\n      // trigger the target's click event\n      target.click()\n    }\n  }\n\n  /**\n   * If the click quickly succeeds a previous click then nothing will happen.\n   * This stops people accidentally causing multiple form submissions by\n   * double clicking buttons.\n   */\n  debounce(event) {\n    const { target } = event\n    // Check the button that is clicked on has the preventDoubleClick feature enabled\n    if (target.getAttribute('data-prevent-double-click') !== 'true') {\n      return\n    }\n\n    // If the timer is still running then we want to prevent the click from submitting the form\n    if (this.debounceFormSubmitTimer) {\n      event.preventDefault()\n      return false // eslint-disable-line consistent-return\n    }\n\n    this.debounceFormSubmitTimer = setTimeout(() => {\n      this.debounceFormSubmitTimer = null\n    }, this.DEBOUNCE_TIMEOUT_IN_SECONDS * 1000)\n  }\n\n  /**\n   * Initialise an event listener for keydown at document level\n   * this will help listening for later inserted elements with a role=\"button\"\n   */\n  init() {\n    this.$module.addEventListener('keydown', this.handleKeyDown.bind(this))\n    this.$module.addEventListener('click', this.debounce.bind(this))\n  }\n}\n\nmodule.exports = ({ scope = document } = {}) => {\n  const buttons = scope.querySelectorAll('[data-module=\"nhsuk-button\"]')\n  buttons.forEach((el) => {\n    new Button(el).init()\n  })\n}\n","class CharacterCount {\n  constructor($module) {\n    this.$module = $module\n    this.$textarea = $module.querySelector('.nhsuk-js-character-count')\n    this.$visibleCountMessage = null\n    this.$screenReaderCountMessage = null\n    this.lastInputTimestamp = null\n  }\n\n  // Initialize component\n  init() {\n    // Check that required elements are present\n    if (!this.$textarea) {\n      return\n    }\n\n    // Check for module\n    const { $module } = this\n    const { $textarea } = this\n    const $fallbackLimitMessage = document.getElementById(\n      `${$textarea.id}-info`\n    )\n\n    // Move the fallback count message to be immediately after the textarea\n    // Kept for backwards compatibility\n    $textarea.insertAdjacentElement('afterend', $fallbackLimitMessage)\n\n    // Create the *screen reader* specific live-updating counter\n    // This doesn't need any styling classes, as it is never visible\n    const $screenReaderCountMessage = document.createElement('div')\n    $screenReaderCountMessage.className =\n      'nhsuk-character-count__sr-status nhsuk-u-visually-hidden'\n    $screenReaderCountMessage.setAttribute('aria-live', 'polite')\n    this.$screenReaderCountMessage = $screenReaderCountMessage\n    $fallbackLimitMessage.insertAdjacentElement(\n      'afterend',\n      $screenReaderCountMessage\n    )\n\n    // Create our live-updating counter element, copying the classes from the\n    // fallback element for backwards compatibility as these may have been configured\n    const $visibleCountMessage = document.createElement('div')\n    $visibleCountMessage.className = $fallbackLimitMessage.className\n    $visibleCountMessage.classList.add('nhsuk-character-count__status')\n    $visibleCountMessage.setAttribute('aria-hidden', 'true')\n    this.$visibleCountMessage = $visibleCountMessage\n    $fallbackLimitMessage.insertAdjacentElement(\n      'afterend',\n      $visibleCountMessage\n    )\n\n    // Hide the fallback limit message\n    $fallbackLimitMessage.classList.add('nhsuk-u-visually-hidden')\n\n    // Read options set using dataset ('data-' values)\n    this.options = CharacterCount.getDataset($module)\n\n    // Determine the limit attribute (characters or words)\n    let countAttribute = this.defaults.characterCountAttribute\n    if (this.options.maxwords) {\n      countAttribute = this.defaults.wordCountAttribute\n    }\n\n    // Save the element limit\n    this.maxLength = $module.getAttribute(countAttribute)\n\n    // Check for limit\n    if (!this.maxLength) {\n      return\n    }\n\n    // Remove hard limit if set\n    $textarea.removeAttribute('maxlength')\n\n    this.bindChangeEvents()\n\n    // When the page is restored after navigating 'back' in some browsers the\n    // state of the character count is not restored until *after* the DOMContentLoaded\n    // event is fired, so we need to manually update it after the pageshow event\n    // in browsers that support it.\n    if ('onpageshow' in window) {\n      window.addEventListener('pageshow', this.updateCountMessage.bind(this))\n    } else {\n      window.addEventListener(\n        'DOMContentLoaded',\n        this.updateCountMessage.bind(this)\n      )\n    }\n    this.updateCountMessage()\n  }\n\n  // Read data attributes\n  static getDataset(element) {\n    const dataset = {}\n    const { attributes } = element\n    if (attributes) {\n      for (let i = 0; i < attributes.length; i++) {\n        const attribute = attributes[i]\n        const match = attribute.name.match(/^data-(.+)/)\n        if (match) {\n          dataset[match[1]] = attribute.value\n        }\n      }\n    }\n    return dataset\n  }\n\n  // Counts characters or words in text\n  count(text) {\n    let length\n    if (this.options.maxwords) {\n      const tokens = text.match(/\\S+/g) || [] // Matches consecutive non-whitespace chars\n      length = tokens.length // eslint-disable-line prefer-destructuring\n    } else {\n      length = text.length // eslint-disable-line prefer-destructuring\n    }\n    return length\n  }\n\n  // Bind input propertychange to the elements and update based on the change\n  bindChangeEvents() {\n    const { $textarea } = this\n    $textarea.addEventListener('keyup', this.handleKeyUp.bind(this))\n\n    // Bind focus/blur events to start/stop polling\n    $textarea.addEventListener('focus', this.handleFocus.bind(this))\n    $textarea.addEventListener('blur', this.handleBlur.bind(this))\n  }\n\n  // Speech recognition software such as Dragon NaturallySpeaking will modify the\n  // fields by directly changing its `value`. These changes don't trigger events\n  // in JavaScript, so we need to poll to handle when and if they occur.\n  checkIfValueChanged() {\n    if (!this.$textarea.oldValue) {\n      this.$textarea.oldValue = ''\n    }\n    if (this.$textarea.value !== this.$textarea.oldValue) {\n      this.$textarea.oldValue = this.$textarea.value\n      this.updateCountMessage()\n    }\n  }\n\n  // Helper function to update both the visible and screen reader-specific\n  // counters simultaneously (e.g. on init)\n  updateCountMessage() {\n    this.updateVisibleCountMessage()\n    this.updateScreenReaderCountMessage()\n  }\n\n  // Update visible counter\n  updateVisibleCountMessage() {\n    const { $textarea } = this\n    const { $visibleCountMessage } = this\n    const remainingNumber = this.maxLength - this.count($textarea.value)\n\n    // If input is over the threshold, remove the disabled class which renders the\n    // counter invisible.\n    if (this.isOverThreshold()) {\n      $visibleCountMessage.classList.remove(\n        'nhsuk-character-count__message--disabled'\n      )\n    } else {\n      $visibleCountMessage.classList.add(\n        'nhsuk-character-count__message--disabled'\n      )\n    }\n\n    // Update styles\n    if (remainingNumber < 0) {\n      $textarea.classList.add('nhsuk-textarea--error')\n      $visibleCountMessage.classList.remove('nhsuk-hint')\n      $visibleCountMessage.classList.add('nhsuk-error-message')\n    } else {\n      $textarea.classList.remove('nhsuk-textarea--error')\n      $visibleCountMessage.classList.remove('nhsuk-error-message')\n      $visibleCountMessage.classList.add('nhsuk-hint')\n    }\n\n    // Update message\n    $visibleCountMessage.innerHTML = this.formattedUpdateMessage()\n  }\n\n  // Update screen reader-specific counter\n  updateScreenReaderCountMessage() {\n    const { $screenReaderCountMessage } = this\n\n    // If over the threshold, remove the aria-hidden attribute, allowing screen\n    // readers to announce the content of the element.\n    if (this.isOverThreshold()) {\n      $screenReaderCountMessage.removeAttribute('aria-hidden')\n    } else {\n      $screenReaderCountMessage.setAttribute('aria-hidden', true)\n    }\n\n    // Update message\n    $screenReaderCountMessage.innerHTML = this.formattedUpdateMessage()\n  }\n\n  // Format update message\n  formattedUpdateMessage() {\n    const { $textarea } = this\n    const { options } = this\n    const remainingNumber = this.maxLength - this.count($textarea.value)\n\n    let charVerb = 'remaining'\n    let charNoun = 'character'\n    let displayNumber = remainingNumber\n    if (options.maxwords) {\n      charNoun = 'word'\n    }\n    charNoun += remainingNumber === -1 || remainingNumber === 1 ? '' : 's'\n\n    charVerb = remainingNumber < 0 ? 'too many' : 'remaining'\n    displayNumber = Math.abs(remainingNumber)\n\n    return `You have ${displayNumber} ${charNoun} ${charVerb}`\n  }\n\n  // Checks whether the value is over the configured threshold for the input.\n  // If there is no configured threshold, it is set to 0 and this function will\n  // always return true.\n  isOverThreshold() {\n    const { $textarea } = this\n    const { options } = this\n\n    // Determine the remaining number of characters/words\n    const currentLength = this.count($textarea.value)\n    const { maxLength } = this\n\n    // Set threshold if presented in options\n    const thresholdPercent = options.threshold ? options.threshold : 0\n    const thresholdValue = (maxLength * thresholdPercent) / 100\n\n    return thresholdValue <= currentLength\n  }\n\n  // Update the visible character counter and keep track of when the last update\n  // happened for each keypress\n  handleKeyUp() {\n    this.updateVisibleCountMessage()\n    this.lastInputTimestamp = Date.now()\n  }\n\n  handleFocus() {\n    // If the field is focused, and a keyup event hasn't been detected for at\n    // least 1000 ms (1 second), then run the manual change check.\n    // This is so that the update triggered by the manual comparison doesn't\n    // conflict with debounced KeyboardEvent updates.\n    this.valueChecker = setInterval(() => {\n      if (\n        !this.lastInputTimestamp ||\n        Date.now() - 500 >= this.lastInputTimestamp\n      ) {\n        this.checkIfValueChanged()\n      }\n    }, 1000)\n  }\n\n  handleBlur() {\n    // Cancel value checking on blur\n    clearInterval(this.valueChecker)\n  }\n}\n\nCharacterCount.prototype.defaults = {\n  characterCountAttribute: 'data-maxlength',\n  wordCountAttribute: 'data-maxwords'\n}\n\nmodule.exports = ({ scope = document } = {}) => {\n  const characterCounts = scope.querySelectorAll(\n    '[data-module=\"nhsuk-character-count\"]'\n  )\n  characterCounts.forEach((el) => {\n    new CharacterCount(el).init()\n  })\n}\n","const { toggleConditionalInput } = require('../../common')\n\n/**\n * Conditionally show content when a checkbox button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/checkboxes/conditional.html\n */\nconst syncAllConditionalReveals = function syncAllConditionalReveals(input) {\n  const allInputsInForm = input.form.querySelectorAll('input[type=\"checkbox\"]')\n  allInputsInForm.forEach((item) =>\n    toggleConditionalInput(item, 'nhsuk-checkboxes__conditional--hidden')\n  )\n}\n\n/**\n * Uncheck other checkboxes\n *\n * Find any other checkbox inputs with the checkbox group value, and uncheck them.\n * This is useful for when a “None of these\" checkbox is checked.\n */\nconst unCheckAllInputsExcept = function unCheckAllInputsExcept(input) {\n  const allInputsInSameExclusiveGroup = input.form.querySelectorAll(\n    `input[type=\"checkbox\"][data-checkbox-exclusive-group=\"${input.getAttribute('data-checkbox-exclusive-group')}\"]`\n  )\n\n  allInputsInSameExclusiveGroup.forEach((inputWithSameName) => {\n    const hasSameFormOwner = input.form === inputWithSameName.form\n    if (hasSameFormOwner && inputWithSameName !== input) {\n      inputWithSameName.checked = false // eslint-disable-line no-param-reassign\n    }\n  })\n\n  syncAllConditionalReveals(input)\n}\n\n/**\n * Uncheck exclusive inputs\n *\n * Find any checkbox inputs with the same checkbox group value and the 'exclusive' behaviour,\n * and uncheck them. This helps prevent someone checking both a regular checkbox and a\n * \"None of these\" checkbox in the same fieldset.\n */\nconst unCheckExclusiveInputs = function unCheckExclusiveInputs(input) {\n  const allExclusiveInputsInSameExclusiveGroup = input.form.querySelectorAll(\n    `input[type=\"checkbox\"][data-checkbox-exclusive][data-checkbox-exclusive-group=\"${input.getAttribute(\n      'data-checkbox-exclusive-group'\n    )}\"]`\n  )\n\n  allExclusiveInputsInSameExclusiveGroup.forEach((exclusiveInput) => {\n    const hasSameFormOwner = input.form === exclusiveInput.form\n    if (hasSameFormOwner) {\n      exclusiveInput.checked = false // eslint-disable-line no-param-reassign\n    }\n  })\n\n  syncAllConditionalReveals(input)\n}\n\nmodule.exports = ({ scope = document } = {}) => {\n  // Checkbox input DOMElements inside a conditional form group\n  const checkboxInputs = scope.querySelectorAll(\n    '.nhsuk-checkboxes .nhsuk-checkboxes__input'\n  )\n\n  /**\n   * Toggle classes and attributes\n   * @param {Object} event click event object\n   */\n  const handleClick = (event) => {\n    // Toggle conditional content based on checked state\n    toggleConditionalInput(\n      event.target,\n      'nhsuk-checkboxes__conditional--hidden'\n    )\n\n    if (!event.target.checked) {\n      return\n    }\n\n    // Handle 'exclusive' checkbox behaviour (ie \"None of these\")\n    if (event.target.hasAttribute('data-checkbox-exclusive')) {\n      unCheckAllInputsExcept(event.target)\n    } else {\n      unCheckExclusiveInputs(event.target)\n    }\n  }\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', () =>\n      checkboxInputs.forEach((input) => syncAllConditionalReveals(input))\n    )\n  } else {\n    window.addEventListener('DOMContentLoaded', () =>\n      checkboxInputs.forEach((input) => syncAllConditionalReveals(input))\n    )\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  checkboxInputs.forEach((input) => syncAllConditionalReveals(input))\n\n  // Attach handleClick as click to checkboxInputs\n  checkboxInputs.forEach((checkboxButton) => {\n    checkboxButton.addEventListener('change', handleClick)\n  })\n}\n","const { toggleAttribute } = require('../../common')\n\n/**\n * Ensure details component is cross browser and accessible\n * Test at http://localhost:3000/nhsuk-frontend/components/details/index.html\n */\n\nmodule.exports = ({ scope = document } = {}) => {\n  // Does the browser support details component\n  const nativeSupport =\n    typeof document.createElement('details').open === 'boolean'\n  if (nativeSupport) {\n    return\n  }\n\n  // Nodelist of all details elements\n  const allDetails = scope.querySelectorAll('details')\n\n  /**\n   * Adds all necessary functionality to a details element\n   * @param {HTMLElement} element details element to initialise\n   * @param {number} index number to be appended to dynamic IDs\n   */\n  const initDetails = (element, index) => {\n    // Set details element as polyfilled to prevent duplicate events being added\n    element.setAttribute('nhsuk-polyfilled', 'true')\n\n    // Give details element an ID if it doesn't already have one\n    if (!element.id) element.setAttribute('id', `nhsuk-details${index}`)\n\n    // Set content element and give it an ID if it doesn't already have one\n    const content = scope.querySelector(`#${element.id} .nhsuk-details__text`)\n    if (!content.id) content.setAttribute('id', `nhsuk-details__text${index}`)\n\n    // Set summary element\n    const summary = scope.querySelector(\n      `#${element.id} .nhsuk-details__summary`\n    )\n\n    // Set initial summary aria attributes\n    summary.setAttribute('role', 'button')\n    summary.setAttribute('aria-controls', content.id)\n    summary.setAttribute('tabIndex', '0')\n    const openAttr = element.getAttribute('open') !== null\n    if (openAttr === true) {\n      summary.setAttribute('aria-expanded', 'true')\n      content.setAttribute('aria-hidden', 'false')\n    } else {\n      summary.setAttribute('aria-expanded', 'false')\n      content.setAttribute('aria-hidden', 'true')\n      content.style.display = 'none'\n    }\n\n    const toggleDetails = () => {\n      toggleAttribute(summary, 'aria-expanded')\n      toggleAttribute(content, 'aria-hidden')\n\n      content.style.display =\n        content.getAttribute('aria-hidden') === 'true' ? 'none' : ''\n      if (element.hasAttribute('open')) {\n        element.removeAttribute('open')\n      } else {\n        element.setAttribute('open', 'open')\n      }\n    }\n\n    // Toggle details onclick\n    summary.addEventListener('click', toggleDetails)\n\n    // Call toggle details on enter and space key events\n    summary.addEventListener('keydown', (event) => {\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault()\n        summary.click()\n      }\n    })\n  }\n\n  // Initialise details for any new details element\n  if (allDetails.length) {\n    allDetails.forEach((element, index) => {\n      if (!element.hasAttribute('nhsuk-polyfilled')) initDetails(element, index)\n    })\n  }\n}\n","/**\n * Adapted from https://github.com/alphagov/govuk-frontend/blob/master/src/govuk/components/error-summary/error-summary.js\n */\n\n/**\n * Get associated legend or label\n *\n * Returns the first element that exists from this list:\n *\n * - The `<legend>` associated with the closest `<fieldset>` ancestor, as long\n *   as the top of it is no more than half a viewport height away from the\n *   bottom of the input\n * - The first `<label>` that is associated with the input using for='inputId'\n * - The closest parent `<label>`\n */\nfunction getAssociatedLegendOrLabel(input) {\n  const fieldset = input.closest('fieldset')\n\n  if (fieldset) {\n    const legends = fieldset.getElementsByTagName('legend')\n\n    if (legends.length) {\n      const candidateLegend = legends[0] // eslint-disable-line prefer-destructuring\n\n      // If the input type is radio or checkbox, always use the legend if there\n      // is one.\n      if (input.type === 'checkbox' || input.type === 'radio') {\n        return candidateLegend\n      }\n\n      // For other input types, only scroll to the fieldset’s legend (instead of\n      // the label associated with the input) if the input would end up in the\n      // top half of the screen.\n      //\n      // This should avoid situations where the input either ends up off the\n      // screen, or obscured by a software keyboard.\n      const legendTop = candidateLegend.getBoundingClientRect().top\n      const inputRect = input.getBoundingClientRect()\n\n      // If the browser doesn't support Element.getBoundingClientRect().height\n      // or window.innerHeight (like IE8), bail and just link to the label.\n      if (inputRect.height && window.innerHeight) {\n        const inputBottom = inputRect.top + inputRect.height\n\n        if (inputBottom - legendTop < window.innerHeight / 2) {\n          return candidateLegend\n        }\n      }\n    }\n  }\n\n  return (\n    document.querySelector(`label[for='${input.getAttribute('id')}']`) ||\n    input.closest('label')\n  )\n}\n\n/**\n * Focus the target element\n *\n * By default, the browser will scroll the target into view. Because our labels\n * or legends appear above the input, this means the user will be presented with\n * an input without any context, as the label or legend will be off the top of\n * the screen.\n *\n * Manually handling the click event, scrolling the question into view and then\n * focussing the element solves this.\n *\n * This also results in the label and/or legend being announced correctly in\n * NVDA - without this only the field type is announced\n * (e.g. 'Edit, has autocomplete').\n */\nfunction focusTarget(target) {\n  // If the element that was clicked was not a link, return early\n  if (target.tagName !== 'A' || target.href === false) {\n    return false\n  }\n\n  const input = document.querySelector(target.hash)\n  if (!input) {\n    return false\n  }\n\n  const legendOrLabel = getAssociatedLegendOrLabel(input)\n  if (!legendOrLabel) {\n    return false\n  }\n\n  // Scroll the legend or label into view *before* calling focus on the input to\n  // avoid extra scrolling in browsers that don't support `preventScroll` (which\n  // at time of writing is most of them...)\n  legendOrLabel.scrollIntoView()\n  input.focus({ preventScroll: true })\n\n  return true\n}\n\n/**\n * Handle click events on the error summary\n */\nfunction handleClick(event) {\n  if (focusTarget(event.target)) {\n    event.preventDefault()\n  }\n}\n\nmodule.exports = ({ focusOnPageLoad = true, scope = document } = {}) => {\n  // Error summary component\n  const errorSummary = scope.querySelector('.nhsuk-error-summary')\n\n  if (errorSummary) {\n    // Focus error summary component if it exists\n\n    if (focusOnPageLoad) {\n      errorSummary.focus()\n    }\n    errorSummary.addEventListener('click', handleClick)\n  }\n}\n","/**\n * Header component\n *\n */\n\nclass Header {\n  constructor() {\n    this.menuIsOpen = false\n    this.navigation = document.querySelector('.nhsuk-navigation')\n    this.navigationList = document.querySelector(\n      '.nhsuk-header__navigation-list'\n    )\n    this.mobileMenu = document.createElement('ul')\n    this.mobileMenuToggleButton = document.querySelector(\n      '.nhsuk-header__menu-toggle'\n    )\n    this.mobileMenuCloseButton = document.createElement('button')\n    this.mobileMenuContainer = document.querySelector(\n      '.nhsuk-mobile-menu-container'\n    )\n    this.breakpoints = []\n    this.width = document.body.offsetWidth\n  }\n\n  init() {\n    if (\n      !this.navigation ||\n      !this.navigationList ||\n      !this.mobileMenuToggleButton ||\n      !this.mobileMenuContainer\n    ) {\n      return\n    }\n\n    this.setupMobileMenu()\n    this.calculateBreakpoints()\n    this.updateNavigation()\n    this.doOnOrientationChange()\n\n    this.handleResize = this.debounce(() => {\n      this.calculateBreakpoints()\n      this.updateNavigation()\n    })\n\n    this.mobileMenuToggleButton.addEventListener(\n      'click',\n      this.toggleMobileMenu.bind(this)\n    )\n    window.addEventListener('resize', this.handleResize)\n    window.addEventListener('orientationchange', this.doOnOrientationChange())\n  }\n\n  debounce(func, timeout = 100) {\n    let timer\n    return (...args) => {\n      clearTimeout(timer)\n      timer = setTimeout(() => {\n        func.apply(this, args)\n      }, timeout)\n    }\n  }\n\n  /**\n   * Calculate breakpoints.\n   *\n   * Calculate the breakpoints by summing the widths of\n   * each navigation item.\n   *\n   */\n  calculateBreakpoints() {\n    // Get the width of the gap between each navigation item\n    const navigationListStyles = window.getComputedStyle(this.navigationList)\n    const gapPixels = navigationListStyles.getPropertyValue('gap')\n    const gap = Number(gapPixels.replace('px', ''))\n\n    let childrenWidth = 0\n    for (let i = 0; i < this.navigationList.children.length; i++) {\n      childrenWidth += this.navigationList.children[i].offsetWidth + gap\n      this.breakpoints[i] = childrenWidth\n    }\n  }\n\n  // Add the mobile menu to the DOM\n  setupMobileMenu() {\n    this.mobileMenuContainer.appendChild(this.mobileMenu)\n    this.mobileMenu.classList.add(\n      'nhsuk-header__drop-down',\n      'nhsuk-header__drop-down--hidden'\n    )\n  }\n\n  /**\n   * Close the mobile menu\n   *\n   * Closes the mobile menu and updates accessibility state.\n   *\n   * Removes the margin-bottom from the navigation\n   */\n  closeMobileMenu() {\n    this.menuIsOpen = false\n    this.mobileMenu.classList.add('nhsuk-header__drop-down--hidden')\n    this.navigation.style.marginBottom = 0\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'false')\n    this.mobileMenuToggleButton.focus()\n    this.mobileMenuCloseButton.removeEventListener(\n      'click',\n      this.closeMobileMenu.bind(this)\n    )\n    document.removeEventListener('keydown', this.handleEscapeKey.bind(this))\n  }\n\n  /**\n   * Escape key handler\n   *\n   * This function is called when the user\n   * presses the escape key to close the mobile menu.\n   *\n   */\n  handleEscapeKey(e) {\n    if (e.key === 'Escape') {\n      this.closeMobileMenu()\n    }\n  }\n\n  /**\n   * Open the mobile menu\n   *\n   * Opens the mobile menu and updates accessibility state.\n   *\n   * The mobile menu is absolutely positioned, so it adds a margin\n   * to the bottom of the navigation to prevent it from overlapping\n   *\n   * Adds event listeners for the close button,\n   */\n\n  openMobileMenu() {\n    this.menuIsOpen = true\n    this.mobileMenu.classList.remove('nhsuk-header__drop-down--hidden')\n    const marginBody = this.mobileMenu.offsetHeight\n    this.navigation.style.marginBottom = `${marginBody}px`\n    this.mobileMenuToggleButton.setAttribute('aria-expanded', 'true')\n\n    // add event listener for esc key to close menu\n    document.addEventListener('keydown', this.handleEscapeKey.bind(this))\n\n    // add event listener for close icon to close menu\n    this.mobileMenuCloseButton.addEventListener(\n      'click',\n      this.closeMobileMenu.bind(this)\n    )\n  }\n\n  /**\n   * Handle menu button click\n   *\n   * Toggles the mobile menu between open and closed\n   */\n  toggleMobileMenu() {\n    if (this.menuIsOpen) {\n      this.closeMobileMenu()\n    } else {\n      this.openMobileMenu()\n    }\n  }\n\n  /**\n   * Update nav for the available space\n   *\n   * If the available space is less than the current breakpoint,\n   * add the mobile menu toggle button and move the last\n   * item in the list to the drop-down list.\n   *\n   * If the available space is greater than the current breakpoint,\n   * remove the mobile menu toggle button and move the first item in the\n   *\n   * Additionally will close the mobile menu if the window gets resized\n   * and the menu is open.\n   */\n\n  updateNavigation() {\n    const availableSpace = this.navigationList.offsetWidth\n    let itemsVisible = this.navigationList.children.length\n\n    if (availableSpace < this.breakpoints[itemsVisible - 1]) {\n      this.mobileMenuToggleButton.classList.add(\n        'nhsuk-header__menu-toggle--visible'\n      )\n      this.mobileMenuContainer.classList.add(\n        'nhsuk-mobile-menu-container--visible'\n      )\n      if (itemsVisible === 2) {\n        return\n      }\n      while (availableSpace < this.breakpoints[itemsVisible - 1]) {\n        this.mobileMenu.insertBefore(\n          this.navigationList.children[itemsVisible - 2],\n          this.mobileMenu.firstChild\n        )\n        itemsVisible -= 1\n      }\n    } else if (availableSpace > this.breakpoints[itemsVisible]) {\n      while (availableSpace > this.breakpoints[itemsVisible]) {\n        this.navigationList.insertBefore(\n          this.mobileMenu.removeChild(this.mobileMenu.firstChild),\n          this.mobileMenuContainer\n        )\n        itemsVisible += 1\n      }\n    }\n\n    if (!this.mobileMenu.children.length) {\n      this.mobileMenuToggleButton.classList.remove(\n        'nhsuk-header__menu-toggle--visible'\n      )\n      this.mobileMenuContainer.classList.remove(\n        'nhsuk-mobile-menu-container--visible'\n      )\n    }\n\n    if (document.body.offsetWidth !== this.width && this.menuIsOpen) {\n      this.closeMobileMenu()\n    }\n  }\n\n  /**\n   * Orientation change\n   *\n   * Check the orientation of the device, if changed it will trigger a\n   * update to the breakpoints and navigation.\n   */\n  doOnOrientationChange() {\n    switch (window.orientation) {\n      case 90:\n        setTimeout(() => {\n          this.calculateBreakpoints()\n          this.updateNavigation()\n        }, 200)\n        break\n      default:\n        break\n    }\n  }\n}\n\nmodule.exports = () => {\n  new Header().init()\n}\n","const { toggleConditionalInput } = require('../../common')\n\n/**\n * Conditionally show content when a radio button is checked\n * Test at http://localhost:3000/nhsuk-frontend/components/radios/conditional.html\n */\n\nmodule.exports = ({ scope = document } = {}) => {\n  // Radio input HTMLElements inside a conditional form group\n  const radioInputs = scope.querySelectorAll(\n    '.nhsuk-radios--conditional .nhsuk-radios__input'\n  )\n\n  /**\n   * Update all conditional reveals to match checked state\n   */\n  const syncAllConditionalReveals = () => {\n    radioInputs.forEach((input) =>\n      toggleConditionalInput(input, 'nhsuk-radios__conditional--hidden')\n    )\n  }\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  if ('onpageshow' in window) {\n    window.addEventListener('pageshow', syncAllConditionalReveals)\n  } else {\n    window.addEventListener('DOMContentLoaded', syncAllConditionalReveals)\n  }\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  syncAllConditionalReveals()\n\n  // Attach event handler to radioInputs\n  radioInputs.forEach((radioButton) => {\n    radioButton.addEventListener('change', syncAllConditionalReveals)\n  })\n}\n","const { setFocus } = require('../../common')\n\n/*\n * NHS.UK skip link.\n *\n * When using VoiceOver on iOS, focus remains on the skip link anchor\n * when elected so the next focusable element is not at the jumped to area.\n */\n\nmodule.exports = () => {\n  const $skipLink = document.querySelector('.nhsuk-skip-link')\n\n  // Check for skip link\n  if (!$skipLink || !($skipLink instanceof HTMLAnchorElement)) {\n    return\n  }\n\n  const linkedElementId = $skipLink.hash.split('#').pop()\n  const $linkedElement = linkedElementId\n    ? document.getElementById(linkedElementId)\n    : null\n\n  // Check for linked element\n  if (!$linkedElement) {\n    return\n  }\n\n  /**\n   * Focus the linked element on click\n   *\n   * Adds a helper CSS class to hide native focus styles,\n   * but removes it on blur to restore native focus styles\n   */\n  $skipLink.addEventListener('click', () =>\n    setFocus($linkedElement, {\n      onBeforeFocus() {\n        $linkedElement.classList.add('nhsuk-skip-link-focused-element')\n      },\n      onBlur() {\n        $linkedElement.classList.remove('nhsuk-skip-link-focused-element')\n      }\n    })\n  )\n}\n","class Tabs {\n  constructor($module, namespace, responsive, historyEnabled) {\n    this.$module = $module\n    this.namespace = namespace\n    this.responsive = responsive\n    this.historyEnabled = historyEnabled\n    this.$tabs = $module.querySelectorAll(`.${this.namespace}__tab`)\n\n    this.keys = {\n      down: 40,\n      left: 37,\n      right: 39,\n      up: 38\n    }\n    this.jsHiddenClass = `${this.namespace}__panel--hidden`\n\n    this.showEvent = new CustomEvent('tab.show')\n    this.hideEvent = new CustomEvent('tab.hide')\n  }\n\n  init() {\n    if (typeof window.matchMedia === 'function' && this.responsive) {\n      this.setupResponsiveChecks()\n    } else {\n      this.setup()\n    }\n  }\n\n  setupResponsiveChecks() {\n    // $mq-breakpoints: (\n    // mobile: 320px,\n    // tablet: 641px,\n    // desktop: 769px,\n    // large - desktop: 990px\n    // );\n    this.mql = window.matchMedia('(min-width: 641px)')\n\n    // MediaQueryList.addEventListener isn't supported by Safari < 14 so we need\n    // to be able to fall back to the deprecated MediaQueryList.addListener\n    if ('addEventListener' in this.mql) {\n      this.mql.addEventListener('change', this.checkMode.bind(this))\n    } else {\n      // addListener is a deprecated function, however addEventListener\n      // isn't supported by Safari < 14. We therefore add this in as\n      // a fallback for those browsers\n      this.mql.addListener(this.checkMode.bind(this))\n    }\n\n    this.checkMode()\n  }\n\n  checkMode() {\n    if (this.mql.matches) {\n      this.setup()\n    } else {\n      this.teardown()\n    }\n  }\n\n  setup() {\n    const { $module } = this\n    const { $tabs } = this\n    const $tabList = $module.querySelector(`.${this.namespace}__list`)\n    const $tabListItems = $module.querySelectorAll(\n      `.${this.namespace}__list-item`\n    )\n\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return\n    }\n\n    $tabList.setAttribute('role', 'tablist')\n\n    $tabListItems.forEach(($item) => {\n      $item.setAttribute('role', 'presentation')\n    })\n\n    $tabs.forEach(($tab) => {\n      // Set HTML attributes\n      this.setAttributes($tab)\n\n      // Save bounded functions to use when removing event listeners during teardown\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabClick = this.onTabClick.bind(this)\n      // eslint-disable-next-line no-param-reassign\n      $tab.boundTabKeydown = this.onTabKeydown.bind(this)\n\n      // Handle events\n      $tab.addEventListener('click', $tab.boundTabClick, true)\n      $tab.addEventListener('keydown', $tab.boundTabKeydown, true)\n\n      // Remove old active panels\n      this.hideTab($tab)\n    })\n\n    // Show either the active tab according to the URL's hash or the first tab\n    const $activeTab = this.getTab(window.location.hash) || this.$tabs[0]\n    this.showTab($activeTab)\n\n    // Handle hashchange events\n    if (this.historyEnabled) {\n      $module.boundOnHashChange = this.onHashChange.bind(this)\n      window.addEventListener('hashchange', $module.boundOnHashChange, true)\n    }\n  }\n\n  teardown() {\n    const { $module } = this\n    const { $tabs } = this\n    const $tabList = $module.querySelector(`.${this.namespace}__list`)\n    const $tabListItems = $module.querySelectorAll(\n      `.${this.namespace}__list-item`\n    )\n\n    if (!$tabs || !$tabList || !$tabListItems) {\n      return\n    }\n\n    $tabList.removeAttribute('role')\n\n    $tabListItems.forEach(($item) => {\n      $item.removeAttribute('role', 'presentation')\n    })\n\n    $tabs.forEach(($tab) => {\n      // Remove events\n      $tab.removeEventListener('click', $tab.boundTabClick, true)\n      $tab.removeEventListener('keydown', $tab.boundTabKeydown, true)\n\n      // Unset HTML attributes\n      this.unsetAttributes($tab)\n    })\n\n    if (this.historyEnabled) {\n      // Remove hashchange event handler\n      window.removeEventListener('hashchange', $module.boundOnHashChange, true)\n    }\n  }\n\n  onHashChange() {\n    const { hash } = window.location\n    const $tabWithHash = this.getTab(hash)\n    if (!$tabWithHash) {\n      return\n    }\n\n    // Prevent changing the hash\n    if (this.changingHash) {\n      this.changingHash = false\n      return\n    }\n\n    // Show either the active tab according to the URL's hash or the first tab\n    const $previousTab = this.getCurrentTab()\n\n    this.hideTab($previousTab)\n    this.showTab($tabWithHash)\n    $tabWithHash.focus()\n  }\n\n  hideTab($tab) {\n    this.unhighlightTab($tab)\n    this.hidePanel($tab)\n  }\n\n  showTab($tab) {\n    this.highlightTab($tab)\n    this.showPanel($tab)\n  }\n\n  getTab(hash) {\n    return this.$module.querySelector(`.${this.namespace}__tab[href=\"${hash}\"]`)\n  }\n\n  setAttributes($tab) {\n    // set tab attributes\n    const panelId = Tabs.getHref($tab).slice(1)\n    $tab.setAttribute('id', `tab_${panelId}`)\n    $tab.setAttribute('role', 'tab')\n    $tab.setAttribute('aria-controls', panelId)\n    $tab.setAttribute('aria-selected', 'false')\n    $tab.setAttribute('tabindex', '-1')\n\n    // set panel attributes\n    const $panel = this.getPanel($tab)\n    $panel.setAttribute('role', 'tabpanel')\n    $panel.setAttribute('aria-labelledby', $tab.id)\n    $panel.classList.add(this.jsHiddenClass)\n  }\n\n  unsetAttributes($tab) {\n    // unset tab attributes\n    $tab.removeAttribute('id')\n    $tab.removeAttribute('role')\n    $tab.removeAttribute('aria-controls')\n    $tab.removeAttribute('aria-selected')\n    $tab.removeAttribute('tabindex')\n\n    // unset panel attributes\n    const $panel = this.getPanel($tab)\n    $panel.removeAttribute('role')\n    $panel.removeAttribute('aria-labelledby')\n    $panel.removeAttribute('tabindex')\n    $panel.classList.remove(this.jsHiddenClass)\n  }\n\n  onTabClick(e) {\n    if (!e.target.classList.contains(`${this.namespace}__tab`)) {\n      e.stopPropagation()\n      e.preventDefault()\n    }\n    e.preventDefault()\n    const $newTab = e.target\n    const $currentTab = this.getCurrentTab()\n    this.hideTab($currentTab)\n    this.showTab($newTab)\n    this.createHistoryEntry($newTab)\n  }\n\n  createHistoryEntry($tab) {\n    if (this.historyEnabled) {\n      const $panel = this.getPanel($tab)\n\n      // Save and restore the id\n      // so the page doesn't jump when a user clicks a tab (which changes the hash)\n      const { id } = $panel\n      $panel.id = ''\n      this.changingHash = true\n      window.location.hash = Tabs.getHref($tab).slice(1)\n      $panel.id = id\n    }\n  }\n\n  onTabKeydown(e) {\n    switch (e.keyCode) {\n      case this.keys.left:\n      case this.keys.up:\n        this.activatePreviousTab()\n        e.preventDefault()\n        break\n      case this.keys.right:\n      case this.keys.down:\n        this.activateNextTab()\n        e.preventDefault()\n        break\n\n      default:\n    }\n  }\n\n  activateNextTab() {\n    const currentTab = this.getCurrentTab()\n    const nextTabListItem = currentTab.parentNode.nextElementSibling\n    let nextTab\n\n    if (nextTabListItem) {\n      nextTab = nextTabListItem.querySelector(`.${this.namespace}__tab`)\n    }\n    if (nextTab) {\n      this.hideTab(currentTab)\n      this.showTab(nextTab)\n      nextTab.focus()\n      this.createHistoryEntry(nextTab)\n    }\n  }\n\n  activatePreviousTab() {\n    const currentTab = this.getCurrentTab()\n    const previousTabListItem = currentTab.parentNode.previousElementSibling\n    let previousTab\n\n    if (previousTabListItem) {\n      previousTab = previousTabListItem.querySelector(`.${this.namespace}__tab`)\n    }\n    if (previousTab) {\n      this.hideTab(currentTab)\n      this.showTab(previousTab)\n      previousTab.focus()\n      this.createHistoryEntry(previousTab)\n    }\n  }\n\n  getPanel($tab) {\n    const $panel = this.$module.querySelector(Tabs.getHref($tab))\n    return $panel\n  }\n\n  showPanel($tab) {\n    const $panel = this.getPanel($tab)\n    $panel.classList.remove(this.jsHiddenClass)\n    $panel.dispatchEvent(this.showEvent)\n  }\n\n  hidePanel(tab) {\n    const $panel = this.getPanel(tab)\n    $panel.classList.add(this.jsHiddenClass)\n    $panel.dispatchEvent(this.hideEvent)\n  }\n\n  unhighlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'false')\n    $tab.parentNode.classList.remove(`${this.namespace}__list-item--selected`)\n    $tab.setAttribute('tabindex', '-1')\n  }\n\n  highlightTab($tab) {\n    $tab.setAttribute('aria-selected', 'true')\n    $tab.parentNode.classList.add(`${this.namespace}__list-item--selected`)\n    $tab.setAttribute('tabindex', '0')\n  }\n\n  getCurrentTab() {\n    return this.$module.querySelector(\n      `.${this.namespace}__list-item--selected .${this.namespace}__tab`\n    )\n  }\n\n  // this is because IE doesn't always return the actual value but a relative full path\n  // should be a utility function most prob\n  // http://labs.thesedays.com/blog/2010/01/08/getting-the-href-value-with-jquery-in-ie/\n  static getHref($tab) {\n    const href = $tab.getAttribute('href')\n    const hash = href.slice(href.indexOf('#'), href.length)\n    return hash\n  }\n}\n\n/**\n * Main function to invoke tabs. Can be called as follows to alter various features\n *\n * Tabs({historyEnabled: false});\n * Tabs({responsive: false});\n * Tabs({namespace: 'my-custom-namespace'});  // Alters classes allowing alternative css\n */\nmodule.exports = ({\n  namespace = 'nhsuk-tabs',\n  responsive = true,\n  historyEnabled = true,\n  scope = document\n} = {}) => {\n  const tabs = scope.querySelectorAll(`[data-module=\"${namespace}\"]`)\n  tabs.forEach((el) => {\n    new Tabs(el, namespace, responsive, historyEnabled).init()\n  })\n}\n","/* eslint-disable import/prefer-default-export */\n\n// Components\nconst initButton = require('./components/button/button')\nconst initCharacterCount = require('./components/character-count/character-count')\nconst initCheckboxes = require('./components/checkboxes/checkboxes')\nconst initDetails = require('./components/details/details')\nconst initErrorSummary = require('./components/error-summary/error-summary')\nconst initHeader = require('./components/header/header')\nconst initRadios = require('./components/radios/radios')\nconst initSkipLink = require('./components/skip-link/skip-link')\nconst initTabs = require('./components/tabs/tabs')\n\nrequire('./polyfills.js')\n\n/**\n * Use this function to initialise nhsuk-frontend components within a\n * given scope. This function is called by default with the document\n * element, but you can call it again later with a new DOM element\n * containing nhsuk-frontend components which you wish to initialise.\n *\n * @param {HTMLElement} scope\n */\nfunction initAll(scope) {\n  initButton({ scope })\n  initCharacterCount({ scope })\n  initCheckboxes({ scope })\n  initDetails({ scope })\n  initErrorSummary({ scope })\n  initRadios({ scope })\n  initTabs({ scope })\n}\n\n// Initialize components\ndocument.addEventListener('DOMContentLoaded', () => {\n  initHeader()\n  initSkipLink()\n\n  initAll(document)\n})\n\nmodule.exports = {\n  initAll\n}\n","/**\n * IE polyfill for NodeList.forEach()\n */\nif (!NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach\n}\n\n/**\n * IE polyfill for Array.includes()\n */\nif (!Array.prototype.includes) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Array.prototype, 'includes', {\n    enumerable: false,\n    value(obj) {\n      return this.filter((el) => el === obj).length > 0\n    }\n  })\n}\n\n/**\n * IE polyfill for Element.closest()\n */\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector\n}\n\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this\n\n    do {\n      if (Element.prototype.matches.call(el, s)) return el\n      el = el.parentElement || el.parentNode\n    } while (el !== null && el.nodeType === 1)\n    return null\n  }\n}\n\n/**\n * IE polyfill for CustomEvent\n */\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function (event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null }\n    var evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n    return evt\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(930);\n"]}