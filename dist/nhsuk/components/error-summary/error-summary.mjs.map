{"version":3,"file":"error-summary.mjs","sources":["../../../../src/nhsuk/components/error-summary/error-summary.mjs"],"sourcesContent":["/**\n * Error summary component\n *\n * Adapted from https://github.com/alphagov/govuk-frontend/blob/v2.13.0/src/components/error-summary/error-summary.js\n */\nexport class ErrorSummary {\n  /**\n   * @param {Element | null} [$root] - HTML element to use for component\n   * @param {ErrorSummaryConfig} [config] - Error summary config\n   */\n  constructor($root, config = {}) {\n    if (!$root || !($root instanceof HTMLElement)) {\n      return this\n    }\n\n    this.$root = $root\n    this.$root.addEventListener('click', this.handleClick.bind(this))\n\n    if (!config.disableAutoFocus) {\n      this.$root.focus()\n    }\n  }\n\n  /**\n   * Get associated legend or label\n   *\n   * Returns the first element that exists from this list:\n   *\n   * - The `<legend>` associated with the closest `<fieldset>` ancestor, as long\n   *   as the top of it is no more than half a viewport height away from the\n   *   bottom of the input\n   * - The first `<label>` that is associated with the input using for='inputId'\n   * - The closest parent `<label>`\n   */\n  getAssociatedLegendOrLabel(input) {\n    const fieldset = input.closest('fieldset')\n\n    if (fieldset) {\n      const legends = fieldset.getElementsByTagName('legend')\n\n      if (legends.length) {\n        const candidateLegend = legends[0] // eslint-disable-line prefer-destructuring\n\n        // If the input type is radio or checkbox, always use the legend if there\n        // is one.\n        if (input.type === 'checkbox' || input.type === 'radio') {\n          return candidateLegend\n        }\n\n        // For other input types, only scroll to the fieldsetâ€™s legend (instead of\n        // the label associated with the input) if the input would end up in the\n        // top half of the screen.\n        //\n        // This should avoid situations where the input either ends up off the\n        // screen, or obscured by a software keyboard.\n        const legendTop = candidateLegend.getBoundingClientRect().top\n        const inputRect = input.getBoundingClientRect()\n\n        // If the browser doesn't support Element.getBoundingClientRect().height\n        // or window.innerHeight (like IE8), bail and just link to the label.\n        if (inputRect.height && window.innerHeight) {\n          const inputBottom = inputRect.top + inputRect.height\n\n          if (inputBottom - legendTop < window.innerHeight / 2) {\n            return candidateLegend\n          }\n        }\n      }\n    }\n\n    return (\n      document.querySelector(`label[for='${input.getAttribute('id')}']`) ||\n      input.closest('label')\n    )\n  }\n\n  /**\n   * Focus the target element\n   *\n   * By default, the browser will scroll the target into view. Because our labels\n   * or legends appear above the input, this means the user will be presented with\n   * an input without any context, as the label or legend will be off the top of\n   * the screen.\n   *\n   * Manually handling the click event, scrolling the question into view and then\n   * focussing the element solves this.\n   *\n   * This also results in the label and/or legend being announced correctly in\n   * NVDA - without this only the field type is announced\n   * (e.g. 'Edit, has autocomplete').\n   */\n  focusTarget(target) {\n    // If the element that was clicked was not a link, return early\n    if (target.tagName !== 'A' || target.href === false) {\n      return false\n    }\n\n    const input = document.querySelector(target.hash)\n    if (!input) {\n      return false\n    }\n\n    const legendOrLabel = this.getAssociatedLegendOrLabel(input)\n    if (!legendOrLabel) {\n      return false\n    }\n\n    // Scroll the legend or label into view *before* calling focus on the input to\n    // avoid extra scrolling in browsers that don't support `preventScroll` (which\n    // at time of writing is most of them...)\n    legendOrLabel.scrollIntoView()\n    input.focus({ preventScroll: true })\n\n    return true\n  }\n\n  /**\n   * Handle click events on the error summary\n   */\n  handleClick(event) {\n    if (this.focusTarget(event.target)) {\n      event.preventDefault()\n    }\n  }\n}\n\n/**\n * Initialise error summary component\n *\n * @param {object} [options]\n * @param {Element | Document | null} [options.scope] - Scope of the document to search within\n * @param {boolean} [options.focusOnPageLoad] - If set to `false` the error\n *   summary will not be focussed when the page loads.\n */\nexport function initErrorSummary(options = {}) {\n  const $scope = options.scope || document\n  const $root = $scope.querySelector('.nhsuk-error-summary')\n\n  new ErrorSummary($root, {\n    disableAutoFocus: options.focusOnPageLoad === false\n  })\n}\n\n/**\n * Error summary config\n *\n * @typedef {object} ErrorSummaryConfig\n * @property {boolean} [disableAutoFocus=false] - If set to `true` the error\n *   summary will not be focussed when the page loads.\n */\n"],"names":["ErrorSummary","constructor","$root","config","HTMLElement","addEventListener","handleClick","bind","disableAutoFocus","focus","getAssociatedLegendOrLabel","input","fieldset","closest","legends","getElementsByTagName","length","candidateLegend","type","legendTop","getBoundingClientRect","top","inputRect","height","window","innerHeight","inputBottom","document","querySelector","getAttribute","focusTarget","target","tagName","href","hash","legendOrLabel","scrollIntoView","preventScroll","event","preventDefault","initErrorSummary","options","$scope","scope","focusOnPageLoad"],"mappings":"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"}